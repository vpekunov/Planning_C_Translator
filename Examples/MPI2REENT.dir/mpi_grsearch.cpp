// 05 processors

#include <stdio.h>
#include <math.h>
#include "mpi.h"

const double X0[4] = {3.0,-1.0,0.0,1.0}; /* Начальная точка поиска */
const double h = 0.005; /* Шаг поиска */

const double Eps = 1E-4; /* Точность расчета */

void main(int argc, char ** argv)
{
 int nProcs; /* Число процессоров */
 int MyProcID; /* Идентификатор текущего процессора */
 MPI_Status status;
 double X[4]; /* Текущая точка */
 double Gr, LGr; /* Gr -- значение одной из компонент градиента */
 double F1;
 int WorkFlag = 1; /* Признак продолжения работы */
 int i;
 	
 MPI_Init(&argc,&argv);
 MPI_Comm_size(MPI_COMM_WORLD,&nProcs);
 MPI_Comm_rank(MPI_COMM_WORLD,&MyProcID);

 /* Метод градиентного спуска. */
 /* Используется схема обменов типа "звезда". Главный процессор обменивается */
 /* данными с рабочими процессорами. */
 /* Процессор номер 0 -- главный. Используются еще 4 рабочих процессора, */
 /* т.е. всего используется 5 процессоров. */
 /* Рабочие процессоры вычисляют компоненты вектора градиента. */
 /* Процессор номер 1 вычисляет dF/dX1 и так далее. */
 if (nProcs>=5)
    {
     if (MyProcID==0)
        for (i=0; i<4; i++)
          X[i] = X0[i];
     if (MyProcID<5)
       while (WorkFlag)
        if (MyProcID==0)
           {
            /* Посылаем рабочим процессорам координаты текущей точки */
            for (i=1; i<5; i++)
              MPI_Send(X,4,MPI_DOUBLE,i,1234,MPI_COMM_WORLD);
            LGr = 0.0;
            /* Получаем от рабочих процессоров компоненты градиента */
            for (i=1; i<5; i++)
              {
               MPI_Recv(&Gr,1,MPI_DOUBLE,i,1234,MPI_COMM_WORLD,&status);
               /* Делаем шаг по одной из переменных в направлении антиградиента. */
               X[i-1] -= h*Gr;
               LGr += Gr*Gr; /* В LGr накапливаем длину вектора градиента */
              }
            /* Считаем значение целевой функции в новой точке */
            F1 = pow(X[0]+10.0*X[1],2.0)+5.0*pow(X[0]-X[3],2.0)+
                 pow(X[1]-2.0*X[2],4.0)+10.0*pow(X[0]-X[3],4.0);
            printf("F(%lf,%lf,%lf,%lf)=%lf\n",X[0],X[1],X[2],X[3],F1);
            if (sqrt(LGr)<=Eps) /* Если длина градиента меньше точности -- конец */
               WorkFlag = 0;
            /* Рассылаем рабочим указание продолжить или закончить работу */
            for (i=1; i<5; i++)
              MPI_Send(&WorkFlag,1,MPI_INT,i,1234,MPI_COMM_WORLD);
           }
        else
           {
            /* Рабочий процессор получает от главного координаты текущей точки */
            MPI_Recv(X,4,MPI_DOUBLE,0,1234,MPI_COMM_WORLD,&status);
            /* Каждый рабочий вычисляет свою компоненту градиента */
            if (MyProcID==1) /* dF/dX1 */
               Gr = 2.0*(X[0]+10.0*X[1])+10.0*(X[0]-X[3])+40.0*pow(X[0]-X[3],3.0);
            else if (MyProcID==2) /* dF/dX2 */
               Gr = 20.0*(X[0]+10.0*X[1])+4.0*pow(X[1]-2.0*X[2],3.0);
            else if (MyProcID==3) /* dF/dX3 */
               Gr = -8.0*pow(X[1]-2.0*X[2],3.0);
            else /* dF/dX4 */
               Gr = -10.0*(X[0]-X[3])-40.0*pow(X[0]-X[3],3.0);
            /* Отсылаем вычисленное значение компоненты градиента главному процессору */
            MPI_Send(&Gr,1,MPI_DOUBLE,0,1234,MPI_COMM_WORLD);
            /* Получаем указание продолжить или завершить работу */
            MPI_Recv(&WorkFlag,1,MPI_INT,0,1234,MPI_COMM_WORLD,&status);
           }
    }
 else
    printf("Должно быть 5 или больше процессоров\n");

 MPI_Finalize();
}