// 06 processors

#include <stdio.h>
#include <math.h>
#include "mpi.h"

const double X_0[3] = {4.0,-1.0,2.0}; /* Начальная точка перебора */
const double X_1[3] = {0.0,4.0,-6.0}; /* Конечная точка перебора */

const double Eps = 5E-2; /* Точность */

void main(int argc, char ** argv)
{
 int nProcs; /* Число процессоров */
 int MyProcID; /* Идентификатор текущего процессора */
 MPI_Status status;
 double X0[3]; /* Начальная точка перебора для текущего процессора */
 double X1[3]; /* Конечная точка перебора для текущего процессора */
 double dX[3]; /* Приращения по координатам для перебора */
 double X[3];  /* Текущая точка перебора для текущего процессора */
 double xm[3]; /* Точка с минимальным значением функции */
 int N[3];     /* Количество перебираемых точек по каждой координате */
 double F;     /* Текущее значение функции */
 double MinP;
 double XP[3];
 double Min = 1E30; /* Здесь окажется минимальное значение функции */
 int i,j,k,s;
 	
 MPI_Init(&argc,&argv);
 MPI_Comm_size(MPI_COMM_WORLD,&nProcs);
 MPI_Comm_rank(MPI_COMM_WORLD,&MyProcID);

 /* Используется любое число процессоров больше двух. Область сканирования */
 /* делится на столько частей, сколько процессоров. При этом каждый процессор */
 /* перебирает все возможные значения X2,X3, но лишь ЧАСТЬ значений X1. */
 /* Топология -- "труба". По окончании перебора нулевой процессор посылает */
 /* сведения о найденной им минимальной точке первому процессору, тот */
 /* сравнивает это значение со своей минимальной точкой, выбирает из них */
 /* меньшую и пересылает сведения о ней второму процессору, и так далее. */
 /* В итоге процессор с номером nProcs-1 сможет определить наименьшую точку */
 /* по заданной области поиска. */
 if (nProcs>=2)
    {
     /* Диапазон поиска по X1 делится на столько частей, сколько процессоров */
     N[0]  = fabs(X_1[0]-X_0[0])/nProcs/Eps;
     /* Каждому процессору достается часть этого диапазона. */
     X0[0] = X_0[0]+(X_1[0]-X_0[0])*MyProcID/nProcs;
     X1[0] = X_0[0]+(X_1[0]-X_0[0])*(MyProcID+1)/nProcs;
     dX[0] = (X1[0]-X0[0])/N[0];
     /* По X2,X3 каждый процессор перебирает весь диапазон. */
     for (i=1; i<3; i++)
       {
        N[i]  = fabs(X_1[i]-X_0[i])/Eps;
        X0[i] = X_0[i];
        X1[i] = X_1[i];
        dX[i] = (X1[i]-X0[i])/N[i];
       }
     /* Перебор в заданной области. */
     for (i=0, X[0]=X0[0]; i<N[0]; i++, X[0]+=dX[0])
       for (j=0, X[1]=X0[1]; j<N[1]; j++, X[1]+=dX[1])
         for (k=0, X[2]=X0[2]; k<N[2]; k++, X[2]+=dX[2])
           { /* Вычисляем значение функции в текущей точке X */
            F = pow(X[0]-1.0,4)+pow(X[1]-3.0,2)+4*pow(X[2]+5.0,4);
            if (F<Min) /* Сравниваем вычисленное значение с минимальным */
               {
                Min = F; /* Запоминаем минимальное значение функции */
                for (s=0; s<3; s++)
                  xm[s] = X[s]; /* Запоминаем координаты точки с минимальным значением */
               }
           }
     /* Перебор окончен. */
     if (MyProcID>0)
        {
         /* Все процессоры, кроме нулевого, принимают от предыдущего */
         /* процессора (соседа слева) значение функции и координаты */
         /* той точки, которую соседний процессор считает точкой минимума */
         MPI_Recv(&MinP,1,MPI_DOUBLE,MyProcID-1,1234,MPI_COMM_WORLD,&status);
         MPI_Recv(XP,3,MPI_DOUBLE,MyProcID-1,1234,MPI_COMM_WORLD,&status);
         if (MinP<Min)
            { /* Если принятое значение меньше того значения, */
              /* которое текущий процессор считал минимальным, то теперь */
              /* будем считать минимальным принятое значение. */
             Min = MinP;
             for (s=0; s<3; s++)
               xm[s] = XP[s];
            }
         /* Последний процессор выводит на экран координаты минимальной */
         /* точки и значение функции в ней. */
         if (MyProcID==nProcs-1)
            printf("F(%lf,%lf,%lf) = %lf\n",xm[0],xm[1],xm[2],Min);
        }
     /* Каждый процессор (кроме последнего), посылает соседу справа то значение, */
     /* которое является минимальным в той части области, которая обрабатывалась */
     /* им и его соседями слева. */
     if (MyProcID<nProcs-1)
        { /* Посылаем и значение функции и координаты точки минимума */
         MPI_Send(&Min,1,MPI_DOUBLE,MyProcID+1,1234,MPI_COMM_WORLD);
         MPI_Send(xm,3,MPI_DOUBLE,MyProcID+1,1234,MPI_COMM_WORLD);
        }
    }
 else
    printf("Должно быть 2 или больше процессоров\n");

 MPI_Finalize();
}