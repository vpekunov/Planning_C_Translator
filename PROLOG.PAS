Unit Prolog;

Interface

{$IFDEF FPC}
{$MODE ObjFPC}
{$ENDIF}
{$H+}

Procedure WriteProlog(Var Out: TextFile; IsClustered, IsVectorized: Boolean);

Implementation

Uses Common, Consts, Topo;

{$INCLUDE SHMEM.PAS}
{$INCLUDE LISTS.PAS}

Procedure WriteProlog(Var Out: TextFile; IsClustered, IsVectorized: Boolean);
Begin
  If IsClustered Then
     WriteLn(Out,'#define __REENT_MPI__');
  If IsVectorized Then
     WriteLn(Out,'#define __REENT_GPU__');
  WriteLn(Out,'#define __global /* global */');
  WriteLn(Out,'#define __local  /* local  */');
  WriteLn(Out,'#define __constant /* constant */');
  WriteLn(Out,'#define __private  /* private  */');
  WriteLn(Out,'#define barrier(N) /* barrier */');
  WriteLn(Out,'#define mem_fence(N) /* mem_fence */');
  WriteLn(Out,'#define read_mem_fence(N) /* read_mem_fence */');
  WriteLn(Out,'#define write_mem_fence(N) /* write_mem_fence */');
  WriteLn(Out,'#define CLK_LOCAL_MEM_FENCE (1<<0)');
  WriteLn(Out,'#define CLK_GLOBAL_MEM_FENCE (1<<1)');
  WriteLn(Out,'#ifdef __REENT_GPU__');
  WriteLn(Out,' #ifdef __APPLE__');
  WriteLn(Out,'  #include <OpenCL/opencl.h>');
  WriteLn(Out,' #else');
  WriteLn(Out,'  #include <CL/cl.h>');
  WriteLn(Out,' #endif');
  WriteLn(Out,'');
  WriteLn(Out,' #include <map>');
  WriteLn(Out,' #include <string>');
  WriteLn(Out,' #include <string.h>');
  WriteLn(Out,' #include <stdlib.h>');
  WriteLn(Out,' #include <iostream>');
  WriteLn(Out,' #include <omp.h>');
  WriteLn(Out,'');
  WriteLn(Out,' using namespace std;');
  WriteLn(Out,'');
  WriteLn(Out,' #define MAX_PLATFORMS 100 ');
  WriteLn(Out,' #define MAX_DEVICES 100');
  WriteLn(Out,'');
  WriteLn(Out,' typedef struct {');
  WriteLn(Out,'   bool             online;');
  WriteLn(Out,'   cl_platform_id   platform_id;');
  WriteLn(Out,'   cl_device_id     device_id;');
  WriteLn(Out,'   cl_uint          n_units;');
  WriteLn(Out,'   cl_ulong         local_mem_size;');
  WriteLn(Out,'   size_t           max_work_size;');
  WriteLn(Out,'   cl_context       context;');
  WriteLn(Out,'   cl_command_queue command_queue;');
  WriteLn(Out,'   double           compile_time;');
  WriteLn(Out,'   double           execution_time;');
  WriteLn(Out,' } __device;');
  WriteLn(Out,'');
  WriteLn(Out,' map<string, __device> __devices;');
  WriteLn(Out,'');
  WriteLn(Out,' string __powerfulest_device;');
  WriteLn(Out,'');
  WriteLn(Out,' int __max_group_threads = 128;');
  WriteLn(Out,'');
  WriteLn(Out,' void set_max_group_threads(int val) {');
  WriteLn(Out,'   __max_group_threads = val;');
  WriteLn(Out,' }');
  WriteLn(Out,'');
  WriteLn(Out,' int get_max_group_threads() {');
  WriteLn(Out,'   return __max_group_threads;');
  WriteLn(Out,' }');
  WriteLn(Out,'');
  WriteLn(Out,' typedef struct tag__program {');
  WriteLn(Out,'   cl_program            program;');
  WriteLn(Out,'   cl_kernel             kernel;');
  WriteLn(Out,'   const char **         kernel_source;');
  WriteLn(Out,'   struct tag__program * next;');
  WriteLn(Out,' } __program;');
  WriteLn(Out,'');
  WriteLn(Out,' map<cl_device_id, __program *> __programs;');
  WriteLn(Out,'');
  WriteLn(Out,'void __init_devices() {');
  WriteLn(Out,'  cl_platform_id platform_ids[MAX_PLATFORMS] = {NULL};');
  WriteLn(Out,'  cl_device_id device_ids[MAX_DEVICES] = {NULL};');
  WriteLn(Out,'  cl_uint ret_num_devices;');
  WriteLn(Out,'  cl_uint ret_num_platforms;');
  WriteLn(Out,'  char platform[256];');
  WriteLn(Out,'  char device[256];');
  WriteLn(Out,'  cl_int ret;');
  WriteLn(Out,'  size_t sz;');
  WriteLn(Out,'');
  WriteLn(Out,'  cl_uint n_units = 0;');
  WriteLn(Out,'');
  WriteLn(Out,'  cout<<"--- OpenCL begin ---"<<endl;');
  WriteLn(Out,'  ret = clGetPlatformIDs(MAX_PLATFORMS, platform_ids, &ret_num_platforms);');
  WriteLn(Out,'  for (unsigned int i = 0; i < ret_num_platforms; i++) {');
  WriteLn(Out,'      ret = clGetDeviceIDs(platform_ids[i], CL_DEVICE_TYPE_DEFAULT, MAX_DEVICES, device_ids, &ret_num_devices);');
  WriteLn(Out,'      ret = clGetPlatformInfo(platform_ids[i], CL_PLATFORM_NAME, 256, platform, &sz);');
  WriteLn(Out,'      cout<<"  Platform: "<<platform<<endl;');
  WriteLn(Out,'      if (strcmp(platform, "FreeOCL") == 0) {');
  WriteLn(Out,'         cout<<"    BYPASSED."<<endl;');
  WriteLn(Out,'         continue;');
  WriteLn(Out,'      }');
  WriteLn(Out,'      for (unsigned int j = 0; j < ret_num_devices; j++) {');
  WriteLn(Out,'          __device d = {false, platform_ids[i], device_ids[j]};');
  WriteLn(Out,'          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(d.n_units), &d.n_units, &sz);');
  WriteLn(Out,'          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_NAME, 256, &device, &sz);');
  WriteLn(Out,'          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(d.max_work_size), &d.max_work_size, &sz);');
  WriteLn(Out,'          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(d.local_mem_size), &d.local_mem_size, &sz);');
  WriteLn(Out,'          while (__devices.find(device) != __devices.end()) {');
  WriteLn(Out,'            int n = strlen(device);');
  WriteLn(Out,'            device[n++] = ''.''; device[n++] = ''X''; device[n] = 0x0;');
  WriteLn(Out,'          }');
  WriteLn(Out,'          d.max_work_size *= d.n_units;');
  WriteLn(Out,'          if (d.n_units > n_units) {');
  WriteLn(Out,'             n_units = d.n_units;');
  WriteLn(Out,'             __powerfulest_device = device;');
  WriteLn(Out,'          }');
  WriteLn(Out,'          cout<<"    Device: "<<device<<endl;');
  WriteLn(Out,'          d.compile_time = 0.0;');
  WriteLn(Out,'          d.execution_time = 0.0;');
  WriteLn(Out,'          __devices[device] = d;');
  WriteLn(Out,'      }');
  WriteLn(Out,'  }');
  WriteLn(Out,'  cout<<"------------------"<<endl;');
  WriteLn(Out,'  cout<<"Powerfulest device: "<<__powerfulest_device<<endl;');
  WriteLn(Out,'  cout<<"--- OpenCL end ---"<<endl;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'void __free_devices() {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'      if (it->second.online) {');
  WriteLn(Out,'         cl_int ret;');
  WriteLn(Out,'         ret = clFlush(it->second.command_queue);');
  WriteLn(Out,'         ret = clFinish(it->second.command_queue);');
  WriteLn(Out,'         map<cl_device_id, __program *>::iterator itp = __programs.find(it->second.device_id);');
  WriteLn(Out,'         if (itp != __programs.end()) {');
  WriteLn(Out,'            __program * cur = itp->second;');
  WriteLn(Out,'            while (cur) {');
  WriteLn(Out,'	             ret = clReleaseKernel(cur->kernel);');
  WriteLn(Out,'	             ret = clReleaseProgram(cur->program);');
  WriteLn(Out,'              __program * next = cur->next;');
  WriteLn(Out,'              delete cur;');
  WriteLn(Out,'              cur = next;');
  WriteLn(Out,'            }');
  WriteLn(Out,'         }');
  WriteLn(Out,'         ret = clReleaseCommandQueue(it->second.command_queue);');
  WriteLn(Out,'         ret = clReleaseContext(it->second.context);');
  WriteLn(Out,'      }');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'__device & __open_device(const char * Device) {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  if (Device) {');
  WriteLn(Out,'     for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'         if (it->first.find(Device) != string::npos)');
  WriteLn(Out,'            break;');
  WriteLn(Out,'  } else');
  WriteLn(Out,'     it = __devices.find(__powerfulest_device);');
  WriteLn(Out,'  if (it == __devices.end()) {');
  WriteLn(Out,'     cout<<"Error: there is no device whose name contains ''"<<Device<<"''"<<endl;');
  WriteLn(Out,'     exit(-1);');
  WriteLn(Out,'  }');
  WriteLn(Out,'  if (!it->second.online) {');
  WriteLn(Out,'     cl_int ret1, ret2;');
  WriteLn(Out,'     it->second.context = clCreateContext(NULL, 1, &it->second.device_id, NULL, NULL, &ret1);');
  WriteLn(Out,'     it->second.command_queue = clCreateCommandQueue(it->second.context, it->second.device_id, CL_QUEUE_PROFILING_ENABLE, &ret2);');
  WriteLn(Out,'     if (ret1 != CL_SUCCESS || ret2 != CL_SUCCESS) {');
  WriteLn(Out,'        cout<<"Device opening error: "<<ret1<<" : "<<ret2<<endl;');
  WriteLn(Out,'        exit(-1);');
  WriteLn(Out,'     }');
  WriteLn(Out,'     it->second.online = true;');
  WriteLn(Out,'  }');
  WriteLn(Out,'  return it->second;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'char * __collect(const char ** source) {');
  WriteLn(Out,'  string S = "";');
  WriteLn(Out,'  while (*source) {');
  WriteLn(Out,'    S.append(*source);');
  WriteLn(Out,'    S.append("\n");');
  WriteLn(Out,'    source++;');
  WriteLn(Out,'  }');
  WriteLn(Out,'  int n = S.length();');
  WriteLn(Out,'');
  WriteLn(Out,'  char * result = new char[n+1];');
  WriteLn(Out,'  memmove(result, S.c_str(), n);');
  WriteLn(Out,'  result[n] = 0x0;');
  WriteLn(Out,'');
  WriteLn(Out,'  return result;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'cl_kernel __compile_on_device(__device & d, const char ** common, const char ** kernel_source, const char * kernel_name) {');
  WriteLn(Out,'   map<cl_device_id, __program *>::iterator itp = __programs.find(d.device_id);');
  WriteLn(Out,'   if (itp != __programs.end()) {');
  WriteLn(Out,'      __program * cur = itp->second;');
  WriteLn(Out,'      while (cur) {');
  WriteLn(Out,'        if (kernel_source == cur->kernel_source)');
  WriteLn(Out,'           return cur->kernel;');
  WriteLn(Out,'        cur = cur->next;');
  WriteLn(Out,'      }');
  WriteLn(Out,'   } else');
  WriteLn(Out,'      __programs[d.device_id] = NULL;');
  WriteLn(Out,'');
  WriteLn(Out,'   __program * prg = new __program;');
  WriteLn(Out,'');
  WriteLn(Out,'   prg->kernel_source = kernel_source;');
  WriteLn(Out,'');
  WriteLn(Out,'   char * log = new char[65536*2];');
  WriteLn(Out,'   char * prog = new char[65536*2];');
  WriteLn(Out,'   cl_int ret;');
  WriteLn(Out,'   size_t sz;');
  WriteLn(Out,'');
  WriteLn(Out,'   char * _common = __collect(common);');
  WriteLn(Out,'   char * _kernel = __collect(kernel_source);');
  WriteLn(Out,'');
  WriteLn(Out,'   size_t n  = strlen(_common);');
  WriteLn(Out,'   size_t n1 = strlen(_kernel);');
  WriteLn(Out,'   memmove(&prog[0], _common, n);');
  WriteLn(Out,'   prog[n++] = 0x0D; prog[n++] = 0x0A;');
  WriteLn(Out,'   memmove(&prog[n], _kernel, n1);');
  WriteLn(Out,'   n += n1;');
  WriteLn(Out,'   prog[n] = 0x0;');
  WriteLn(Out,'');
  WriteLn(Out,'   prg->program = clCreateProgramWithSource(d.context, 1, (const char **)&prog, (const size_t *)&n, &ret);');
  WriteLn(Out,'   if (ret != CL_SUCCESS) {');
  WriteLn(Out,'      cout<<"Create device program error = "<<ret<<endl; exit(-1);');
  WriteLn(Out,'   }');
  WriteLn(Out,'   double t = omp_get_wtime();');
  WriteLn(Out,'   ret = clBuildProgram(prg->program, 1, &d.device_id, "-cl-opt-disable", NULL, NULL);');
  WriteLn(Out,'   if (ret != CL_SUCCESS) {');
  WriteLn(Out,'      cout<<"Build device program error = "<<ret<<endl;');
  WriteLn(Out,'      clGetProgramBuildInfo(prg->program, d.device_id, CL_PROGRAM_BUILD_LOG, 65536*2, log, &sz);');
  WriteLn(Out,'      log[sz] = 0x0;');
  WriteLn(Out,'      cout<<"--- Build <"<<kernel_name<<"> Info ---"<<endl;');
  WriteLn(Out,'      cout<<log;');
  WriteLn(Out,'      cout<<"--- End of Build Info ---"<<endl;');
  WriteLn(Out,'      exit(-1);');
  WriteLn(Out,'   }');
  WriteLn(Out,'');
  WriteLn(Out,'   d.compile_time = omp_get_wtime() - t;');
  WriteLn(Out,'   prg->kernel = clCreateKernel(prg->program, kernel_name, &ret);');
  WriteLn(Out,'   if (ret != CL_SUCCESS) {');
  WriteLn(Out,'      cout<<"Create kernel for device program error = "<<ret<<endl; exit(-1);');
  WriteLn(Out,'   }');
  WriteLn(Out,'');
  WriteLn(Out,'   delete _common;');
  WriteLn(Out,'   delete _kernel;');
  WriteLn(Out,'');
  WriteLn(Out,'   delete prog;');
  WriteLn(Out,'   delete log;');
  WriteLn(Out,'');
  WriteLn(Out,'   prg->next = __programs[d.device_id];');
  WriteLn(Out,'   __programs[d.device_id] = prg;');
  WriteLn(Out,'');
  WriteLn(Out,'   return prg->kernel;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'void __run_kernel(__device & d, cl_kernel kernel,');
  WriteLn(Out,'                  int n_args,');
  WriteLn(Out,'                  int * size_items, int * offs_items, int * mode_items, bool * is_global,');
  WriteLn(Out,'                  long long * n_pointer, int * n_items,');
  WriteLn(Out,'                  char ** cpu_data, int n) {');
  WriteLn(Out,'  cl_mem gpu_data[256];');
  WriteLn(Out,'  cl_int ret;');
  WriteLn(Out,'');
  WriteLn(Out,'  for (int i = 0; i <= n_args; i++) {');
  WriteLn(Out,'      gpu_data[i] = clCreateBuffer(d.context, CL_MEM_USE_HOST_PTR+mode_items[i], n_items[i]*size_items[i], cpu_data[i], &ret);');
  WriteLn(Out,'      if (ret != CL_SUCCESS) {');
  WriteLn(Out,'         cout<<"Error: can not allocate buffer, error "<<ret<<endl;');
  WriteLn(Out,'         exit(-1);');
  WriteLn(Out,'      }');
  WriteLn(Out,'  }');
  WriteLn(Out,'  /* vectorize */');
  WriteLn(Out,'  for (int i = 0; i <= n_args; i++) {');
  WriteLn(Out,'      ret = clSetKernelArg(kernel, i, sizeof(cl_mem), (void *)&gpu_data[i]);');
  WriteLn(Out,'      if (ret != CL_SUCCESS) {');
  WriteLn(Out,'         cout<<"Error "<<ret<<": can not set argument "<<i<<" for kernel"<<endl; exit(-1);');
  WriteLn(Out,'      }');
  WriteLn(Out,'  }');
  WriteLn(Out,'  size_t work_size = n;');
  WriteLn(Out,'  size_t max_group_size = d.max_work_size/d.n_units;');
  WriteLn(Out,'  size_t work_groups = d.n_units;');
  WriteLn(Out,'  while (work_groups > 1 && work_size % work_groups != 0)');
  WriteLn(Out,'    work_groups--;');
  WriteLn(Out,'  size_t _group_size = work_size/work_groups;');
  WriteLn(Out,'  while ((_group_size > __max_group_threads || _group_size > max_group_size) && work_size%(2*work_groups) == 0) {');
  WriteLn(Out,'     work_groups *= 2;');
  WriteLn(Out,'     _group_size /= 2;');
  WriteLn(Out,'  }');
  WriteLn(Out,'  size_t * group_size = _group_size > __max_group_threads || _group_size > max_group_size ? NULL : &_group_size;');
  WriteLn(Out,'  cl_event event;');
  WriteLn(Out,'  ret = clEnqueueNDRangeKernel(d.command_queue, kernel, 1, NULL, &work_size, group_size, 0, NULL, &event);');
  WriteLn(Out,'  if (ret != CL_SUCCESS) {');
  WriteLn(Out,'     cout<<"Error "<<ret<<": kernel execution"<<endl; exit(-1);');
  WriteLn(Out,'  }');
  WriteLn(Out,'  clWaitForEvents(1, &event);');
  WriteLn(Out,'  clFinish(d.command_queue);');
  WriteLn(Out,'  cl_ulong time_start;');
  WriteLn(Out,'  cl_ulong time_end;');
  WriteLn(Out,'  clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_START, sizeof(time_start), &time_start, NULL);');
  WriteLn(Out,'  clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_END, sizeof(time_end), &time_end, NULL);');
  WriteLn(Out,'  d.execution_time = (time_end-time_start)/1000000000.0;');
  WriteLn(Out,'  for (int j = 0; j < n_args; j++)');
  WriteLn(Out,'    if (!is_global[j] && n_pointer[j]) {');
  WriteLn(Out,'       void * tmp_ptr = NULL;');
  WriteLn(Out,'       tmp_ptr = clEnqueueMapBuffer(d.command_queue, gpu_data[j], true, CL_MAP_READ, 0, n_items[j]*size_items[j], 0, NULL, NULL, &ret);');
  WriteLn(Out,'       if (tmp_ptr != cpu_data[j]) {');
  WriteLn(Out,'          	cout<<"Error mapping _local buffer"<<endl; exit(-1);');
  WriteLn(Out,'       }');
  WriteLn(Out,'    }');
  WriteLn(Out,'  clFinish(d.command_queue);');
  WriteLn(Out,'  for (int j = 0; j < n_args; j++)');
  WriteLn(Out,'    if (!is_global[j] && n_pointer[j]) {');
  WriteLn(Out,'       ret = clEnqueueUnmapMemObject(d.command_queue, gpu_data[j], cpu_data[j], 0, NULL, NULL);');
  WriteLn(Out,'       if (ret != CL_SUCCESS) {');
  WriteLn(Out,'          cout<<"Error "<<ret<<": unmap _local buffer"<<endl; exit(-1);');
  WriteLn(Out,'       }');
  WriteLn(Out,'    }');
  WriteLn(Out,'  clFinish(d.command_queue);');
  WriteLn(Out,'  for (int i = 0; i <= n_args; i++)');
  WriteLn(Out,'      ret = clReleaseMemObject(gpu_data[i]);');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'int vector_max_size(const char * Device) {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  if (Device) {');
  WriteLn(Out,'     for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'         if (it->first.find(Device) != string::npos)');
  WriteLn(Out,'            break;');
  WriteLn(Out,'  } else');
  WriteLn(Out,'     it = __devices.find(__powerfulest_device);');
  WriteLn(Out,'  return it->second.max_work_size;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'int vector_max_units(const char * Device) {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  if (Device) {');
  WriteLn(Out,'     for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'         if (it->first.find(Device) != string::npos)');
  WriteLn(Out,'            break;');
  WriteLn(Out,'  } else');
  WriteLn(Out,'     it = __devices.find(__powerfulest_device);');
  WriteLn(Out,'  return it->second.n_units;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'const char * get_device_id(int n) {');
  WriteLn(Out,'  if (n >= __devices.size())');
  WriteLn(Out,'     return NULL;');
  WriteLn(Out,'  map<string, __device>::iterator idev = __devices.begin();');
  WriteLn(Out,'  while (n--) idev++;');
  WriteLn(Out,'  return idev->first.c_str();');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'double last_compile_time(const char * Device) {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  if (Device) {');
  WriteLn(Out,'     for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'         if (it->first.find(Device) != string::npos)');
  WriteLn(Out,'            break;');
  WriteLn(Out,'  } else');
  WriteLn(Out,'     it = __devices.find(__powerfulest_device);');
  WriteLn(Out,'  double result = it->second.compile_time;');
  WriteLn(Out,'  it->second.compile_time = 0.0;');
  WriteLn(Out,'  return result;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'double last_execution_time(const char * Device) {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  if (Device) {');
  WriteLn(Out,'     for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'         if (it->first.find(Device) != string::npos)');
  WriteLn(Out,'            break;');
  WriteLn(Out,'  } else');
  WriteLn(Out,'     it = __devices.find(__powerfulest_device);');
  WriteLn(Out,'  double result = it->second.execution_time;');
  WriteLn(Out,'  it->second.execution_time = 0.0;');
  WriteLn(Out,'  return result;');
  WriteLn(Out,'}');
  WriteLn(Out,'unsigned long local_memory_size(const char * Device) {');
  WriteLn(Out,'  map<string, __device>::iterator it;');
  WriteLn(Out,'  if (Device) {');
  WriteLn(Out,'     for (it = __devices.begin(); it != __devices.end(); it++)');
  WriteLn(Out,'         if (it->first.find(Device) != string::npos)');
  WriteLn(Out,'            break;');
  WriteLn(Out,'  } else');
  WriteLn(Out,'     it = __devices.find(__powerfulest_device);');
  WriteLn(Out,'  return it->second.local_mem_size;');
  WriteLn(Out,'}');
  WriteLn(Out,'');
  WriteLn(Out,'#define plan_vector_id() 0');
  WriteLn(Out,'#define plan_vector_size() 1');
  WriteLn(Out,'');
  WriteLn(Out,'#define __run_opencl_kernel__ \');
  WriteLn(Out,'  do { \');
  WriteLn(Out,'    char * cpu_data[n_args+1]; \');
  WriteLn(Out,'    cl_int ret; \');
  WriteLn(Out,'    int __n__ = 0; \');
  WriteLn(Out,'    for (it = __event_list__->begin(); __n__ < d.max_work_size && it != __event_list__->end() && !((*it).Flags & 1); it++) \');
  WriteLn(Out,'        __n__++; \');
  WriteLn(Out,'    if (__n__ == 0) break; \');
  WriteLn(Out,'    if (__n__ == d.max_work_size && it != __event_list__->end() && !((*it).Flags & 1)) { \');
  WriteLn(Out,'       cout<<"Error: too many items in vectorized section of plan: exceeds "<<d.max_work_size<<endl; \');
  WriteLn(Out,'       exit(-1); \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    for (int i = 0; i < n_args; i++) { \');
  WriteLn(Out,'        if (is_global[i]) n_items[i] = n_pointer[i]; \');
  WriteLn(Out,'        else if (n_pointer[i] == 0) n_items[i] = __n__; \');
  WriteLn(Out,'        else { \');
  WriteLn(Out,'          n_pointer[i] = reinterpret_cast<long long>(malloc(__n__*sizeof(int))); \');
  WriteLn(Out,'          it = __event_list__->begin(); \');
  WriteLn(Out,'          n_items[i] = 0; \');
  WriteLn(Out,'          for (int j = 0; j < __n__; j++) { \');
  WriteLn(Out,'              __planned__ = *it++; \');
  WriteLn(Out,'              n_items[i] += (reinterpret_cast<int *>(n_pointer[i])[j] = loc_items(i)); \');
  WriteLn(Out,'          } \');
  WriteLn(Out,'        } \');
  WriteLn(Out,'        cpu_data[i] = (char *) malloc(n_items[i]*size_items[i]); \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    const int __nl__ = __max(1,n_locs); \');
  WriteLn(Out,'    n_items[n_args] = __nl__*__n__; \');
  WriteLn(Out,'    cpu_data[n_args] = (char *) malloc(__nl__*__n__*sizeof(int)); \');
  WriteLn(Out,'    int __offs[n_args] = {0}; \');
  WriteLn(Out,'    int * offs = reinterpret_cast<int *>(cpu_data[n_args]); \');
  WriteLn(Out,'    it = __event_list__->begin(); \');
  WriteLn(Out,'    for (int i = 0; i < __n__; i++) { \');
  WriteLn(Out,'        __planned__ = *it++; \');
  WriteLn(Out,'        memmove(&offs[i*__nl__], __offs, __nl__*sizeof(int)); \');
  WriteLn(Out,'        int k = 0; \');
  WriteLn(Out,'        for (int j = 0; j < n_args; j++) \');
  WriteLn(Out,'          if (!is_global[j] || i == 0) { \');
  WriteLn(Out,'             int __nn__ = is_global[j] ? n_pointer[j] : (n_pointer[j] == 0 ? 1 : reinterpret_cast<int *>(n_pointer[j])[i]); \');
  WriteLn(Out,'             if (n_pointer[j]) \');
  WriteLn(Out,'                if (is_global[j]) \');
  WriteLn(Out,'                   memmove(&cpu_data[j][i*__nn__*size_items[j]],*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]),__nn__*size_items[j]); \');
  WriteLn(Out,'                else { \');
  WriteLn(Out,'                   memmove(&cpu_data[j][__offs[k]*size_items[j]],*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]),__nn__*size_items[j]); \');
  WriteLn(Out,'                   __offs[k] += __nn__; \');
  WriteLn(Out,'                   k++; \');
  WriteLn(Out,'                } \');
  WriteLn(Out,'             else \');
  WriteLn(Out,'                memmove(&cpu_data[j][i*__nn__*size_items[j]],reinterpret_cast<char *>(&__planned__)+offs_items[j],__nn__*size_items[j]); \');
  WriteLn(Out,'          } \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    __run_kernel(d, kernel, n_args, size_items, offs_items, mode_items, is_global, n_pointer, n_items, cpu_data, __n__); \');
  WriteLn(Out,'    /* reverse_pump */ \');
  WriteLn(Out,'    memset(__offs, 0, __nl__*sizeof(int)); \');
  WriteLn(Out,'    for (int i = 0; i < __n__; i++) { \');
  WriteLn(Out,'        __planned__ = __event_list__->front(); \');
  WriteLn(Out,'        __event_list__->pop_front(); \');
  WriteLn(Out,'        int k = 0; \');
  WriteLn(Out,'        for (int j = 0; j < n_args; j++) \');
  WriteLn(Out,'          if (!is_global[j] && n_pointer[j]) { \');
  WriteLn(Out,'             int __nn__ = reinterpret_cast<int *>(n_pointer[j])[i]; \');
  WriteLn(Out,'             memmove(*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]), &cpu_data[j][__offs[k]*size_items[j]], __nn__*size_items[j]); \');
  WriteLn(Out,'             __offs[k] += __nn__; \');
  WriteLn(Out,'             k++; \');
  WriteLn(Out,'          } \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    if (!__event_list__->empty()) { \');
  WriteLn(Out,'       __planned__ = __event_list__->front(); \');
  WriteLn(Out,'       if (__planned__.Flags & 1) __event_list__->pop_front(); \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    for (int i = 0; i <= n_args; i++) { \');
  WriteLn(Out,'        if (!is_global[i] && n_pointer[i]) free(reinterpret_cast<void *>(n_pointer[i])); \');
  WriteLn(Out,'        free(cpu_data[i]); \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'  } while(0)');
  WriteLn(Out,'#else');
  WriteLn(Out,' #define plan_vector_id() plan_processor_id()');
  WriteLn(Out,' #define plan_vector_size() plan_processors()');
  WriteLn(Out,' #define vector_max_size(S) (0x7FFFFFFF)');
  WriteLn(Out,' #define last_compile_time(S) (0.0)');
  WriteLn(Out,' #define last_execution_time(S) (0.0)');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#ifdef __REENT_MPI__');
  WriteLn(Out,'#include "mpi.h"');
  WriteLn(Out,'int __cluster_size__;');
  WriteLn(Out,'int __cluster_id__;');
  WriteLn(Out,'inline int plan_cluster_size() {');
  WriteLn(Out,'  return __cluster_size__;');
  WriteLn(Out,'}');
  WriteLn(Out,'inline int plan_cluster_id() {');
  WriteLn(Out,'  return __cluster_id__;');
  WriteLn(Out,'}');
  WriteLn(Out,'const int th_back  = 0;');
  WriteLn(Out,'const int th_front = 1;');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#include <time.h>');
  WriteLn(Out,'#include <list>');
  WriteLn(Out,'#include <map>');
  WriteLn(Out,'#include <vector>');
  WriteLn(Out,'#include <iostream>');
  WriteLn(Out,'#include <time.h>');
  WriteLn(Out,'#include <string>');
  WriteLn(Out,'#include <stdlib.h>');
  WriteLn(Out,'using namespace std;');
  WriteLn(Out,'#ifdef _OPENMP');
  WriteLn(Out,'  #include <omp.h>');
  WriteLn(Out,'#endif');
  WriteLn(Out,Signals);
  WriteLn(Out,Tunnels_Vars_Sems);
  WriteLn(Out,ReentList);
  WriteLn(Out,Topologies);
  WriteLn(Out,CircularList);
  WriteLn(Out,'#define plan_atomize __transaction_atomic');
  WriteLn(Out,'#define plan_item_type(A) _params_##A');
  WriteLn(Out,'#define plan_type(A) A##_plan_type');
  WriteLn(Out,'#define plan(A) (A##_plan_prefix _events_##A)');
  WriteLn(Out,'#define _size(A) (A.size())');
  WriteLn(Out,'#define plan_stop _plan_stop()');
  WriteLn(Out,'#define clear_plan _clear_plan()');
  WriteLn(Out,'#define plan_group_first _plan_group_first()');
  WriteLn(Out,'#define plan_group_last _plan_group_last()');
  WriteLn(Out,'#define plan_group_parallelize _plan_group_parallelize()');
  WriteLn(Out,'#define plan_group_atomize _plan_group_atomize()');
  WriteLn(Out,'#define plan_group_soft_atomize _plan_group_soft_atomize()');
  WriteLn(Out,'#define plan_group_vectorize(S) _plan_group_vectorize(S)');
  WriteLn(Out,'#define plan_group_typize(S) _plan_group_vectorize(S)');
  WriteLn(Out,'#ifdef __REENT_MPI__');
  WriteLn(Out,'#define __throw_cluster__(ID,InputProcName,__Direction__) \');
  WriteLn(Out,' if (__clustered_topology(plan_topology_num())) { \');
  WriteLn(Out,'    long long send_id; \');
  WriteLn(Out,'    if (InputProcName == 1) \');
  WriteLn(Out,'       send_id = reinterpret_cast<long long>(__chain_plan__); \');
  WriteLn(Out,'    else { \');
  WriteLn(Out,'       __Node * node = get_topology_link(plan_topology_num(),reinterpret_cast<void *>(&_call_##ID),plan_linear_num(),InputProcName); \');
  WriteLn(Out,'       send_id = node->id; \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    if (send_id < 0) { \');
  WriteLn(Out,'       cout<<"Default throw link from "<<reinterpret_cast<void *>(&_call_##ID)<<"["<<plan_linear_num()<<"] does not exist"<<endl; \');
  WriteLn(Out,'       exit(-1); \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    int tag_base = get_topology_tag(plan_topology_num()); \');
  WriteLn(Out,'    int first = th_##__Direction__; \');
  WriteLn(Out,'    MPI_Send(&first, 1, MPI_INT, send_id, tag_base+2, MPI_COMM_WORLD); \');
  WriteLn(Out,'    MPI_Send(&__dummy_throw__, sizeof(__dummy_throw__), MPI_BYTE, send_id, tag_base+2, MPI_COMM_WORLD); \');
  WriteLn(Out,'    break; \');
  WriteLn(Out,' }');
  WriteLn(Out,'#else');
  WriteLn(Out,'#define __throw_cluster__(ID,InputProcName,__Direction__) while(0)');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#ifdef _OPENMP');
  WriteLn(Out,'#define __plan_stop(Allow) \');
  WriteLn(Out,'   do if (Allow) {\');
  WriteLn(Out,'        omp_set_lock(__continue_lock__); \');
  WriteLn(Out,'        *__continue_plan__ = 0; \');
  WriteLn(Out,'        omp_unset_lock(__continue_lock__); \');
  WriteLn(Out,'   } while(0)');
  WriteLn(Out,'#define plan_processor_id omp_get_thread_num');
  WriteLn(Out,'#define plan_processors() (omp_in_parallel() ? omp_get_num_threads() : omp_get_max_threads())');
  WriteLn(Out,'#define _throw_num_stages() __get_num_stages(plan_topology_num())');
  WriteLn(Out,'#define throw_num_stages() _throw_num_stages()');
  WriteLn(Out,'char __AFTER_CONTINUE(char Allow, omp_lock_t * __continue_lock__, char * __continue_plan__) {');
  WriteLn(Out,'  char Result = 0;');
  WriteLn(Out,'  if (Allow) {');
  WriteLn(Out,'     omp_set_lock(__continue_lock__);');
  WriteLn(Out,'     if (Result = *__continue_plan__ == 2) *__continue_plan__ = 1;');
  WriteLn(Out,'     omp_unset_lock(__continue_lock__);');
  WriteLn(Out,'  }');
  WriteLn(Out,'  return Result;');
  WriteLn(Out,'}');
  WriteLn(Out,'#define __plan_locking__ plan_set_lock(__plan_lock__)');
  WriteLn(Out,'#define __plan_unlocking__ do { plan_unset_lock(__plan_lock__); } while(0)');
  WriteLn(Out,'#define __plan_signal__ do { __signal_reent_event(__signaler__); __instead_signal_yield(); } while(0)');
  WriteLn(Out,'#define __throw_locking__ do if (__chain_lock__) plan_set_lock(__chain_lock__); while(0)');
  WriteLn(Out,'#define __throw_substitute__(ID,InputProcName) \');
  WriteLn(Out,'    __Node * node = get_topology_link(plan_topology_num(),reinterpret_cast<void *>(&_call_##ID),plan_linear_num(),InputProcName); \');
  WriteLn(Out,'    __abstract_list<_throw_##ID> * __throw_list__ = (__abstract_list<_throw_##ID> *) node->Plan; \');
  WriteLn(Out,'    plan_lock_t * __chain_lock__ = node->LockPlan; \');
  WriteLn(Out,'    __reent_event * __next_signaler = node->SignalPlan;');
  WriteLn(Out,'#define __throw_unlocking__ do if (__chain_lock__) plan_unset_lock(__chain_lock__); while(0)');
  WriteLn(Out,'#define __throw_signal__ do if (__next_signaler__) { __signal_reent_event(__next_signaler__); __instead_signal_yield(); } while(0)');
  WriteLn(Out,'void __START_LOCK__(int __num_threads__, omp_lock_t * __start_lock__) {');
  WriteLn(Out,' int __i;');
  WriteLn(Out,' if (__start_lock__) {');
  WriteLn(Out,'    #pragma omp for private(__i) schedule(static,1) ordered nowait');
  WriteLn(Out,'    for (__i=0; __i<__num_threads__; __i++)');
  WriteLn(Out,'        #pragma omp ordered');
  WriteLn(Out,'          {');
  WriteLn(Out,'           omp_set_lock(__start_lock__);');
  WriteLn(Out,'           if (__i!=0)');
  WriteLn(Out,'              omp_unset_lock(__start_lock__);');
  WriteLn(Out,'          }');
  WriteLn(Out,' }');
  WriteLn(Out,'}');
  WriteLn(Out,'#else');
  WriteLn(Out,'#define plan_processor_id() 0');
  WriteLn(Out,'#define plan_processors() 1');
  WriteLn(Out,'#define _throw_num_stages() (__num_stages__)');
  WriteLn(Out,'#define throw_num_stages() _throw_num_stages()');
  WriteLn(Out,'#define __plan_locking__ while(0)');
  WriteLn(Out,'#define __plan_unlocking__ while(0)');
  WriteLn(Out,'#define __plan_signal__ while(0)');
  WriteLn(Out,'#define __throw_locking__ while(0)');
  WriteLn(Out,'#define __throw_substitute__(ID,InputProcName) __abstract_list<_throw_##ID> * __throw_list__ = (__abstract_list<_throw_##ID> *) __chain_plan__;');
  WriteLn(Out,'#define __throw_unlocking__ while(0)');
  WriteLn(Out,'#define __throw_signal__ while(0)');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#define plan_locking() __plan_locking__');
  WriteLn(Out,'#define plan_unlocking() __plan_unlocking__');
  WriteLn(Out,'#ifdef __REENT_MPI__');
  WriteLn(Out,'#define __wait_cluster__(ID,__Direction__) \');
  WriteLn(Out,' if (__clustered_topology(plan_topology_num())) { \');
  WriteLn(Out,'    int tag_base = get_topology_tag(plan_topology_num()); \');
  WriteLn(Out,'    MPI_Status status; \');
  WriteLn(Out,'    int item_received; \');
  WriteLn(Out,'    do { \');
  WriteLn(Out,'       MPI_Iprobe(MPI_ANY_SOURCE, tag_base+2, MPI_COMM_WORLD, &item_received, &status); \');
  WriteLn(Out,'       if (item_received) { \');
  WriteLn(Out,'          MPI_Status status1; \');
  WriteLn(Out,'          int first; \');
  WriteLn(Out,'          MPI_Recv(&first, 1, MPI_INT, status.MPI_SOURCE, tag_base+2, MPI_COMM_WORLD, &status1); \');
  WriteLn(Out,'          MPI_Recv(&__dummy_throw__, sizeof(__dummy_throw__), MPI_BYTE, status.MPI_SOURCE, tag_base+2, MPI_COMM_WORLD, &status1); \');
  WriteLn(Out,'       } \');
  WriteLn(Out,'    } while (!item_received && plan_empty); \');
  WriteLn(Out,'    if (!item_received) { \');
  WriteLn(Out,'       __plan_locking__; \');
  WriteLn(Out,'       __dummy_throw__ = __event_list__->__Direction__(); \');
  WriteLn(Out,'       __event_list__->pop_##__Direction__(); \');
  WriteLn(Out,'       __plan_unlocking__; \');
  WriteLn(Out,'    } \');
  WriteLn(Out,' } else');
  WriteLn(Out,'#else');
  WriteLn(Out,'#define __wait_cluster__(ID,__Direction__) /* We have no the clustered topology */');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#define __wait_smp__(ID,__Direction__) \');
  WriteLn(Out,' do { \');
  WriteLn(Out,'    while (plan_empty) { \');
  WriteLn(Out,'       _Yield(); \');
  WriteLn(Out,'       Sleep(5); \');
  WriteLn(Out,'    } \');
  WriteLn(Out,'    __plan_locking__; \');
  WriteLn(Out,'    __dummy_throw__ = __event_list__->__Direction__(); \');
  WriteLn(Out,'    if (__dummy_throw__.Flags & 1) result = 0; \');
  WriteLn(Out,'    else __event_list__->pop_##__Direction__(); \');
  WriteLn(Out,'    __plan_unlocking__; \');
  WriteLn(Out,' } while (0)');
  WriteLn(Out,'#define __get_item_begin__(ID,__Direction__) \');
  WriteLn(Out,' do { \');
  WriteLn(Out,'    plan_item_type(ID) __dummy_throw__; \');
  WriteLn(Out,'    __wait_cluster__(ID,__Direction__) \');
  WriteLn(Out,'    __wait_smp__(ID,__Direction__)');
  WriteLn(Out,'#define __get_item_end__ \');
  WriteLn(Out,' } while (0)');
  WriteLn(Out,'long long __dummy_counter = 0;');
  WriteLn(Out,'class __init_openmp_mpi__ {');
  WriteLn(Out,'  public:');
  WriteLn(Out,'  __init_openmp_mpi__() {');
  WriteLn(Out,'#ifdef _OPENMP');
  WriteLn(Out,'    omp_set_nested(1);');
  WriteLn(Out,'    __topo_lock__ = new plan_lock_t;');
  WriteLn(Out,'    plan_init_lock(__topo_lock__);');
  WriteLn(Out,'    omp_init_lock(&__funnel_lock__);');
  WriteLn(Out,'#ifdef __REENT_MPI__');
  WriteLn(Out,'    omp_init_lock(&__cfunnel_lock__);');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#endif');
  WriteLn(Out,'    srand((unsigned int) time(NULL));');
  WriteLn(Out,'#ifdef __REENT_MPI__');
  WriteLn(Out,'    int provided;');
  WriteLn(Out,'    MPI_Init_thread(NULL,NULL, MPI_THREAD_SERIALIZED, &provided);');
  WriteLn(Out,'    if (provided != MPI_THREAD_SERIALIZED && provided != MPI_THREAD_MULTIPLE) {');
  WriteLn(Out,'       cout<<"MPI: multithreading support is not suffucuent"<<endl;');
  WriteLn(Out,'       MPI_Abort(MPI_COMM_WORLD,-1);');
  WriteLn(Out,'    }');
  WriteLn(Out,'    MPI_Comm_size(MPI_COMM_WORLD,&__cluster_size__);');
  WriteLn(Out,'    MPI_Comm_rank(MPI_COMM_WORLD,&__cluster_id__);');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#ifdef __REENT_GPU__');
  WriteLn(Out,'    __init_devices();');
  WriteLn(Out,'#endif');
  WriteLn(Out,'  };');
  WriteLn(Out,'  ~__init_openmp_mpi__() {');
  WriteLn(Out,'    srand((unsigned int) __dummy_counter);');
  WriteLn(Out,'#ifdef __REENT_GPU__');
  WriteLn(Out,'    __free_devices();');
  WriteLn(Out,'#endif');
  WriteLn(Out,'#ifdef __REENT_MPI__');
  WriteLn(Out,'    MPI_Finalize();');
  WriteLn(Out,'#endif');
  WriteLn(Out,'  };');
  WriteLn(Out,'};');
  WriteLn(Out,'__init_openmp_mpi__ __ompi_initializer = __init_openmp_mpi__();');
  WriteLn(Out,Transact);
  WriteLn(Out,'#define soft_transact_array(Type) TArray<Type>');
  WriteLn(Out,'#define soft_transact_var(Type) TScalar<Type>');
  WriteLn(Out,'#define soft_transact_in(Type) TIn<Type>');
  WriteLn(Out,'#define soft_transact_out(Type) TOut<Type>');
  WriteLn(Out,'#define reduction(A) /* reduction */')
End;

End.
