Unit Prolog;

Interface

{$IFDEF FPC}
{$MODE ObjFPC}
{$ENDIF}
{$H+}

Uses Classes;

Procedure WriteProlog(Var _Out: TStringList; IsClustered, IsVectorized: Boolean);

Implementation

Uses Common, Consts, Topo;

{$INCLUDE SHMEM.PAS}
{$INCLUDE LISTS.PAS}

Procedure WriteProlog(Var _Out: TStringList; IsClustered, IsVectorized: Boolean);
Begin
  If IsClustered Then
     _Out.Add('#define __REENT_MPI__');
  If IsVectorized Then
     _Out.Add('#define __REENT_GPU__');
  _Out.Add('#define __global /* global */');
  _Out.Add('#define __local  /* local  */');
  _Out.Add('#define __constant /* constant */');
  _Out.Add('#define __private  /* private  */');
  _Out.Add('#define barrier(N) /* barrier */');
  _Out.Add('#define mem_fence(N) /* mem_fence */');
  _Out.Add('#define read_mem_fence(N) /* read_mem_fence */');
  _Out.Add('#define write_mem_fence(N) /* write_mem_fence */');
  _Out.Add('#define CLK_LOCAL_MEM_FENCE (1<<0)');
  _Out.Add('#define CLK_GLOBAL_MEM_FENCE (1<<1)');
  _Out.Add('#ifdef __REENT_GPU__');
  _Out.Add(' #ifdef __APPLE__');
  _Out.Add('  #include <OpenCL/opencl.h>');
  _Out.Add(' #else');
  _Out.Add('  #include <CL/cl.h>');
  _Out.Add(' #endif');
  _Out.Add('');
  _Out.Add(' #include <map>');
  _Out.Add(' #include <string>');
  _Out.Add(' #include <string.h>');
  _Out.Add(' #include <stdlib.h>');
  _Out.Add(' #include <iostream>');
  _Out.Add(' #include <omp.h>');
  _Out.Add('');
  _Out.Add(' using namespace std;');
  _Out.Add('');
  _Out.Add(' #define MAX_PLATFORMS 100 ');
  _Out.Add(' #define MAX_DEVICES 100');
  _Out.Add('');
  _Out.Add(' typedef struct {');
  _Out.Add('   bool             online;');
  _Out.Add('   cl_platform_id   platform_id;');
  _Out.Add('   cl_device_id     device_id;');
  _Out.Add('   cl_uint          n_units;');
  _Out.Add('   cl_ulong         local_mem_size;');
  _Out.Add('   size_t           max_work_size;');
  _Out.Add('   cl_context       context;');
  _Out.Add('   cl_command_queue command_queue;');
  _Out.Add('   double           compile_time;');
  _Out.Add('   double           execution_time;');
  _Out.Add(' } __device;');
  _Out.Add('');
  _Out.Add(' map<string, __device> __devices;');
  _Out.Add('');
  _Out.Add(' string __powerfulest_device;');
  _Out.Add('');
  _Out.Add(' int __max_group_threads = 128;');
  _Out.Add('');
  _Out.Add(' void set_max_group_threads(int val) {');
  _Out.Add('   __max_group_threads = val;');
  _Out.Add(' }');
  _Out.Add('');
  _Out.Add(' int get_max_group_threads() {');
  _Out.Add('   return __max_group_threads;');
  _Out.Add(' }');
  _Out.Add('');
  _Out.Add(' typedef struct tag__program {');
  _Out.Add('   cl_program            program;');
  _Out.Add('   cl_kernel             kernel;');
  _Out.Add('   const char **         kernel_source;');
  _Out.Add('   struct tag__program * next;');
  _Out.Add(' } __program;');
  _Out.Add('');
  _Out.Add(' map<cl_device_id, __program *> __programs;');
  _Out.Add('');
  _Out.Add('void __init_devices() {');
  _Out.Add('  cl_platform_id platform_ids[MAX_PLATFORMS] = {NULL};');
  _Out.Add('  cl_device_id device_ids[MAX_DEVICES] = {NULL};');
  _Out.Add('  cl_uint ret_num_devices;');
  _Out.Add('  cl_uint ret_num_platforms;');
  _Out.Add('  char platform[256];');
  _Out.Add('  char device[256];');
  _Out.Add('  cl_int ret;');
  _Out.Add('  size_t sz;');
  _Out.Add('');
  _Out.Add('  cl_uint n_units = 0;');
  _Out.Add('');
  _Out.Add('  cout<<"--- OpenCL begin ---"<<endl;');
  _Out.Add('  ret = clGetPlatformIDs(MAX_PLATFORMS, platform_ids, &ret_num_platforms);');
  _Out.Add('  for (unsigned int i = 0; i < ret_num_platforms; i++) {');
  _Out.Add('      ret = clGetDeviceIDs(platform_ids[i], CL_DEVICE_TYPE_DEFAULT, MAX_DEVICES, device_ids, &ret_num_devices);');
  _Out.Add('      ret = clGetPlatformInfo(platform_ids[i], CL_PLATFORM_NAME, 256, platform, &sz);');
  _Out.Add('      cout<<"  Platform: "<<platform<<endl;');
  _Out.Add('      if (strcmp(platform, "FreeOCL") == 0) {');
  _Out.Add('         cout<<"    BYPASSED."<<endl;');
  _Out.Add('         continue;');
  _Out.Add('      }');
  _Out.Add('      for (unsigned int j = 0; j < ret_num_devices; j++) {');
  _Out.Add('          __device d = {false, platform_ids[i], device_ids[j]};');
  _Out.Add('          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(d.n_units), &d.n_units, &sz);');
  _Out.Add('          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_NAME, 256, &device, &sz);');
  _Out.Add('          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(d.max_work_size), &d.max_work_size, &sz);');
  _Out.Add('          ret = clGetDeviceInfo(device_ids[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(d.local_mem_size), &d.local_mem_size, &sz);');
  _Out.Add('          while (__devices.find(device) != __devices.end()) {');
  _Out.Add('            int n = strlen(device);');
  _Out.Add('            device[n++] = ''.''; device[n++] = ''X''; device[n] = 0x0;');
  _Out.Add('          }');
  _Out.Add('          d.max_work_size *= d.n_units;');
  _Out.Add('          if (d.n_units > n_units) {');
  _Out.Add('             n_units = d.n_units;');
  _Out.Add('             __powerfulest_device = device;');
  _Out.Add('          }');
  _Out.Add('          cout<<"    Device: "<<device<<endl;');
  _Out.Add('          d.compile_time = 0.0;');
  _Out.Add('          d.execution_time = 0.0;');
  _Out.Add('          __devices[device] = d;');
  _Out.Add('      }');
  _Out.Add('  }');
  _Out.Add('  cout<<"------------------"<<endl;');
  _Out.Add('  cout<<"Powerfulest device: "<<__powerfulest_device<<endl;');
  _Out.Add('  cout<<"--- OpenCL end ---"<<endl;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('void __free_devices() {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('      if (it->second.online) {');
  _Out.Add('         cl_int ret;');
  _Out.Add('         ret = clFlush(it->second.command_queue);');
  _Out.Add('         ret = clFinish(it->second.command_queue);');
  _Out.Add('         map<cl_device_id, __program *>::iterator itp = __programs.find(it->second.device_id);');
  _Out.Add('         if (itp != __programs.end()) {');
  _Out.Add('            __program * cur = itp->second;');
  _Out.Add('            while (cur) {');
  _Out.Add('	             ret = clReleaseKernel(cur->kernel);');
  _Out.Add('	             ret = clReleaseProgram(cur->program);');
  _Out.Add('              __program * next = cur->next;');
  _Out.Add('              delete cur;');
  _Out.Add('              cur = next;');
  _Out.Add('            }');
  _Out.Add('         }');
  _Out.Add('         ret = clReleaseCommandQueue(it->second.command_queue);');
  _Out.Add('         ret = clReleaseContext(it->second.context);');
  _Out.Add('      }');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('__device & __open_device(const char * Device) {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  if (Device) {');
  _Out.Add('     for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('         if (it->first.find(Device) != string::npos)');
  _Out.Add('            break;');
  _Out.Add('  } else');
  _Out.Add('     it = __devices.find(__powerfulest_device);');
  _Out.Add('  if (it == __devices.end()) {');
  _Out.Add('     cout<<"Error: there is no device whose name contains ''"<<Device<<"''"<<endl;');
  _Out.Add('     exit(-1);');
  _Out.Add('  }');
  _Out.Add('  if (!it->second.online) {');
  _Out.Add('     cl_int ret1, ret2;');
  _Out.Add('     it->second.context = clCreateContext(NULL, 1, &it->second.device_id, NULL, NULL, &ret1);');
  _Out.Add('     it->second.command_queue = clCreateCommandQueue(it->second.context, it->second.device_id, CL_QUEUE_PROFILING_ENABLE, &ret2);');
  _Out.Add('     if (ret1 != CL_SUCCESS || ret2 != CL_SUCCESS) {');
  _Out.Add('        cout<<"Device opening error: "<<ret1<<" : "<<ret2<<endl;');
  _Out.Add('        exit(-1);');
  _Out.Add('     }');
  _Out.Add('     it->second.online = true;');
  _Out.Add('  }');
  _Out.Add('  return it->second;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('char * __collect(const char ** source) {');
  _Out.Add('  string S = "";');
  _Out.Add('  while (*source) {');
  _Out.Add('    S.append(*source);');
  _Out.Add('    S.append("\n");');
  _Out.Add('    source++;');
  _Out.Add('  }');
  _Out.Add('  int n = S.length();');
  _Out.Add('');
  _Out.Add('  char * result = new char[n+1];');
  _Out.Add('  memmove(result, S.c_str(), n);');
  _Out.Add('  result[n] = 0x0;');
  _Out.Add('');
  _Out.Add('  return result;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('cl_kernel __compile_on_device(__device & d, const char ** common, const char ** kernel_source, const char * kernel_name) {');
  _Out.Add('   map<cl_device_id, __program *>::iterator itp = __programs.find(d.device_id);');
  _Out.Add('   if (itp != __programs.end()) {');
  _Out.Add('      __program * cur = itp->second;');
  _Out.Add('      while (cur) {');
  _Out.Add('        if (kernel_source == cur->kernel_source)');
  _Out.Add('           return cur->kernel;');
  _Out.Add('        cur = cur->next;');
  _Out.Add('      }');
  _Out.Add('   } else');
  _Out.Add('      __programs[d.device_id] = NULL;');
  _Out.Add('');
  _Out.Add('   __program * prg = new __program;');
  _Out.Add('');
  _Out.Add('   prg->kernel_source = kernel_source;');
  _Out.Add('');
  _Out.Add('   char * log = new char[65536*2];');
  _Out.Add('   char * prog = new char[65536*2];');
  _Out.Add('   cl_int ret;');
  _Out.Add('   size_t sz;');
  _Out.Add('');
  _Out.Add('   char * _common = __collect(common);');
  _Out.Add('   char * _kernel = __collect(kernel_source);');
  _Out.Add('');
  _Out.Add('   size_t n  = strlen(_common);');
  _Out.Add('   size_t n1 = strlen(_kernel);');
  _Out.Add('   memmove(&prog[0], _common, n);');
  _Out.Add('   prog[n++] = 0x0D; prog[n++] = 0x0A;');
  _Out.Add('   memmove(&prog[n], _kernel, n1);');
  _Out.Add('   n += n1;');
  _Out.Add('   prog[n] = 0x0;');
  _Out.Add('');
  _Out.Add('   prg->program = clCreateProgramWithSource(d.context, 1, (const char **)&prog, (const size_t *)&n, &ret);');
  _Out.Add('   if (ret != CL_SUCCESS) {');
  _Out.Add('      cout<<"Create device program error = "<<ret<<endl; exit(-1);');
  _Out.Add('   }');
  _Out.Add('   double t = omp_get_wtime();');
  _Out.Add('   ret = clBuildProgram(prg->program, 1, &d.device_id, "-cl-opt-disable", NULL, NULL);');
  _Out.Add('   if (ret != CL_SUCCESS) {');
  _Out.Add('      cout<<"Build device program error = "<<ret<<endl;');
  _Out.Add('      clGetProgramBuildInfo(prg->program, d.device_id, CL_PROGRAM_BUILD_LOG, 65536*2, log, &sz);');
  _Out.Add('      log[sz] = 0x0;');
  _Out.Add('      cout<<"--- Build <"<<kernel_name<<"> Info ---"<<endl;');
  _Out.Add('      cout<<log;');
  _Out.Add('      cout<<"--- End of Build Info ---"<<endl;');
  _Out.Add('      exit(-1);');
  _Out.Add('   }');
  _Out.Add('');
  _Out.Add('   d.compile_time = omp_get_wtime() - t;');
  _Out.Add('   prg->kernel = clCreateKernel(prg->program, kernel_name, &ret);');
  _Out.Add('   if (ret != CL_SUCCESS) {');
  _Out.Add('      cout<<"Create kernel for device program error = "<<ret<<endl; exit(-1);');
  _Out.Add('   }');
  _Out.Add('');
  _Out.Add('   delete _common;');
  _Out.Add('   delete _kernel;');
  _Out.Add('');
  _Out.Add('   delete prog;');
  _Out.Add('   delete log;');
  _Out.Add('');
  _Out.Add('   prg->next = __programs[d.device_id];');
  _Out.Add('   __programs[d.device_id] = prg;');
  _Out.Add('');
  _Out.Add('   return prg->kernel;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('void __run_kernel(__device & d, cl_kernel kernel,');
  _Out.Add('                  int n_args,');
  _Out.Add('                  int * size_items, int * offs_items, int * mode_items, bool * is_global,');
  _Out.Add('                  long long * n_pointer, int * n_items,');
  _Out.Add('                  char ** cpu_data, int n) {');
  _Out.Add('  cl_mem gpu_data[256];');
  _Out.Add('  cl_int ret;');
  _Out.Add('');
  _Out.Add('  for (int i = 0; i <= n_args; i++) {');
  _Out.Add('      gpu_data[i] = clCreateBuffer(d.context, CL_MEM_USE_HOST_PTR+mode_items[i], n_items[i]*size_items[i], cpu_data[i], &ret);');
  _Out.Add('      if (ret != CL_SUCCESS) {');
  _Out.Add('         cout<<"Error: can not allocate buffer, error "<<ret<<endl;');
  _Out.Add('         exit(-1);');
  _Out.Add('      }');
  _Out.Add('  }');
  _Out.Add('  /* vectorize */');
  _Out.Add('  for (int i = 0; i <= n_args; i++) {');
  _Out.Add('      ret = clSetKernelArg(kernel, i, sizeof(cl_mem), (void *)&gpu_data[i]);');
  _Out.Add('      if (ret != CL_SUCCESS) {');
  _Out.Add('         cout<<"Error "<<ret<<": can not set argument "<<i<<" for kernel"<<endl; exit(-1);');
  _Out.Add('      }');
  _Out.Add('  }');
  _Out.Add('  size_t work_size = n;');
  _Out.Add('  size_t max_group_size = d.max_work_size/d.n_units;');
  _Out.Add('  size_t work_groups = d.n_units;');
  _Out.Add('  while (work_groups > 1 && work_size % work_groups != 0)');
  _Out.Add('    work_groups--;');
  _Out.Add('  size_t _group_size = work_size/work_groups;');
  _Out.Add('  while ((_group_size > __max_group_threads || _group_size > max_group_size) && work_size%(2*work_groups) == 0) {');
  _Out.Add('     work_groups *= 2;');
  _Out.Add('     _group_size /= 2;');
  _Out.Add('  }');
  _Out.Add('  size_t * group_size = _group_size > __max_group_threads || _group_size > max_group_size ? NULL : &_group_size;');
  _Out.Add('  cl_event event;');
  _Out.Add('  ret = clEnqueueNDRangeKernel(d.command_queue, kernel, 1, NULL, &work_size, group_size, 0, NULL, &event);');
  _Out.Add('  if (ret != CL_SUCCESS) {');
  _Out.Add('     cout<<"Error "<<ret<<": kernel execution"<<endl; exit(-1);');
  _Out.Add('  }');
  _Out.Add('  clWaitForEvents(1, &event);');
  _Out.Add('  clFinish(d.command_queue);');
  _Out.Add('  cl_ulong time_start;');
  _Out.Add('  cl_ulong time_end;');
  _Out.Add('  clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_START, sizeof(time_start), &time_start, NULL);');
  _Out.Add('  clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_END, sizeof(time_end), &time_end, NULL);');
  _Out.Add('  d.execution_time = (time_end-time_start)/1000000000.0;');
  _Out.Add('  for (int j = 0; j < n_args; j++)');
  _Out.Add('    if (n_items[j] && size_items[j]) {');
  _Out.Add('       void * tmp_ptr = NULL;');
  _Out.Add('       tmp_ptr = clEnqueueMapBuffer(d.command_queue, gpu_data[j], true, CL_MAP_READ, 0, n_items[j]*size_items[j], 0, NULL, NULL, &ret);');
  _Out.Add('       if (tmp_ptr != cpu_data[j]) {');
  _Out.Add('          	cout<<"Error mapping _local/_global buffer"<<endl; exit(-1);');
  _Out.Add('       }');
  _Out.Add('    }');
  _Out.Add('  clFinish(d.command_queue);');
  _Out.Add('  for (int j = 0; j < n_args; j++)');
  _Out.Add('    if (n_items[j] && size_items[j]) {');
  _Out.Add('       ret = clEnqueueUnmapMemObject(d.command_queue, gpu_data[j], cpu_data[j], 0, NULL, NULL);');
  _Out.Add('       if (ret != CL_SUCCESS) {');
  _Out.Add('          cout<<"Error "<<ret<<": unmap _local/_global buffer"<<endl; exit(-1);');
  _Out.Add('       }');
  _Out.Add('    }');
  _Out.Add('  clFinish(d.command_queue);');
  _Out.Add('  for (int i = 0; i <= n_args; i++)');
  _Out.Add('      ret = clReleaseMemObject(gpu_data[i]);');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('int vector_max_size(const char * Device) {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  if (Device) {');
  _Out.Add('     for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('         if (it->first.find(Device) != string::npos)');
  _Out.Add('            break;');
  _Out.Add('  } else');
  _Out.Add('     it = __devices.find(__powerfulest_device);');
  _Out.Add('  return it->second.max_work_size;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('int vector_max_units(const char * Device) {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  if (Device) {');
  _Out.Add('     for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('         if (it->first.find(Device) != string::npos)');
  _Out.Add('            break;');
  _Out.Add('  } else');
  _Out.Add('     it = __devices.find(__powerfulest_device);');
  _Out.Add('  return it->second.n_units;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('const char * get_device_id(int n) {');
  _Out.Add('  if (n >= __devices.size())');
  _Out.Add('     return NULL;');
  _Out.Add('  map<string, __device>::iterator idev = __devices.begin();');
  _Out.Add('  while (n--) idev++;');
  _Out.Add('  return idev->first.c_str();');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('double last_compile_time(const char * Device) {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  if (Device) {');
  _Out.Add('     for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('         if (it->first.find(Device) != string::npos)');
  _Out.Add('            break;');
  _Out.Add('  } else');
  _Out.Add('     it = __devices.find(__powerfulest_device);');
  _Out.Add('  double result = it->second.compile_time;');
  _Out.Add('  it->second.compile_time = 0.0;');
  _Out.Add('  return result;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('double last_execution_time(const char * Device) {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  if (Device) {');
  _Out.Add('     for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('         if (it->first.find(Device) != string::npos)');
  _Out.Add('            break;');
  _Out.Add('  } else');
  _Out.Add('     it = __devices.find(__powerfulest_device);');
  _Out.Add('  double result = it->second.execution_time;');
  _Out.Add('  it->second.execution_time = 0.0;');
  _Out.Add('  return result;');
  _Out.Add('}');
  _Out.Add('unsigned long local_memory_size(const char * Device) {');
  _Out.Add('  map<string, __device>::iterator it;');
  _Out.Add('  if (Device) {');
  _Out.Add('     for (it = __devices.begin(); it != __devices.end(); it++)');
  _Out.Add('         if (it->first.find(Device) != string::npos)');
  _Out.Add('            break;');
  _Out.Add('  } else');
  _Out.Add('     it = __devices.find(__powerfulest_device);');
  _Out.Add('  return it->second.local_mem_size;');
  _Out.Add('}');
  _Out.Add('');
  _Out.Add('#define plan_vector_id() 0');
  _Out.Add('#define plan_vector_size() 1');
  _Out.Add('');
  _Out.Add('#define __run_opencl_kernel__ \');
  _Out.Add('  do { \');
  _Out.Add('    char * cpu_data[n_args+1]; \');
  _Out.Add('    cl_int ret; \');
  _Out.Add('    int __n__ = 0; \');
  _Out.Add('    for (it = __event_list__->begin(); __n__ < d.max_work_size && it != __event_list__->end() && !((*it).Flags & 1); ++it) \');
  _Out.Add('        __n__++; \');
  _Out.Add('    if (__n__ == 0) break; \');
  _Out.Add('    if (__n__ == d.max_work_size && it != __event_list__->end() && !((*it).Flags & 1)) { \');
  _Out.Add('       cout<<"Error: too many items in vectorized section of plan: exceeds "<<d.max_work_size<<endl; \');
  _Out.Add('       exit(-1); \');
  _Out.Add('    } \');
  _Out.Add('    for (int i = 0; i < n_args; i++) { \');
  _Out.Add('        if (is_global[i]) n_items[i] = n_pointer[i] ? n_pointer[i] : loc_items(i); \');
  _Out.Add('        else if (n_pointer[i] == 0) n_items[i] = __n__; \');
  _Out.Add('        else { \');
  _Out.Add('          n_pointer[i] = reinterpret_cast<long long>(malloc(__n__*sizeof(int))); \');
  _Out.Add('          it = __event_list__->begin(); \');
  _Out.Add('          n_items[i] = 0; \');
  _Out.Add('          for (int j = 0; j < __n__; j++) { \');
  _Out.Add('              __planned__ = *it; ++it; \');
  _Out.Add('              n_items[i] += (reinterpret_cast<int *>(n_pointer[i])[j] = loc_items(i)); \');
  _Out.Add('          } \');
  _Out.Add('        } \');
  _Out.Add('        cpu_data[i] = (char *) malloc(n_items[i]*size_items[i]); \');
  _Out.Add('    } \');
  _Out.Add('    const int __nl__ = __max(1,n_locs); \');
  _Out.Add('    n_items[n_args] = __nl__*__n__; \');
  _Out.Add('    cpu_data[n_args] = (char *) malloc(__nl__*__n__*sizeof(int)); \');
  _Out.Add('    int __offs[n_args] = {0}; \');
  _Out.Add('    int * offs = reinterpret_cast<int *>(cpu_data[n_args]); \');
  _Out.Add('    it = __event_list__->begin(); \');
  _Out.Add('    for (int i = 0; i < __n__; i++) { \');
  _Out.Add('        __planned__ = *it; ++it; \');
  _Out.Add('        memmove(&offs[i*__nl__], __offs, __nl__*sizeof(int)); \');
  _Out.Add('        int k = 0; \');
  _Out.Add('        for (int j = 0; j < n_args; j++) \');
  _Out.Add('          if (!is_global[j] || i == 0) { \');
  _Out.Add('             int __nn__ = is_global[j] ? (n_pointer[j] ? n_pointer[j] : loc_items(j)) : (n_pointer[j] == 0 ? 1 : reinterpret_cast<int *>(n_pointer[j])[i]); \');
  _Out.Add('             if (n_pointer[j] || is_global[j] && loc_items(j)) \');
  _Out.Add('                if (is_global[j]) \');
  _Out.Add('                   memmove(&cpu_data[j][i*__nn__*size_items[j]],*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]),__nn__*size_items[j]); \');
  _Out.Add('                else { \');
  _Out.Add('                   memmove(&cpu_data[j][__offs[k]*size_items[j]],*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]),__nn__*size_items[j]); \');
  _Out.Add('                   __offs[k] += __nn__; \');
  _Out.Add('                   k++; \');
  _Out.Add('                } \');
  _Out.Add('             else \');
  _Out.Add('                memmove(&cpu_data[j][i*__nn__*size_items[j]],reinterpret_cast<char *>(&__planned__)+offs_items[j],__nn__*size_items[j]); \');
  _Out.Add('          } \');
  _Out.Add('    } \');
  _Out.Add('    __run_kernel(d, kernel, n_args, size_items, offs_items, mode_items, is_global, n_pointer, n_items, cpu_data, __n__); \');
  _Out.Add('    /* reverse_pump */ \');
  _Out.Add('    memset(__offs, 0, __nl__*sizeof(int)); \');
  _Out.Add('    for (int i = 0; i < __n__; i++) { \');
  _Out.Add('        __planned__ = __event_list__->front(); \');
  _Out.Add('        __event_list__->pop_front(); \');
  _Out.Add('        int k = 0; \');
  _Out.Add('        for (int j = 0; j < n_args; j++) \');
  _Out.Add('          if (!is_global[j] && n_pointer[j]) { \');
  _Out.Add('             int __nn__ = reinterpret_cast<int *>(n_pointer[j])[i]; \');
  _Out.Add('             memmove(*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]), &cpu_data[j][__offs[k]*size_items[j]], __nn__*size_items[j]); \');
  _Out.Add('             __offs[k] += __nn__; \');
  _Out.Add('             k++; \');
  _Out.Add('          } else if (is_global[j] && i == 0) { \');
  _Out.Add('             int __nn__ = n_pointer[j] ? n_pointer[j] : loc_items(j); \');
  _Out.Add('             memmove(*reinterpret_cast<void **>(reinterpret_cast<char *>(&__planned__)+offs_items[j]),&cpu_data[j][i*__nn__*size_items[j]],__nn__*size_items[j]); \');
  _Out.Add('          } \');
  _Out.Add('    } \');
  _Out.Add('    if (!__event_list__->empty()) { \');
  _Out.Add('       __planned__ = __event_list__->front(); \');
  _Out.Add('       if (__planned__.Flags & 1) __event_list__->pop_front(); \');
  _Out.Add('    } \');
  _Out.Add('    for (int i = 0; i <= n_args; i++) { \');
  _Out.Add('        if (!is_global[i] && n_pointer[i]) free(reinterpret_cast<void *>(n_pointer[i])); \');
  _Out.Add('        free(cpu_data[i]); \');
  _Out.Add('    } \');
  _Out.Add('  } while(0)');
  _Out.Add('#else');
  _Out.Add(' #define plan_vector_id() plan_processor_id()');
  _Out.Add(' #define plan_vector_size() plan_processors()');
  _Out.Add(' #define vector_max_size(S) (0x7FFFFFFF)');
  _Out.Add(' #define last_compile_time(S) (0.0)');
  _Out.Add(' #define last_execution_time(S) (0.0)');
  _Out.Add('#endif');
  _Out.Add('#ifdef __REENT_MPI__');
  _Out.Add('#include "mpi.h"');
  _Out.Add('int __cluster_size__;');
  _Out.Add('int __cluster_id__;');
  _Out.Add('inline int plan_cluster_size() {');
  _Out.Add('  return __cluster_size__;');
  _Out.Add('}');
  _Out.Add('inline int plan_cluster_id() {');
  _Out.Add('  return __cluster_id__;');
  _Out.Add('}');
  _Out.Add('const int th_back  = 0;');
  _Out.Add('const int th_front = 1;');
  _Out.Add('#endif');
  _Out.Add('#include <time.h>');
  _Out.Add('#include <list>');
  _Out.Add('#include <map>');
  _Out.Add('#include <vector>');
  _Out.Add('#include <iostream>');
  _Out.Add('#include <time.h>');
  _Out.Add('#include <string>');
  _Out.Add('#include <stdlib.h>');
  _Out.Add('using namespace std;');
  _Out.Add('#ifdef _OPENMP');
  _Out.Add('  #include <omp.h>');
  _Out.Add('#endif');
  _Out.Add(Signals);
  _Out.Add(Tunnels_Vars_Sems);
  _Out.Add(ReentList);
  _Out.Add(Topologies);
  _Out.Add(CircularList);
  _Out.Add('#define plan_atomize __transaction_atomic');
  _Out.Add('#define plan_item_type(A) _params_##A');
  _Out.Add('#define plan_type(A) A##_plan_type');
  _Out.Add('#define plan(A) (A##_plan_prefix _events_##A)');
  _Out.Add('#define _size(A) (A.size())');
  _Out.Add('#define plan_stop _plan_stop()');
  _Out.Add('#define clear_plan _clear_plan()');
  _Out.Add('#define plan_group_first _plan_group_first()');
  _Out.Add('#define plan_group_last _plan_group_last()');
  _Out.Add('#define plan_group_parallelize _plan_group_parallelize()');
  _Out.Add('#define plan_group_atomize _plan_group_atomize()');
  _Out.Add('#define plan_group_soft_atomize _plan_group_soft_atomize()');
  _Out.Add('#define plan_group_vectorize(S) _plan_group_vectorize(S)');
  _Out.Add('#define plan_group_typize(S) _plan_group_vectorize(S)');
  _Out.Add('#ifdef __REENT_MPI__');
  _Out.Add('#define __throw_cluster__(ID,InputProcName,__Direction__) \');
  _Out.Add(' if (__clustered_topology(plan_topology_num())) { \');
  _Out.Add('    long long send_id; \');
  _Out.Add('    if (InputProcName == 1) \');
  _Out.Add('       send_id = reinterpret_cast<long long>(__chain_plan__); \');
  _Out.Add('    else { \');
  _Out.Add('       __Node * node = get_topology_link(plan_topology_num(),reinterpret_cast<void *>(&_call_##ID),plan_linear_num(),InputProcName); \');
  _Out.Add('       send_id = node->id; \');
  _Out.Add('    } \');
  _Out.Add('    if (send_id < 0) { \');
  _Out.Add('       cout<<"Default throw link from "<<reinterpret_cast<void *>(&_call_##ID)<<"["<<plan_linear_num()<<"] does not exist"<<endl; \');
  _Out.Add('       exit(-1); \');
  _Out.Add('    } \');
  _Out.Add('    int tag_base = get_topology_tag(plan_topology_num()); \');
  _Out.Add('    int first = th_##__Direction__; \');
  _Out.Add('    MPI_Send(&first, 1, MPI_INT, send_id, tag_base+2, MPI_COMM_WORLD); \');
  _Out.Add('    MPI_Send(&__dummy_throw__, sizeof(__dummy_throw__), MPI_BYTE, send_id, tag_base+2, MPI_COMM_WORLD); \');
  _Out.Add('    break; \');
  _Out.Add(' }');
  _Out.Add('#else');
  _Out.Add('#define __throw_cluster__(ID,InputProcName,__Direction__) while(0)');
  _Out.Add('#endif');
  _Out.Add('#ifdef _OPENMP');
  _Out.Add('#define __plan_stop(Allow) \');
  _Out.Add('   do if (Allow) {\');
  _Out.Add('        omp_set_lock(__continue_lock__); \');
  _Out.Add('        *__continue_plan__ = 0; \');
  _Out.Add('        omp_unset_lock(__continue_lock__); \');
  _Out.Add('   } while(0)');
  _Out.Add('#define plan_processor_id omp_get_thread_num');
  _Out.Add('#define plan_processors() (omp_in_parallel() ? omp_get_num_threads() : omp_get_max_threads())');
  _Out.Add('#define _throw_num_stages() __get_num_stages(plan_topology_num())');
  _Out.Add('#define throw_num_stages() _throw_num_stages()');
  _Out.Add('char __AFTER_CONTINUE(char Allow, omp_lock_t * __continue_lock__, char * __continue_plan__) {');
  _Out.Add('  char Result = 0;');
  _Out.Add('  if (Allow) {');
  _Out.Add('     omp_set_lock(__continue_lock__);');
  _Out.Add('     if (Result = *__continue_plan__ == 2) *__continue_plan__ = 1;');
  _Out.Add('     omp_unset_lock(__continue_lock__);');
  _Out.Add('  }');
  _Out.Add('  return Result;');
  _Out.Add('}');
  _Out.Add('#define __plan_locking__ plan_set_lock(__plan_lock__)');
  _Out.Add('#define __plan_unlocking__ do { plan_unset_lock(__plan_lock__); } while(0)');
  _Out.Add('#define __plan_signal__ do { __signal_reent_event(__signaler__); __instead_signal_yield(); } while(0)');
  _Out.Add('#define __throw_locking__ do if (__chain_lock__) plan_set_lock(__chain_lock__); while(0)');
  _Out.Add('#define __throw_substitute__(ID,InputProcName) \');
  _Out.Add('    __Node * node = get_topology_link(plan_topology_num(),reinterpret_cast<void *>(&_call_##ID),plan_linear_num(),InputProcName); \');
  _Out.Add('    __abstract_list<_throw_##ID> * __throw_list__ = (__abstract_list<_throw_##ID> *) node->Plan; \');
  _Out.Add('    plan_lock_t * __chain_lock__ = node->LockPlan; \');
  _Out.Add('    __reent_event * __next_signaler = node->SignalPlan;');
  _Out.Add('#define __throw_unlocking__ do if (__chain_lock__) plan_unset_lock(__chain_lock__); while(0)');
  _Out.Add('#define __throw_signal__ do if (__next_signaler__) { __signal_reent_event(__next_signaler__); __instead_signal_yield(); } while(0)');
  _Out.Add('void __START_LOCK__(int __num_threads__, omp_lock_t * __start_lock__) {');
  _Out.Add(' int __i;');
  _Out.Add(' if (__start_lock__) {');
  _Out.Add('    #pragma omp for private(__i) schedule(static,1) ordered nowait');
  _Out.Add('    for (__i=0; __i<__num_threads__; __i++)');
  _Out.Add('        #pragma omp ordered');
  _Out.Add('          {');
  _Out.Add('           omp_set_lock(__start_lock__);');
  _Out.Add('           if (__i!=0)');
  _Out.Add('              omp_unset_lock(__start_lock__);');
  _Out.Add('          }');
  _Out.Add(' }');
  _Out.Add('}');
  _Out.Add('#else');
  _Out.Add('#define plan_processor_id() 0');
  _Out.Add('#define plan_processors() 1');
  _Out.Add('#define _throw_num_stages() (__num_stages__)');
  _Out.Add('#define throw_num_stages() _throw_num_stages()');
  _Out.Add('#define __plan_locking__ while(0)');
  _Out.Add('#define __plan_unlocking__ while(0)');
  _Out.Add('#define __plan_signal__ while(0)');
  _Out.Add('#define __throw_locking__ while(0)');
  _Out.Add('#define __throw_substitute__(ID,InputProcName) __abstract_list<_throw_##ID> * __throw_list__ = (__abstract_list<_throw_##ID> *) __chain_plan__;');
  _Out.Add('#define __throw_unlocking__ while(0)');
  _Out.Add('#define __throw_signal__ while(0)');
  _Out.Add('#endif');
  _Out.Add('#define plan_locking() __plan_locking__');
  _Out.Add('#define plan_unlocking() __plan_unlocking__');
  _Out.Add('#ifdef __REENT_MPI__');
  _Out.Add('#define __wait_cluster__(ID,__Direction__) \');
  _Out.Add(' if (__clustered_topology(plan_topology_num())) { \');
  _Out.Add('    int tag_base = get_topology_tag(plan_topology_num()); \');
  _Out.Add('    MPI_Status status; \');
  _Out.Add('    int item_received; \');
  _Out.Add('    do { \');
  _Out.Add('       MPI_Iprobe(MPI_ANY_SOURCE, tag_base+2, MPI_COMM_WORLD, &item_received, &status); \');
  _Out.Add('       if (item_received) { \');
  _Out.Add('          MPI_Status status1; \');
  _Out.Add('          int first; \');
  _Out.Add('          MPI_Recv(&first, 1, MPI_INT, status.MPI_SOURCE, tag_base+2, MPI_COMM_WORLD, &status1); \');
  _Out.Add('          MPI_Recv(&__dummy_throw__, sizeof(__dummy_throw__), MPI_BYTE, status.MPI_SOURCE, tag_base+2, MPI_COMM_WORLD, &status1); \');
  _Out.Add('       } \');
  _Out.Add('    } while (!item_received && plan_empty); \');
  _Out.Add('    if (!item_received) { \');
  _Out.Add('       __plan_locking__; \');
  _Out.Add('       __dummy_throw__ = __event_list__->__Direction__(); \');
  _Out.Add('       __event_list__->pop_##__Direction__(); \');
  _Out.Add('       __plan_unlocking__; \');
  _Out.Add('    } \');
  _Out.Add(' } else');
  _Out.Add('#else');
  _Out.Add('#define __wait_cluster__(ID,__Direction__) /* We have no the clustered topology */');
  _Out.Add('#endif');
  _Out.Add('#define __wait_smp__(ID,__Direction__) \');
  _Out.Add(' do { \');
  _Out.Add('    while (plan_empty) { \');
  _Out.Add('       _Yield(); \');
  _Out.Add('       Sleep(5); \');
  _Out.Add('    } \');
  _Out.Add('    __plan_locking__; \');
  _Out.Add('    __dummy_throw__ = __event_list__->__Direction__(); \');
  _Out.Add('    if (__dummy_throw__.Flags & 1) result = 0; \');
  _Out.Add('    else __event_list__->pop_##__Direction__(); \');
  _Out.Add('    __plan_unlocking__; \');
  _Out.Add(' } while (0)');
  _Out.Add('#define __get_item_begin__(ID,__Direction__) \');
  _Out.Add(' do { \');
  _Out.Add('    plan_item_type(ID) __dummy_throw__; \');
  _Out.Add('    __wait_cluster__(ID,__Direction__) \');
  _Out.Add('    __wait_smp__(ID,__Direction__)');
  _Out.Add('#define __get_item_end__ \');
  _Out.Add(' } while (0)');
  _Out.Add('long long __dummy_counter = 0;');
  _Out.Add('class __init_openmp_mpi__ {');
  _Out.Add('  public:');
  _Out.Add('  __init_openmp_mpi__() {');
  _Out.Add('#ifdef _OPENMP');
  _Out.Add('    omp_set_nested(1);');
  _Out.Add('    __topo_lock__ = new plan_lock_t;');
  _Out.Add('    plan_init_lock(__topo_lock__);');
  _Out.Add('    omp_init_lock(&__funnel_lock__);');
  _Out.Add('#ifdef __REENT_MPI__');
  _Out.Add('    omp_init_lock(&__cfunnel_lock__);');
  _Out.Add('#endif');
  _Out.Add('#endif');
  _Out.Add('    srand((unsigned int) time(NULL));');
  _Out.Add('#ifdef __REENT_MPI__');
  _Out.Add('    int provided;');
  _Out.Add('    MPI_Init_thread(NULL,NULL, MPI_THREAD_SERIALIZED, &provided);');
  _Out.Add('    if (provided != MPI_THREAD_SERIALIZED && provided != MPI_THREAD_MULTIPLE) {');
  _Out.Add('       cout<<"MPI: multithreading support is not suffucuent"<<endl;');
  _Out.Add('       MPI_Abort(MPI_COMM_WORLD,-1);');
  _Out.Add('    }');
  _Out.Add('    MPI_Comm_size(MPI_COMM_WORLD,&__cluster_size__);');
  _Out.Add('    MPI_Comm_rank(MPI_COMM_WORLD,&__cluster_id__);');
  _Out.Add('#endif');
  _Out.Add('#ifdef __REENT_GPU__');
  _Out.Add('    __init_devices();');
  _Out.Add('#endif');
  _Out.Add('  };');
  _Out.Add('  ~__init_openmp_mpi__() {');
  _Out.Add('    srand((unsigned int) __dummy_counter);');
  _Out.Add('#ifdef __REENT_GPU__');
  _Out.Add('    __free_devices();');
  _Out.Add('#endif');
  _Out.Add('#ifdef __REENT_MPI__');
  _Out.Add('    MPI_Finalize();');
  _Out.Add('#endif');
  _Out.Add('  };');
  _Out.Add('};');
  _Out.Add('__init_openmp_mpi__ __ompi_initializer = __init_openmp_mpi__();');
  _Out.Add(Transact);
  _Out.Add('#define soft_transact_array(Type) TArray<Type>');
  _Out.Add('#define soft_transact_var(Type) TScalar<Type>');
  _Out.Add('#define soft_transact_in(Type) TIn<Type>');
  _Out.Add('#define soft_transact_out(Type) TOut<Type>');
  _Out.Add('#define reduction(A) /* reduction */');
  _Out.Add('void plan_undo_locals() { }')
End;

End.
