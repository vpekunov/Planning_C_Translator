   Это прототипный транслятор языка Planning C 2.0.

   Документация содержится в каталоге Documentation

   Может работать в Windows/Linux. Компилируется с помощью Free Pascal (проекты Reenterable, xpathInduct, Grammar
и mpi2reent), необходимые библиотеки компилируются с помощью C++ (проекты Predicates, PrologIntrf, prolog_micro_brain).
   Лексико-синтаксические анализаторы в Windows компилируются как проекты ANTLR\plc_cpp\lexer_plc.dir\lexer_plc.sln
и ANTLR\plc_preproc\lexer_preproc.dir\lexer_preproc.sln. В Linux данные программы компилируются
при запуске интсалляционного скрипта.
   При работе в Linux проект PrologIntrf не используется и не требует компиляции.
   Скомпилированные библиотеки Predicates, xpathInduct, Grammar (и, при работе в Windows, PrologIntrf) должны быть
помещены в рабочий каталог транслятора.
   Транслятор переводит Planning C программу на C++, который потом компилируется стандартным
компилятором C++. Поэтому, для компиляции транслированных Planning C-программ Вам потребуется
компилятор C++.

   ПРИМЕР ИНСТАЛЛЯЦИИ (для Linux)

1. Инсталлировать Free Pascal
2. Инсталлировать cmake
3. Инсталлировать uuid-dev
4. Инсталлировать git
5. Инсталлировать php, желательно не ниже 8.1.2
6. Инсталлировать OpenCL
7. Инсталлировать boost
8. Инсталлировать mpi
9. Инсталлировать php-xml
10. Инсталлировать, если возможно, компилятор gcc/g++ с поддержкой cilk (-fcilkplus)
11. Запустить скрипт install.sh. При этом будет собран компилятор, а также автоматически скомпилированы все
   примеры из каталога Examples и его подкаталогов.

   ПРИМЕРЫ ПРОГРАММ НА Planning C (содержатся в каталоге Examples).

   Для компиляции произвольного (с именем файла, не начинающимся с mpi_) примера EXAMPLE.cpp необходимо:
1. Провести трансляцию на C++, с генерацией выходного файла (например, out.cpp):
   ./Reenterable EXAMPLE.cpp out.cpp
2. Скомпилировать выходной файл (например, out.cpp) в запускаемый файл (например, EXAMPLE),
например, компилятором g++:
   g++ -o EXAMPLE out.cpp -lm -lpthread -fopenmp --std=c++11 -fpermissive -fgnu-tm
Если программа не использует транзакционную память, то ключ -fgnu-tm не нужен.
Если программа использует видеоускорители, то дополнительно потребуется ключ -lOpenCL, соответственно,
  будут необходимы библиотеки OpenCL.
Если программа использует расчеты с применением кластерных средств, то потребуется установленная среда
исполнения MPI-2, а компиляция должна выполняться с помощью mpic++

   Для компиляции произвольного примера с трансляцией MPI->Planning C, например mpi_example.cpp для исполнения
на 5 процессорах, необходим предварительный шаг:
0. ./mpi2reent 5 mpi_example.cpp EXAMPLE.cpp
При этом будет получен Planning C-файл EXAMPLE.cpp, который компилируется по описанной выше двухходовой схеме.
Обращаем внимание, что после такой трансляции наличие среды MPI НЕ ТРЕБУЕТСЯ, все вызовы MPI будут эмулироваться
стандартными средствами Planning C.

   ПРИМЕРЫ АВТОМАТИЧЕСКОГО РАСПАРАЛЛЕЛИВАНИЯ ПРОГРАММ СРЕДСТВАМИ Planning C

   Размеры распараллеливаемых программ существенно ограничены возможностями Prolog MicroBrain! Не рекомендуется
использовать с программами объемом более 100-200 строк, возможна нехватка памяти и ошибки при трансляции.

1. Planning C умеет распараллеливать небольшие программы, вставляя в них директивы Cilk++. Для этого в программу
включается модуль #include "cilk_compile.h" и запускается транслятор Planning C. В инсталляцию включен такой
пример reent_cilk.c, его можно транслировать так:
   ./Reenterable -nosourcelines -extensionsonly reent_cilk.c out.cpp
При этом результат автоматического распараллеливания можно посмотреть в файле _cilk.cpp (а не в out.cpp, как могло
бы показаться). В нем обнаружится несколько вставленных директив Cilk++. Этот файл можно скомпилировать любым
компилятором C++, поддерживающим расширение Cilk++ (например, это некоторые версии GNU C++).
2. Planning C умеет распараллеливать небольшие программы, используя расщепляющие трансформации на базе сверхоптимистичных
вычислений. Для этого в программу включается модуль #include "atomic_compile.h" и запускается транслятор Planning C.
В инсталляцию включен такой пример reent_atomic.cpp, его можно транслировать так:
   ./Reenterable -nosourcelines -extensionsonly reent_atomic.cpp out.cpp
При этом результат автоматического распараллеливания можно посмотреть в файле _atomic.cpp (а не в out.cpp, как могло
бы показаться). В нем обнаружится несколько вставленных директив Planning C и OpenMP. Этот файл можно скомпилировать любым
компилятором C++, поддерживающим расширение OpenMP, кроме того, потребуются библиотеки transact.h и funnels_atomic.h,
входящие в комплект Planning C (есть в репозитории).
