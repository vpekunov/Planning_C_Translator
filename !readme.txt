   Это прототипный транслятор языка Planning C 2.0.

   Документация содержится в каталоге Documentation

   Может работать в Windows/Linux. Компилируется с помощью Free Pascal (проекты Reenterable
и mpi2reent), необходимые библиотеки компилируются с помощью C++ (проекты Predicates, PrologIntrf).
При работе в Linux проект PrologIntrf не используется и не требует компиляции.
   При работе в Linux транслятор требует наличия интерпретатора GNU Prolog -- его запускаемые
файлы должны находиться в рабочем каталоге транслятора.
   Скомпилированная библиотека Predicates (и, при работе в Windows, PrologIntrf) также должна быть
помещена в рабочий каталог транслятора.
   Транслятор переводит Planning C программу на C++, который потом компилируется стандартным
компилятором C++. Поэтому, для компиляции транслированных Planning C-программ Вам потребуется
компилятор C++.

   ПРИМЕР ИНСТАЛЛЯЦИИ (для Linux)

1. Инсталлировать Free Pascal
2. Инсталлировать GNU Prolog 1.4.4
3. Запустить скрипт install.sh

   ПРИМЕРЫ ПРОГРАММ НА Planning C (содержатся в каталоге Examples).

   Для компиляции произвольного (с именем файла, не начинающимся с mpi_) примера EXAMPLE.cpp необходимо:
1. Провести трансляцию на C++, с генерацией выходного файла (например, out.cpp):
   ./Reenterable EXAMPLE.cpp out.cpp
2. Скомпилировать выходной файл (например, out.cpp) в запускаемый файл (например, EXAMPLE),
например, компилятором g++:
   g++ -o EXAMPLE out.cpp -lm -lpthread -fopenmp --std=c++0x -fpermissive -fgnu-tm
Если программа не использует транзакционную память, то ключ -fgnu-tm не нужен.
Если программа использует видеоускорители, то дополнительно потребуется ключ -lOpenCL, соответственно,
  будут необходимы библиотеки OpenCL.
Если программа использует расчеты с применением кластерных средств, то потребуется установленная среда
исполнения MPI-2, а компиляция должна выполняться с помощью mpic++

   Для компиляции произвольного примера с трансляцией MPI->Planning C, например mpi_example.cpp для исполнения
на 5 процессорах, необходим предварительный шаг:
0. ./mpi2reent 5 mpi_example.cpp EXAMPLE.cpp
При этом будет получен Planning C-файл EXAMPLE.cpp, который компилируется по описанной выше двухходовой схеме.
Обращаем внимание, что после такой трансляции наличие среды MPI НЕ ТРЕБУЕТСЯ, все вызовы MPI будут эмулироваться
стандартными средствами Planning C.

   ПРИМЕРЫ АВТОМАТИЧЕСКОГО РАСПАРАЛЛЕЛИВАНИЯ ПРОГРАММ СРЕДСТВАМИ Planning C

   Для успешной трансляции этих примеров не забудьте предварительно установить GNU Prolog 1.4.4.

1. Planning C умеет распараллеливать небольшие программы, вставляя в них директивы Cilk++. Для этого в программу
включается модуль #include "cilk_compile.h" и запускается транслятор Planning C. В инсталляцию включен такой
пример reent_cilk.cpp, его можно транслировать так:
   ./Reenterable -nosourcelines -extensionsonly reent_cilk.cpp out.cpp
При этом результат автоматического распараллеливания можно посмотреть в файле _cilk.cpp (а не в out.cpp, как могло
бы показаться). В нем обнаружится несколько вставленных директив Cilk++. Этот файл можно скомпилировать любым
компилятором C++, поддерживающим расширение Cilk++ (например, это некоторые версии GNU C++).
2. Planning C умеет распараллеливать небольшие программы, используя расщепляющие трансформации на базе сверхоптимистичных
вычислений. Для этого в программу включается модуль #include "atomic_compile.h" и запускается транслятор Planning C.
В инсталляцию включен такой пример reent_atomic.c, его можно транслировать так:
   ./Reenterable -nosourcelines -extensionsonly reent_atomic.c out.cpp
При этом результат автоматического распараллеливания можно посмотреть в файле _atomic.cpp (а не в out.cpp, как могло
бы показаться). В нем обнаружится несколько вставленных директив Planning C и OpenMP. Этот файл можно скомпилировать любым
компилятором C++, поддерживающим расширение OpenMP, кроме того, потребуются библиотеки transact.h и funnels_atomic.h,
входящие в комплект Planning C (есть в репозитории).
