
#define _CRT_SECURE_NO_WARNINGS
#include <map>
#include <string>
#include <iostream>
#include <stdio.h>


// Generated from ReentParser.g4 by ANTLR 4.9.2


#include "ReentParserListener.h"

#include "ReentParser.h"


using namespace antlrcpp;
using namespace antlr4;

ReentParser::ReentParser(TokenStream *input) : Parser(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

ReentParser::~ReentParser() {
  delete _interpreter;
}

std::string ReentParser::getGrammarFileName() const {
  return "ReentParser.g4";
}

const std::vector<std::string>& ReentParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& ReentParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- TranslationUnitContext ------------------------------------------------------------------

ReentParser::TranslationUnitContext::TranslationUnitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TranslationUnitContext::EOF() {
  return getToken(ReentParser::EOF, 0);
}

ReentParser::DeclarationseqContext* ReentParser::TranslationUnitContext::declarationseq() {
  return getRuleContext<ReentParser::DeclarationseqContext>(0);
}


size_t ReentParser::TranslationUnitContext::getRuleIndex() const {
  return ReentParser::RuleTranslationUnit;
}

void ReentParser::TranslationUnitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTranslationUnit(this);
}

void ReentParser::TranslationUnitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTranslationUnit(this);
}

ReentParser::TranslationUnitContext* ReentParser::translationUnit() {
  TranslationUnitContext *_localctx = _tracker.createInstance<TranslationUnitContext>(_ctx, getState());
  enterRule(_localctx, 0, ReentParser::RuleTranslationUnit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(569);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 8) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 8)) & ((1ULL << (ReentParser::PlanPragma - 8))
      | (1ULL << (ReentParser::Alignas - 8))
      | (1ULL << (ReentParser::Asm - 8))
      | (1ULL << (ReentParser::Auto - 8))
      | (1ULL << (ReentParser::Begin - 8))
      | (1ULL << (ReentParser::Bool - 8))
      | (1ULL << (ReentParser::Cfunnel - 8))
      | (1ULL << (ReentParser::Chain - 8))
      | (1ULL << (ReentParser::Char - 8))
      | (1ULL << (ReentParser::Char16 - 8))
      | (1ULL << (ReentParser::Char32 - 8))
      | (1ULL << (ReentParser::Class - 8))
      | (1ULL << (ReentParser::Clustered - 8))
      | (1ULL << (ReentParser::Common - 8))
      | (1ULL << (ReentParser::Const - 8))
      | (1ULL << (ReentParser::Constexpr - 8))
      | (1ULL << (ReentParser::Csem - 8))
      | (1ULL << (ReentParser::Cvar - 8))
      | (1ULL << (ReentParser::Decltype - 8))
      | (1ULL << (ReentParser::Depends - 8))
      | (1ULL << (ReentParser::Double - 8))
      | (1ULL << (ReentParser::End - 8))
      | (1ULL << (ReentParser::Enum - 8))
      | (1ULL << (ReentParser::Explicit - 8))
      | (1ULL << (ReentParser::Extern - 8))
      | (1ULL << (ReentParser::Float - 8))
      | (1ULL << (ReentParser::Friend - 8))
      | (1ULL << (ReentParser::Funnel - 8))
      | (1ULL << (ReentParser::Global - 8))
      | (1ULL << (ReentParser::Gpu - 8))
      | (1ULL << (ReentParser::Id - 8))
      | (1ULL << (ReentParser::In - 8)))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ReentParser::Inline - 72))
      | (1ULL << (ReentParser::Int - 72))
      | (1ULL << (ReentParser::Local - 72))
      | (1ULL << (ReentParser::Long - 72))
      | (1ULL << (ReentParser::MarkPreCondition - 72))
      | (1ULL << (ReentParser::MarkState - 72))
      | (1ULL << (ReentParser::Markupdef - 72))
      | (1ULL << (ReentParser::Mutable - 72))
      | (1ULL << (ReentParser::Namespace - 72))
      | (1ULL << (ReentParser::Operator - 72))
      | (1ULL << (ReentParser::Out - 72))
      | (1ULL << (ReentParser::Plan - 72))
      | (1ULL << (ReentParser::Plan_item_type - 72))
      | (1ULL << (ReentParser::Plan_type - 72))
      | (1ULL << (ReentParser::Reenterable - 72))
      | (1ULL << (ReentParser::Register - 72))
      | (1ULL << (ReentParser::Reset - 72))
      | (1ULL << (ReentParser::Set - 72))
      | (1ULL << (ReentParser::Short - 72))
      | (1ULL << (ReentParser::Signed - 72))
      | (1ULL << (ReentParser::Soft_transact_array - 72))
      | (1ULL << (ReentParser::Soft_transact_in - 72))
      | (1ULL << (ReentParser::Soft_transact_out - 72))
      | (1ULL << (ReentParser::Soft_transact_var - 72))
      | (1ULL << (ReentParser::Static - 72))
      | (1ULL << (ReentParser::Static_assert - 72))
      | (1ULL << (ReentParser::Struct - 72))
      | (1ULL << (ReentParser::Template - 72))
      | (1ULL << (ReentParser::Thread_local - 72)))) != 0) || ((((_la - 140) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 140)) & ((1ULL << (ReentParser::Typedef - 140))
      | (1ULL << (ReentParser::Typename_ - 140))
      | (1ULL << (ReentParser::Union - 140))
      | (1ULL << (ReentParser::Unsigned - 140))
      | (1ULL << (ReentParser::Using - 140))
      | (1ULL << (ReentParser::Vectorized - 140))
      | (1ULL << (ReentParser::Virtual - 140))
      | (1ULL << (ReentParser::Void - 140))
      | (1ULL << (ReentParser::Volatile - 140))
      | (1ULL << (ReentParser::Wchar - 140))
      | (1ULL << (ReentParser::LeftParen - 140))
      | (1ULL << (ReentParser::LeftBracket - 140))
      | (1ULL << (ReentParser::Star - 140))
      | (1ULL << (ReentParser::And - 140))
      | (1ULL << (ReentParser::Tilde - 140))
      | (1ULL << (ReentParser::AndAnd - 140))
      | (1ULL << (ReentParser::Doublecolon - 140))
      | (1ULL << (ReentParser::Semi - 140))
      | (1ULL << (ReentParser::Ellipsis - 140))
      | (1ULL << (ReentParser::Identifier - 140)))) != 0)) {
      setState(568);
      declarationseq();
    }
    setState(571);
    match(ReentParser::EOF);

    		if (gpu_block_opened)
    			throw FailedPredicateException(this, "'#pragma plan gpu end' expected");
    		if (common_block_opened)
    			throw FailedPredicateException(this, "'#pragma plan common end' expected");
    	
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyIdentifierContext ------------------------------------------------------------------

ReentParser::AnyIdentifierContext::AnyIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Id() {
  return getToken(ReentParser::Id, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::In() {
  return getToken(ReentParser::In, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Out() {
  return getToken(ReentParser::Out, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Set() {
  return getToken(ReentParser::Set, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Reset() {
  return getToken(ReentParser::Reset, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Depends() {
  return getToken(ReentParser::Depends, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Plan() {
  return getToken(ReentParser::Plan, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Common() {
  return getToken(ReentParser::Common, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Gpu() {
  return getToken(ReentParser::Gpu, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Begin() {
  return getToken(ReentParser::Begin, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::End() {
  return getToken(ReentParser::End, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Local() {
  return getToken(ReentParser::Local, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Global() {
  return getToken(ReentParser::Global, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::MarkState() {
  return getToken(ReentParser::MarkState, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::MarkPreCondition() {
  return getToken(ReentParser::MarkPreCondition, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Vectorized() {
  return getToken(ReentParser::Vectorized, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Clustered() {
  return getToken(ReentParser::Clustered, 0);
}

tree::TerminalNode* ReentParser::AnyIdentifierContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}


size_t ReentParser::AnyIdentifierContext::getRuleIndex() const {
  return ReentParser::RuleAnyIdentifier;
}

void ReentParser::AnyIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyIdentifier(this);
}

void ReentParser::AnyIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyIdentifier(this);
}

ReentParser::AnyIdentifierContext* ReentParser::anyIdentifier() {
  AnyIdentifierContext *_localctx = _tracker.createInstance<AnyIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 2, ReentParser::RuleAnyIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(574);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::Begin)
      | (1ULL << ReentParser::Clustered)
      | (1ULL << ReentParser::Common)
      | (1ULL << ReentParser::Depends)
      | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
      | (1ULL << (ReentParser::Gpu - 64))
      | (1ULL << (ReentParser::Id - 64))
      | (1ULL << (ReentParser::In - 64))
      | (1ULL << (ReentParser::Local - 64))
      | (1ULL << (ReentParser::MarkPreCondition - 64))
      | (1ULL << (ReentParser::MarkState - 64))
      | (1ULL << (ReentParser::Out - 64))
      | (1ULL << (ReentParser::Plan - 64))
      | (1ULL << (ReentParser::Reset - 64))
      | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

    || _la == ReentParser::Identifier)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

ReentParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::LiteralContext *> ReentParser::PrimaryExpressionContext::literal() {
  return getRuleContexts<ReentParser::LiteralContext>();
}

ReentParser::LiteralContext* ReentParser::PrimaryExpressionContext::literal(size_t i) {
  return getRuleContext<ReentParser::LiteralContext>(i);
}

tree::TerminalNode* ReentParser::PrimaryExpressionContext::This() {
  return getToken(ReentParser::This, 0);
}

tree::TerminalNode* ReentParser::PrimaryExpressionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::PrimaryExpressionContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::PrimaryExpressionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::Reent_funs_idContext* ReentParser::PrimaryExpressionContext::reent_funs_id() {
  return getRuleContext<ReentParser::Reent_funs_idContext>(0);
}

ReentParser::Chain_funs_idContext* ReentParser::PrimaryExpressionContext::chain_funs_id() {
  return getRuleContext<ReentParser::Chain_funs_idContext>(0);
}

ReentParser::IdExpressionContext* ReentParser::PrimaryExpressionContext::idExpression() {
  return getRuleContext<ReentParser::IdExpressionContext>(0);
}

ReentParser::LambdaExpressionContext* ReentParser::PrimaryExpressionContext::lambdaExpression() {
  return getRuleContext<ReentParser::LambdaExpressionContext>(0);
}


size_t ReentParser::PrimaryExpressionContext::getRuleIndex() const {
  return ReentParser::RulePrimaryExpression;
}

void ReentParser::PrimaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpression(this);
}

void ReentParser::PrimaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpression(this);
}

ReentParser::PrimaryExpressionContext* ReentParser::primaryExpression() {
  PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 4, ReentParser::RulePrimaryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(590);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(577); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(576);
                literal();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(579); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(581);
      match(ReentParser::This);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(582);
      match(ReentParser::LeftParen);
      setState(583);
      expression();
      setState(584);
      match(ReentParser::RightParen);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(586);
      reent_funs_id();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(587);
      chain_funs_id();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(588);
      idExpression();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(589);
      lambdaExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdExpressionContext ------------------------------------------------------------------

ReentParser::IdExpressionContext::IdExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::QualifiedIdContext* ReentParser::IdExpressionContext::qualifiedId() {
  return getRuleContext<ReentParser::QualifiedIdContext>(0);
}

ReentParser::UnqualifiedIdContext* ReentParser::IdExpressionContext::unqualifiedId() {
  return getRuleContext<ReentParser::UnqualifiedIdContext>(0);
}


size_t ReentParser::IdExpressionContext::getRuleIndex() const {
  return ReentParser::RuleIdExpression;
}

void ReentParser::IdExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdExpression(this);
}

void ReentParser::IdExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdExpression(this);
}

ReentParser::IdExpressionContext* ReentParser::idExpression() {
  IdExpressionContext *_localctx = _tracker.createInstance<IdExpressionContext>(_ctx, getState());
  enterRule(_localctx, 6, ReentParser::RuleIdExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(594);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(592);
      qualifiedId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(593);
      unqualifiedId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_funs_idContext ------------------------------------------------------------------

ReentParser::Reent_funs_idContext::Reent_funs_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_first() {
  return getToken(ReentParser::Plan_first, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_last() {
  return getToken(ReentParser::Plan_last, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_stop() {
  return getToken(ReentParser::Plan_stop, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Clear_plan() {
  return getToken(ReentParser::Clear_plan, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_get_first() {
  return getToken(ReentParser::Plan_get_first, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_get_last() {
  return getToken(ReentParser::Plan_get_last, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_group_first() {
  return getToken(ReentParser::Plan_group_first, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_group_last() {
  return getToken(ReentParser::Plan_group_last, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_group_parallelize() {
  return getToken(ReentParser::Plan_group_parallelize, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_group_vectorize() {
  return getToken(ReentParser::Plan_group_vectorize, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_group_atomize() {
  return getToken(ReentParser::Plan_group_atomize, 0);
}

tree::TerminalNode* ReentParser::Reent_funs_idContext::Plan_group_soft_atomize() {
  return getToken(ReentParser::Plan_group_soft_atomize, 0);
}


size_t ReentParser::Reent_funs_idContext::getRuleIndex() const {
  return ReentParser::RuleReent_funs_id;
}

void ReentParser::Reent_funs_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_funs_id(this);
}

void ReentParser::Reent_funs_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_funs_id(this);
}

ReentParser::Reent_funs_idContext* ReentParser::reent_funs_id() {
  Reent_funs_idContext *_localctx = _tracker.createInstance<Reent_funs_idContext>(_ctx, getState());
  enterRule(_localctx, 8, ReentParser::RuleReent_funs_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(596);

    if (!((in_reenterable || in_chain))) throw FailedPredicateException(this, "(in_reenterable || in_chain)");
    setState(597);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Clear_plan || ((((_la - 91) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 91)) & ((1ULL << (ReentParser::Plan_first - 91))
      | (1ULL << (ReentParser::Plan_get_first - 91))
      | (1ULL << (ReentParser::Plan_get_last - 91))
      | (1ULL << (ReentParser::Plan_group_atomize - 91))
      | (1ULL << (ReentParser::Plan_group_first - 91))
      | (1ULL << (ReentParser::Plan_group_last - 91))
      | (1ULL << (ReentParser::Plan_group_parallelize - 91))
      | (1ULL << (ReentParser::Plan_group_soft_atomize - 91))
      | (1ULL << (ReentParser::Plan_group_vectorize - 91))
      | (1ULL << (ReentParser::Plan_last - 91))
      | (1ULL << (ReentParser::Plan_stop - 91)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chain_funs_idContext ------------------------------------------------------------------

ReentParser::Chain_funs_idContext::Chain_funs_idContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Chain_funs_idContext::Throw_first() {
  return getToken(ReentParser::Throw_first, 0);
}

tree::TerminalNode* ReentParser::Chain_funs_idContext::Throw_last() {
  return getToken(ReentParser::Throw_last, 0);
}


size_t ReentParser::Chain_funs_idContext::getRuleIndex() const {
  return ReentParser::RuleChain_funs_id;
}

void ReentParser::Chain_funs_idContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChain_funs_id(this);
}

void ReentParser::Chain_funs_idContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChain_funs_id(this);
}

ReentParser::Chain_funs_idContext* ReentParser::chain_funs_id() {
  Chain_funs_idContext *_localctx = _tracker.createInstance<Chain_funs_idContext>(_ctx, getState());
  enterRule(_localctx, 10, ReentParser::RuleChain_funs_id);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(599);

    if (!(in_chain)) throw FailedPredicateException(this, "in_chain");
    setState(600);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Throw_first

    || _la == ReentParser::Throw_last)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnqualifiedIdContext ------------------------------------------------------------------

ReentParser::UnqualifiedIdContext::UnqualifiedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TemplateIdContext* ReentParser::UnqualifiedIdContext::templateId() {
  return getRuleContext<ReentParser::TemplateIdContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::UnqualifiedIdContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::OperatorFunctionIdContext* ReentParser::UnqualifiedIdContext::operatorFunctionId() {
  return getRuleContext<ReentParser::OperatorFunctionIdContext>(0);
}

ReentParser::ConversionFunctionIdContext* ReentParser::UnqualifiedIdContext::conversionFunctionId() {
  return getRuleContext<ReentParser::ConversionFunctionIdContext>(0);
}

ReentParser::LiteralOperatorIdContext* ReentParser::UnqualifiedIdContext::literalOperatorId() {
  return getRuleContext<ReentParser::LiteralOperatorIdContext>(0);
}

tree::TerminalNode* ReentParser::UnqualifiedIdContext::Tilde() {
  return getToken(ReentParser::Tilde, 0);
}

ReentParser::ClassNameContext* ReentParser::UnqualifiedIdContext::className() {
  return getRuleContext<ReentParser::ClassNameContext>(0);
}

ReentParser::DecltypeSpecifierContext* ReentParser::UnqualifiedIdContext::decltypeSpecifier() {
  return getRuleContext<ReentParser::DecltypeSpecifierContext>(0);
}


size_t ReentParser::UnqualifiedIdContext::getRuleIndex() const {
  return ReentParser::RuleUnqualifiedId;
}

void ReentParser::UnqualifiedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnqualifiedId(this);
}

void ReentParser::UnqualifiedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnqualifiedId(this);
}

ReentParser::UnqualifiedIdContext* ReentParser::unqualifiedId() {
  UnqualifiedIdContext *_localctx = _tracker.createInstance<UnqualifiedIdContext>(_ctx, getState());
  enterRule(_localctx, 12, ReentParser::RuleUnqualifiedId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(612);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(602);
      templateId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(603);
      anyIdentifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(604);
      operatorFunctionId();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(605);
      conversionFunctionId();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(606);
      literalOperatorId();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(607);
      match(ReentParser::Tilde);
      setState(610);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ReentParser::Begin:
        case ReentParser::Clustered:
        case ReentParser::Common:
        case ReentParser::Depends:
        case ReentParser::End:
        case ReentParser::Global:
        case ReentParser::Gpu:
        case ReentParser::Id:
        case ReentParser::In:
        case ReentParser::Local:
        case ReentParser::MarkPreCondition:
        case ReentParser::MarkState:
        case ReentParser::Out:
        case ReentParser::Plan:
        case ReentParser::Reset:
        case ReentParser::Set:
        case ReentParser::Vectorized:
        case ReentParser::Identifier: {
          setState(608);
          className();
          break;
        }

        case ReentParser::Decltype: {
          setState(609);
          decltypeSpecifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdContext ------------------------------------------------------------------

ReentParser::QualifiedIdContext::QualifiedIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::NestedNameSpecifierContext* ReentParser::QualifiedIdContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

ReentParser::UnqualifiedIdContext* ReentParser::QualifiedIdContext::unqualifiedId() {
  return getRuleContext<ReentParser::UnqualifiedIdContext>(0);
}

tree::TerminalNode* ReentParser::QualifiedIdContext::Template() {
  return getToken(ReentParser::Template, 0);
}


size_t ReentParser::QualifiedIdContext::getRuleIndex() const {
  return ReentParser::RuleQualifiedId;
}

void ReentParser::QualifiedIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedId(this);
}

void ReentParser::QualifiedIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedId(this);
}

ReentParser::QualifiedIdContext* ReentParser::qualifiedId() {
  QualifiedIdContext *_localctx = _tracker.createInstance<QualifiedIdContext>(_ctx, getState());
  enterRule(_localctx, 14, ReentParser::RuleQualifiedId);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    nestedNameSpecifier(0);
    setState(616);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Template) {
      setState(615);
      match(ReentParser::Template);
    }
    setState(618);
    unqualifiedId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NestedNameSpecifierContext ------------------------------------------------------------------

ReentParser::NestedNameSpecifierContext::NestedNameSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NestedNameSpecifierContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

ReentParser::TheTypeNameContext* ReentParser::NestedNameSpecifierContext::theTypeName() {
  return getRuleContext<ReentParser::TheTypeNameContext>(0);
}

ReentParser::NamespaceNameContext* ReentParser::NestedNameSpecifierContext::namespaceName() {
  return getRuleContext<ReentParser::NamespaceNameContext>(0);
}

ReentParser::DecltypeSpecifierContext* ReentParser::NestedNameSpecifierContext::decltypeSpecifier() {
  return getRuleContext<ReentParser::DecltypeSpecifierContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::NestedNameSpecifierContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::NestedNameSpecifierContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::SimpleTemplateIdContext* ReentParser::NestedNameSpecifierContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

tree::TerminalNode* ReentParser::NestedNameSpecifierContext::Template() {
  return getToken(ReentParser::Template, 0);
}


size_t ReentParser::NestedNameSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleNestedNameSpecifier;
}

void ReentParser::NestedNameSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNestedNameSpecifier(this);
}

void ReentParser::NestedNameSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNestedNameSpecifier(this);
}


ReentParser::NestedNameSpecifierContext* ReentParser::nestedNameSpecifier() {
   return nestedNameSpecifier(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::nestedNameSpecifier(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ReentParser::NestedNameSpecifierContext *_localctx = _tracker.createInstance<NestedNameSpecifierContext>(_ctx, parentState);
  ReentParser::NestedNameSpecifierContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 16;
  enterRecursionRule(_localctx, 16, ReentParser::RuleNestedNameSpecifier, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(624);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      setState(621);
      theTypeName();
      break;
    }

    case 2: {
      setState(622);
      namespaceName();
      break;
    }

    case 3: {
      setState(623);
      decltypeSpecifier();
      break;
    }

    default:
      break;
    }
    setState(626);
    match(ReentParser::Doublecolon);
    _ctx->stop = _input->LT(-1);
    setState(640);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<NestedNameSpecifierContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleNestedNameSpecifier);
        setState(628);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(634);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
        case 1: {
          setState(629);
          anyIdentifier();
          break;
        }

        case 2: {
          setState(631);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ReentParser::Template) {
            setState(630);
            match(ReentParser::Template);
          }
          setState(633);
          simpleTemplateId();
          break;
        }

        default:
          break;
        }
        setState(636);
        match(ReentParser::Doublecolon); 
      }
      setState(642);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- LambdaExpressionContext ------------------------------------------------------------------

ReentParser::LambdaExpressionContext::LambdaExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::LambdaIntroducerContext* ReentParser::LambdaExpressionContext::lambdaIntroducer() {
  return getRuleContext<ReentParser::LambdaIntroducerContext>(0);
}

ReentParser::CompoundStatementContext* ReentParser::LambdaExpressionContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}

ReentParser::LambdaDeclaratorContext* ReentParser::LambdaExpressionContext::lambdaDeclarator() {
  return getRuleContext<ReentParser::LambdaDeclaratorContext>(0);
}


size_t ReentParser::LambdaExpressionContext::getRuleIndex() const {
  return ReentParser::RuleLambdaExpression;
}

void ReentParser::LambdaExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaExpression(this);
}

void ReentParser::LambdaExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaExpression(this);
}

ReentParser::LambdaExpressionContext* ReentParser::lambdaExpression() {
  LambdaExpressionContext *_localctx = _tracker.createInstance<LambdaExpressionContext>(_ctx, getState());
  enterRule(_localctx, 18, ReentParser::RuleLambdaExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(643);
    lambdaIntroducer();
    setState(645);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::LeftParen) {
      setState(644);
      lambdaDeclarator();
    }
    setState(647);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaIntroducerContext ------------------------------------------------------------------

ReentParser::LambdaIntroducerContext::LambdaIntroducerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::LambdaIntroducerContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::LambdaIntroducerContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::LambdaCaptureContext* ReentParser::LambdaIntroducerContext::lambdaCapture() {
  return getRuleContext<ReentParser::LambdaCaptureContext>(0);
}


size_t ReentParser::LambdaIntroducerContext::getRuleIndex() const {
  return ReentParser::RuleLambdaIntroducer;
}

void ReentParser::LambdaIntroducerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaIntroducer(this);
}

void ReentParser::LambdaIntroducerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaIntroducer(this);
}

ReentParser::LambdaIntroducerContext* ReentParser::lambdaIntroducer() {
  LambdaIntroducerContext *_localctx = _tracker.createInstance<LambdaIntroducerContext>(_ctx, getState());
  enterRule(_localctx, 20, ReentParser::RuleLambdaIntroducer);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(649);
    match(ReentParser::LeftBracket);
    setState(651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 19) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 19)) & ((1ULL << (ReentParser::Begin - 19))
      | (1ULL << (ReentParser::Clustered - 19))
      | (1ULL << (ReentParser::Common - 19))
      | (1ULL << (ReentParser::Depends - 19))
      | (1ULL << (ReentParser::End - 19))
      | (1ULL << (ReentParser::Global - 19))
      | (1ULL << (ReentParser::Gpu - 19))
      | (1ULL << (ReentParser::Id - 19))
      | (1ULL << (ReentParser::In - 19))
      | (1ULL << (ReentParser::Local - 19))
      | (1ULL << (ReentParser::MarkPreCondition - 19))
      | (1ULL << (ReentParser::MarkState - 19)))) != 0) || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (ReentParser::Out - 85))
      | (1ULL << (ReentParser::Plan - 85))
      | (1ULL << (ReentParser::Reset - 85))
      | (1ULL << (ReentParser::Set - 85))
      | (1ULL << (ReentParser::This - 85))
      | (1ULL << (ReentParser::Vectorized - 85)))) != 0) || ((((_la - 168) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 168)) & ((1ULL << (ReentParser::And - 168))
      | (1ULL << (ReentParser::Assign - 168))
      | (1ULL << (ReentParser::Identifier - 168)))) != 0)) {
      setState(650);
      lambdaCapture();
    }
    setState(653);
    match(ReentParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaCaptureContext ------------------------------------------------------------------

ReentParser::LambdaCaptureContext::LambdaCaptureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::CaptureListContext* ReentParser::LambdaCaptureContext::captureList() {
  return getRuleContext<ReentParser::CaptureListContext>(0);
}

ReentParser::CaptureDefaultContext* ReentParser::LambdaCaptureContext::captureDefault() {
  return getRuleContext<ReentParser::CaptureDefaultContext>(0);
}

tree::TerminalNode* ReentParser::LambdaCaptureContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}


size_t ReentParser::LambdaCaptureContext::getRuleIndex() const {
  return ReentParser::RuleLambdaCapture;
}

void ReentParser::LambdaCaptureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaCapture(this);
}

void ReentParser::LambdaCaptureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaCapture(this);
}

ReentParser::LambdaCaptureContext* ReentParser::lambdaCapture() {
  LambdaCaptureContext *_localctx = _tracker.createInstance<LambdaCaptureContext>(_ctx, getState());
  enterRule(_localctx, 22, ReentParser::RuleLambdaCapture);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(661);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(655);
      captureList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(656);
      captureDefault();
      setState(659);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Comma) {
        setState(657);
        match(ReentParser::Comma);
        setState(658);
        captureList();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaptureDefaultContext ------------------------------------------------------------------

ReentParser::CaptureDefaultContext::CaptureDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::CaptureDefaultContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::CaptureDefaultContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}


size_t ReentParser::CaptureDefaultContext::getRuleIndex() const {
  return ReentParser::RuleCaptureDefault;
}

void ReentParser::CaptureDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaptureDefault(this);
}

void ReentParser::CaptureDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaptureDefault(this);
}

ReentParser::CaptureDefaultContext* ReentParser::captureDefault() {
  CaptureDefaultContext *_localctx = _tracker.createInstance<CaptureDefaultContext>(_ctx, getState());
  enterRule(_localctx, 24, ReentParser::RuleCaptureDefault);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(663);
    _la = _input->LA(1);
    if (!(_la == ReentParser::And

    || _la == ReentParser::Assign)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaptureListContext ------------------------------------------------------------------

ReentParser::CaptureListContext::CaptureListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::CaptureContext *> ReentParser::CaptureListContext::capture() {
  return getRuleContexts<ReentParser::CaptureContext>();
}

ReentParser::CaptureContext* ReentParser::CaptureListContext::capture(size_t i) {
  return getRuleContext<ReentParser::CaptureContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::CaptureListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::CaptureListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}

tree::TerminalNode* ReentParser::CaptureListContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}


size_t ReentParser::CaptureListContext::getRuleIndex() const {
  return ReentParser::RuleCaptureList;
}

void ReentParser::CaptureListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaptureList(this);
}

void ReentParser::CaptureListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaptureList(this);
}

ReentParser::CaptureListContext* ReentParser::captureList() {
  CaptureListContext *_localctx = _tracker.createInstance<CaptureListContext>(_ctx, getState());
  enterRule(_localctx, 26, ReentParser::RuleCaptureList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(665);
    capture();
    setState(670);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(666);
      match(ReentParser::Comma);
      setState(667);
      capture();
      setState(672);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(674);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(673);
      match(ReentParser::Ellipsis);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaptureContext ------------------------------------------------------------------

ReentParser::CaptureContext::CaptureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::SimpleCaptureContext* ReentParser::CaptureContext::simpleCapture() {
  return getRuleContext<ReentParser::SimpleCaptureContext>(0);
}

ReentParser::InitcaptureContext* ReentParser::CaptureContext::initcapture() {
  return getRuleContext<ReentParser::InitcaptureContext>(0);
}


size_t ReentParser::CaptureContext::getRuleIndex() const {
  return ReentParser::RuleCapture;
}

void ReentParser::CaptureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCapture(this);
}

void ReentParser::CaptureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCapture(this);
}

ReentParser::CaptureContext* ReentParser::capture() {
  CaptureContext *_localctx = _tracker.createInstance<CaptureContext>(_ctx, getState());
  enterRule(_localctx, 28, ReentParser::RuleCapture);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(678);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(676);
      simpleCapture();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(677);
      initcapture();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleCaptureContext ------------------------------------------------------------------

ReentParser::SimpleCaptureContext::SimpleCaptureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::SimpleCaptureContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::SimpleCaptureContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::SimpleCaptureContext::This() {
  return getToken(ReentParser::This, 0);
}


size_t ReentParser::SimpleCaptureContext::getRuleIndex() const {
  return ReentParser::RuleSimpleCapture;
}

void ReentParser::SimpleCaptureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleCapture(this);
}

void ReentParser::SimpleCaptureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleCapture(this);
}

ReentParser::SimpleCaptureContext* ReentParser::simpleCapture() {
  SimpleCaptureContext *_localctx = _tracker.createInstance<SimpleCaptureContext>(_ctx, getState());
  enterRule(_localctx, 30, ReentParser::RuleSimpleCapture);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(685);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::And:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(681);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::And) {
          setState(680);
          match(ReentParser::And);
        }
        setState(683);
        anyIdentifier();
        break;
      }

      case ReentParser::This: {
        enterOuterAlt(_localctx, 2);
        setState(684);
        match(ReentParser::This);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitcaptureContext ------------------------------------------------------------------

ReentParser::InitcaptureContext::InitcaptureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::InitcaptureContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::InitializerContext* ReentParser::InitcaptureContext::initializer() {
  return getRuleContext<ReentParser::InitializerContext>(0);
}

tree::TerminalNode* ReentParser::InitcaptureContext::And() {
  return getToken(ReentParser::And, 0);
}


size_t ReentParser::InitcaptureContext::getRuleIndex() const {
  return ReentParser::RuleInitcapture;
}

void ReentParser::InitcaptureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitcapture(this);
}

void ReentParser::InitcaptureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitcapture(this);
}

ReentParser::InitcaptureContext* ReentParser::initcapture() {
  InitcaptureContext *_localctx = _tracker.createInstance<InitcaptureContext>(_ctx, getState());
  enterRule(_localctx, 32, ReentParser::RuleInitcapture);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(688);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::And) {
      setState(687);
      match(ReentParser::And);
    }
    setState(690);
    anyIdentifier();
    setState(691);
    initializer();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LambdaDeclaratorContext ------------------------------------------------------------------

ReentParser::LambdaDeclaratorContext::LambdaDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::LambdaDeclaratorContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::LambdaDeclaratorContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::ParameterDeclarationClauseContext* ReentParser::LambdaDeclaratorContext::parameterDeclarationClause() {
  return getRuleContext<ReentParser::ParameterDeclarationClauseContext>(0);
}

tree::TerminalNode* ReentParser::LambdaDeclaratorContext::Mutable() {
  return getToken(ReentParser::Mutable, 0);
}

ReentParser::ExceptionSpecificationContext* ReentParser::LambdaDeclaratorContext::exceptionSpecification() {
  return getRuleContext<ReentParser::ExceptionSpecificationContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::LambdaDeclaratorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::TrailingReturnTypeContext* ReentParser::LambdaDeclaratorContext::trailingReturnType() {
  return getRuleContext<ReentParser::TrailingReturnTypeContext>(0);
}


size_t ReentParser::LambdaDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleLambdaDeclarator;
}

void ReentParser::LambdaDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLambdaDeclarator(this);
}

void ReentParser::LambdaDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLambdaDeclarator(this);
}

ReentParser::LambdaDeclaratorContext* ReentParser::lambdaDeclarator() {
  LambdaDeclaratorContext *_localctx = _tracker.createInstance<LambdaDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 34, ReentParser::RuleLambdaDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    match(ReentParser::LeftParen);
    setState(695);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 15) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 15)) & ((1ULL << (ReentParser::Alignas - 15))
      | (1ULL << (ReentParser::Auto - 15))
      | (1ULL << (ReentParser::Begin - 15))
      | (1ULL << (ReentParser::Bool - 15))
      | (1ULL << (ReentParser::Cfunnel - 15))
      | (1ULL << (ReentParser::Char - 15))
      | (1ULL << (ReentParser::Char16 - 15))
      | (1ULL << (ReentParser::Char32 - 15))
      | (1ULL << (ReentParser::Class - 15))
      | (1ULL << (ReentParser::Clustered - 15))
      | (1ULL << (ReentParser::Common - 15))
      | (1ULL << (ReentParser::Const - 15))
      | (1ULL << (ReentParser::Constexpr - 15))
      | (1ULL << (ReentParser::Csem - 15))
      | (1ULL << (ReentParser::Cvar - 15))
      | (1ULL << (ReentParser::Decltype - 15))
      | (1ULL << (ReentParser::Depends - 15))
      | (1ULL << (ReentParser::Double - 15))
      | (1ULL << (ReentParser::End - 15))
      | (1ULL << (ReentParser::Enum - 15))
      | (1ULL << (ReentParser::Explicit - 15))
      | (1ULL << (ReentParser::Extern - 15))
      | (1ULL << (ReentParser::Float - 15))
      | (1ULL << (ReentParser::Friend - 15))
      | (1ULL << (ReentParser::Funnel - 15))
      | (1ULL << (ReentParser::Global - 15))
      | (1ULL << (ReentParser::Gpu - 15))
      | (1ULL << (ReentParser::Id - 15))
      | (1ULL << (ReentParser::In - 15))
      | (1ULL << (ReentParser::Inline - 15))
      | (1ULL << (ReentParser::Int - 15))
      | (1ULL << (ReentParser::Local - 15))
      | (1ULL << (ReentParser::Long - 15))
      | (1ULL << (ReentParser::MarkPreCondition - 15))
      | (1ULL << (ReentParser::MarkState - 15))
      | (1ULL << (ReentParser::Markupdef - 15)))) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (ReentParser::Mutable - 79))
      | (1ULL << (ReentParser::Out - 79))
      | (1ULL << (ReentParser::Plan - 79))
      | (1ULL << (ReentParser::Plan_item_type - 79))
      | (1ULL << (ReentParser::Plan_type - 79))
      | (1ULL << (ReentParser::Register - 79))
      | (1ULL << (ReentParser::Reset - 79))
      | (1ULL << (ReentParser::Set - 79))
      | (1ULL << (ReentParser::Short - 79))
      | (1ULL << (ReentParser::Signed - 79))
      | (1ULL << (ReentParser::Soft_transact_array - 79))
      | (1ULL << (ReentParser::Soft_transact_in - 79))
      | (1ULL << (ReentParser::Soft_transact_out - 79))
      | (1ULL << (ReentParser::Soft_transact_var - 79))
      | (1ULL << (ReentParser::Static - 79))
      | (1ULL << (ReentParser::Struct - 79))
      | (1ULL << (ReentParser::Thread_local - 79))
      | (1ULL << (ReentParser::Typedef - 79))
      | (1ULL << (ReentParser::Typename_ - 79)))) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & ((1ULL << (ReentParser::Union - 143))
      | (1ULL << (ReentParser::Unsigned - 143))
      | (1ULL << (ReentParser::Vectorized - 143))
      | (1ULL << (ReentParser::Virtual - 143))
      | (1ULL << (ReentParser::Void - 143))
      | (1ULL << (ReentParser::Volatile - 143))
      | (1ULL << (ReentParser::Wchar - 143))
      | (1ULL << (ReentParser::LeftBracket - 143))
      | (1ULL << (ReentParser::Doublecolon - 143))
      | (1ULL << (ReentParser::Identifier - 143)))) != 0)) {
      setState(694);
      parameterDeclarationClause();
    }
    setState(697);
    match(ReentParser::RightParen);
    setState(699);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Mutable) {
      setState(698);
      match(ReentParser::Mutable);
    }
    setState(702);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Noexcept

    || _la == ReentParser::Throw) {
      setState(701);
      exceptionSpecification();
    }
    setState(705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(704);
      attributeSpecifierSeq();
    }
    setState(708);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Arrow) {
      setState(707);
      trailingReturnType();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PostfixExpressionContext ------------------------------------------------------------------

ReentParser::PostfixExpressionContext::PostfixExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::PrimaryExpressionContext* ReentParser::PostfixExpressionContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::PostfixExpressionContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

ReentParser::TypeNameSpecifierContext* ReentParser::PostfixExpressionContext::typeNameSpecifier() {
  return getRuleContext<ReentParser::TypeNameSpecifierContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::PostfixExpressionContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}

ReentParser::TheTypeIdContext* ReentParser::PostfixExpressionContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Less() {
  return getToken(ReentParser::Less, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Greater() {
  return getToken(ReentParser::Greater, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::PostfixExpressionContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Dynamic_cast() {
  return getToken(ReentParser::Dynamic_cast, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Static_cast() {
  return getToken(ReentParser::Static_cast, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Reinterpret_cast() {
  return getToken(ReentParser::Reinterpret_cast, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Const_cast() {
  return getToken(ReentParser::Const_cast, 0);
}

ReentParser::TypeIdOfTheTypeIdContext* ReentParser::PostfixExpressionContext::typeIdOfTheTypeId() {
  return getRuleContext<ReentParser::TypeIdOfTheTypeIdContext>(0);
}

ReentParser::PostfixExpressionContext* ReentParser::PostfixExpressionContext::postfixExpression() {
  return getRuleContext<ReentParser::PostfixExpressionContext>(0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::ExpressionListContext* ReentParser::PostfixExpressionContext::expressionList() {
  return getRuleContext<ReentParser::ExpressionListContext>(0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Dot() {
  return getToken(ReentParser::Dot, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Arrow() {
  return getToken(ReentParser::Arrow, 0);
}

ReentParser::PseudoDestructorNameContext* ReentParser::PostfixExpressionContext::pseudoDestructorName() {
  return getRuleContext<ReentParser::PseudoDestructorNameContext>(0);
}

ReentParser::IdExpressionContext* ReentParser::PostfixExpressionContext::idExpression() {
  return getRuleContext<ReentParser::IdExpressionContext>(0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::Template() {
  return getToken(ReentParser::Template, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::PlusPlus() {
  return getToken(ReentParser::PlusPlus, 0);
}

tree::TerminalNode* ReentParser::PostfixExpressionContext::MinusMinus() {
  return getToken(ReentParser::MinusMinus, 0);
}


size_t ReentParser::PostfixExpressionContext::getRuleIndex() const {
  return ReentParser::RulePostfixExpression;
}

void ReentParser::PostfixExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPostfixExpression(this);
}

void ReentParser::PostfixExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPostfixExpression(this);
}


ReentParser::PostfixExpressionContext* ReentParser::postfixExpression() {
   return postfixExpression(0);
}

ReentParser::PostfixExpressionContext* ReentParser::postfixExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ReentParser::PostfixExpressionContext *_localctx = _tracker.createInstance<PostfixExpressionContext>(_ctx, parentState);
  ReentParser::PostfixExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 36;
  enterRecursionRule(_localctx, 36, ReentParser::RulePostfixExpression, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(735);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      setState(711);
      primaryExpression();
      break;
    }

    case 2: {
      setState(714);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ReentParser::Auto:
        case ReentParser::Begin:
        case ReentParser::Bool:
        case ReentParser::Char:
        case ReentParser::Char16:
        case ReentParser::Char32:
        case ReentParser::Clustered:
        case ReentParser::Common:
        case ReentParser::Decltype:
        case ReentParser::Depends:
        case ReentParser::Double:
        case ReentParser::End:
        case ReentParser::Float:
        case ReentParser::Global:
        case ReentParser::Gpu:
        case ReentParser::Id:
        case ReentParser::In:
        case ReentParser::Int:
        case ReentParser::Local:
        case ReentParser::Long:
        case ReentParser::MarkPreCondition:
        case ReentParser::MarkState:
        case ReentParser::Out:
        case ReentParser::Plan:
        case ReentParser::Reset:
        case ReentParser::Set:
        case ReentParser::Short:
        case ReentParser::Signed:
        case ReentParser::Unsigned:
        case ReentParser::Vectorized:
        case ReentParser::Void:
        case ReentParser::Wchar:
        case ReentParser::Doublecolon:
        case ReentParser::Identifier: {
          setState(712);
          simpleTypeSpecifier();
          break;
        }

        case ReentParser::Typename_: {
          setState(713);
          typeNameSpecifier();
          break;
        }

      default:
        throw NoViableAltException(this);
      }

      setState(716);
      bracedInitList();
      break;
    }

    case 3: {
      setState(718);
      theTypeId();
      break;
    }

    case 4: {
      setState(719);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Const_cast

      || _la == ReentParser::Dynamic_cast || _la == ReentParser::Reinterpret_cast

      || _la == ReentParser::Static_cast)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(720);
      match(ReentParser::Less);
      setState(721);
      theTypeId();
      setState(722);
      match(ReentParser::Greater);
      setState(723);
      match(ReentParser::LeftParen);
      setState(724);
      expression();
      setState(725);
      match(ReentParser::RightParen);
      break;
    }

    case 5: {
      setState(727);
      typeIdOfTheTypeId();
      setState(728);
      match(ReentParser::LeftParen);
      setState(731);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
      case 1: {
        setState(729);
        expression();
        break;
      }

      case 2: {
        setState(730);
        theTypeId();
        break;
      }

      default:
        break;
      }
      setState(733);
      match(ReentParser::RightParen);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(766);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(764);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<PostfixExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfixExpression);
          setState(737);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(738);
          match(ReentParser::LeftBracket);
          setState(741);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
          case 1: {
            setState(739);
            expression();
            break;
          }

          case 2: {
            setState(740);
            bracedInitList();
            break;
          }

          default:
            break;
          }
          setState(743);
          match(ReentParser::RightBracket);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<PostfixExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfixExpression);
          setState(745);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(746);
          match(ReentParser::LeftParen);
          setState(748);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
          case 1: {
            setState(747);
            expressionList();
            break;
          }

          default:
            break;
          }
          setState(750);
          match(ReentParser::RightParen);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<PostfixExpressionContext>(parentContext, parentState);
          _localctx->planned = previousContext;
          pushNewRecursionContext(_localctx, startState, RulePostfixExpression);
          setState(751);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(752);
          _la = _input->LA(1);
          if (!(_la == ReentParser::Arrow

          || _la == ReentParser::Dot)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(760);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
          case 1: {
            setState(754);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == ReentParser::Template) {
              setState(753);
              match(ReentParser::Template);
            }
            setState(756);
            dynamic_cast<PostfixExpressionContext *>(_localctx)->ident = idExpression();

                      			if ((dynamic_cast<PostfixExpressionContext *>(_localctx)->planned != nullptr ? _input->getText(dynamic_cast<PostfixExpressionContext *>(_localctx)->planned->start, dynamic_cast<PostfixExpressionContext *>(_localctx)->planned->stop) : nullptr) == "__planned__")
                      				if (!in_chain && !in_reenterable)
                      					throw FailedPredicateException(this, "__planned__[.|->]Id not in Chain/Reenterable Procedure");
                      				else if (!_in_gpu_local)
                      					throw FailedPredicateException(this, "__planned__[.|->]Id not inside _local(...) clause in current Chain/Reenterable header");
                      				else
                      					_reent_planned_refs.insert((dynamic_cast<PostfixExpressionContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<PostfixExpressionContext *>(_localctx)->ident->start, dynamic_cast<PostfixExpressionContext *>(_localctx)->ident->stop) : nullptr));
                      		
            break;
          }

          case 2: {
            setState(759);
            pseudoDestructorName();
            break;
          }

          default:
            break;
          }
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<PostfixExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePostfixExpression);
          setState(762);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(763);
          _la = _input->LA(1);
          if (!(_la == ReentParser::PlusPlus

          || _la == ReentParser::MinusMinus)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(768);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- TypeIdOfTheTypeIdContext ------------------------------------------------------------------

ReentParser::TypeIdOfTheTypeIdContext::TypeIdOfTheTypeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TypeIdOfTheTypeIdContext::Typeid_() {
  return getToken(ReentParser::Typeid_, 0);
}


size_t ReentParser::TypeIdOfTheTypeIdContext::getRuleIndex() const {
  return ReentParser::RuleTypeIdOfTheTypeId;
}

void ReentParser::TypeIdOfTheTypeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeIdOfTheTypeId(this);
}

void ReentParser::TypeIdOfTheTypeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeIdOfTheTypeId(this);
}

ReentParser::TypeIdOfTheTypeIdContext* ReentParser::typeIdOfTheTypeId() {
  TypeIdOfTheTypeIdContext *_localctx = _tracker.createInstance<TypeIdOfTheTypeIdContext>(_ctx, getState());
  enterRule(_localctx, 38, ReentParser::RuleTypeIdOfTheTypeId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(769);
    match(ReentParser::Typeid_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionListContext ------------------------------------------------------------------

ReentParser::ExpressionListContext::ExpressionListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::InitializerListContext* ReentParser::ExpressionListContext::initializerList() {
  return getRuleContext<ReentParser::InitializerListContext>(0);
}


size_t ReentParser::ExpressionListContext::getRuleIndex() const {
  return ReentParser::RuleExpressionList;
}

void ReentParser::ExpressionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionList(this);
}

void ReentParser::ExpressionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionList(this);
}

ReentParser::ExpressionListContext* ReentParser::expressionList() {
  ExpressionListContext *_localctx = _tracker.createInstance<ExpressionListContext>(_ctx, getState());
  enterRule(_localctx, 40, ReentParser::RuleExpressionList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(771);
    initializerList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PseudoDestructorNameContext ------------------------------------------------------------------

ReentParser::PseudoDestructorNameContext::PseudoDestructorNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::PseudoDestructorNameContext::Tilde() {
  return getToken(ReentParser::Tilde, 0);
}

std::vector<ReentParser::TheTypeNameContext *> ReentParser::PseudoDestructorNameContext::theTypeName() {
  return getRuleContexts<ReentParser::TheTypeNameContext>();
}

ReentParser::TheTypeNameContext* ReentParser::PseudoDestructorNameContext::theTypeName(size_t i) {
  return getRuleContext<ReentParser::TheTypeNameContext>(i);
}

ReentParser::NestedNameSpecifierContext* ReentParser::PseudoDestructorNameContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::PseudoDestructorNameContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

tree::TerminalNode* ReentParser::PseudoDestructorNameContext::Template() {
  return getToken(ReentParser::Template, 0);
}

ReentParser::SimpleTemplateIdContext* ReentParser::PseudoDestructorNameContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

ReentParser::DecltypeSpecifierContext* ReentParser::PseudoDestructorNameContext::decltypeSpecifier() {
  return getRuleContext<ReentParser::DecltypeSpecifierContext>(0);
}


size_t ReentParser::PseudoDestructorNameContext::getRuleIndex() const {
  return ReentParser::RulePseudoDestructorName;
}

void ReentParser::PseudoDestructorNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPseudoDestructorName(this);
}

void ReentParser::PseudoDestructorNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPseudoDestructorName(this);
}

ReentParser::PseudoDestructorNameContext* ReentParser::pseudoDestructorName() {
  PseudoDestructorNameContext *_localctx = _tracker.createInstance<PseudoDestructorNameContext>(_ctx, getState());
  enterRule(_localctx, 42, ReentParser::RulePseudoDestructorName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(792);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(774);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
      case 1: {
        setState(773);
        nestedNameSpecifier(0);
        break;
      }

      default:
        break;
      }
      setState(779);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << ReentParser::Begin)
        | (1ULL << ReentParser::Clustered)
        | (1ULL << ReentParser::Common)
        | (1ULL << ReentParser::Depends)
        | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
        | (1ULL << (ReentParser::Gpu - 64))
        | (1ULL << (ReentParser::Id - 64))
        | (1ULL << (ReentParser::In - 64))
        | (1ULL << (ReentParser::Local - 64))
        | (1ULL << (ReentParser::MarkPreCondition - 64))
        | (1ULL << (ReentParser::MarkState - 64))
        | (1ULL << (ReentParser::Out - 64))
        | (1ULL << (ReentParser::Plan - 64))
        | (1ULL << (ReentParser::Reset - 64))
        | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

      || _la == ReentParser::Identifier) {
        setState(776);
        theTypeName();
        setState(777);
        match(ReentParser::Doublecolon);
      }
      setState(781);
      match(ReentParser::Tilde);
      setState(782);
      theTypeName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(783);
      nestedNameSpecifier(0);
      setState(784);
      match(ReentParser::Template);
      setState(785);
      simpleTemplateId();
      setState(786);
      match(ReentParser::Doublecolon);
      setState(787);
      match(ReentParser::Tilde);
      setState(788);
      theTypeName();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(790);
      match(ReentParser::Tilde);
      setState(791);
      decltypeSpecifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryExpressionContext ------------------------------------------------------------------

ReentParser::UnaryExpressionContext::UnaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::PostfixExpressionContext* ReentParser::UnaryExpressionContext::postfixExpression() {
  return getRuleContext<ReentParser::PostfixExpressionContext>(0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::Sizeof() {
  return getToken(ReentParser::Sizeof, 0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::TheTypeIdContext* ReentParser::UnaryExpressionContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::UnaryExpressionContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::UnaryExpressionContext* ReentParser::UnaryExpressionContext::unaryExpression() {
  return getRuleContext<ReentParser::UnaryExpressionContext>(0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::PlusPlus() {
  return getToken(ReentParser::PlusPlus, 0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::MinusMinus() {
  return getToken(ReentParser::MinusMinus, 0);
}

ReentParser::UnaryOperatorContext* ReentParser::UnaryExpressionContext::unaryOperator() {
  return getRuleContext<ReentParser::UnaryOperatorContext>(0);
}

ReentParser::CastExpressionContext* ReentParser::UnaryExpressionContext::castExpression() {
  return getRuleContext<ReentParser::CastExpressionContext>(0);
}

tree::TerminalNode* ReentParser::UnaryExpressionContext::Alignof() {
  return getToken(ReentParser::Alignof, 0);
}

ReentParser::NoExceptExpressionContext* ReentParser::UnaryExpressionContext::noExceptExpression() {
  return getRuleContext<ReentParser::NoExceptExpressionContext>(0);
}

ReentParser::NewExpressionContext* ReentParser::UnaryExpressionContext::newExpression() {
  return getRuleContext<ReentParser::NewExpressionContext>(0);
}

ReentParser::DeleteExpressionContext* ReentParser::UnaryExpressionContext::deleteExpression() {
  return getRuleContext<ReentParser::DeleteExpressionContext>(0);
}


size_t ReentParser::UnaryExpressionContext::getRuleIndex() const {
  return ReentParser::RuleUnaryExpression;
}

void ReentParser::UnaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryExpression(this);
}

void ReentParser::UnaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryExpression(this);
}

ReentParser::UnaryExpressionContext* ReentParser::unaryExpression() {
  UnaryExpressionContext *_localctx = _tracker.createInstance<UnaryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 44, ReentParser::RuleUnaryExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(820);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(794);
      postfixExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(795);
      match(ReentParser::Sizeof);
      setState(805);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ReentParser::LeftParen: {
          setState(796);
          match(ReentParser::LeftParen);
          setState(797);
          theTypeId();
          setState(798);
          match(ReentParser::RightParen);
          break;
        }

        case ReentParser::Ellipsis: {
          setState(800);
          match(ReentParser::Ellipsis);
          setState(801);
          match(ReentParser::LeftParen);
          setState(802);
          anyIdentifier();
          setState(803);
          match(ReentParser::RightParen);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(807);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Sizeof || _la == ReentParser::PlusPlus

      || _la == ReentParser::MinusMinus)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(808);
      unaryExpression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(809);
      unaryOperator();
      setState(810);
      castExpression();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(812);
      match(ReentParser::Alignof);
      setState(813);
      match(ReentParser::LeftParen);
      setState(814);
      theTypeId();
      setState(815);
      match(ReentParser::RightParen);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(817);
      noExceptExpression();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(818);
      newExpression();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(819);
      deleteExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryOperatorContext ------------------------------------------------------------------

ReentParser::UnaryOperatorContext::UnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::Or() {
  return getToken(ReentParser::Or, 0);
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::Star() {
  return getToken(ReentParser::Star, 0);
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::Plus() {
  return getToken(ReentParser::Plus, 0);
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::Tilde() {
  return getToken(ReentParser::Tilde, 0);
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::Minus() {
  return getToken(ReentParser::Minus, 0);
}

tree::TerminalNode* ReentParser::UnaryOperatorContext::Not() {
  return getToken(ReentParser::Not, 0);
}


size_t ReentParser::UnaryOperatorContext::getRuleIndex() const {
  return ReentParser::RuleUnaryOperator;
}

void ReentParser::UnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryOperator(this);
}

void ReentParser::UnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryOperator(this);
}

ReentParser::UnaryOperatorContext* ReentParser::unaryOperator() {
  UnaryOperatorContext *_localctx = _tracker.createInstance<UnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 46, ReentParser::RuleUnaryOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(822);
    _la = _input->LA(1);
    if (!(((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & ((1ULL << (ReentParser::Plus - 162))
      | (1ULL << (ReentParser::Minus - 162))
      | (1ULL << (ReentParser::Star - 162))
      | (1ULL << (ReentParser::And - 162))
      | (1ULL << (ReentParser::Or - 162))
      | (1ULL << (ReentParser::Tilde - 162))
      | (1ULL << (ReentParser::Not - 162)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NewExpressionContext ------------------------------------------------------------------

ReentParser::NewExpressionContext::NewExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NewExpressionContext::New() {
  return getToken(ReentParser::New, 0);
}

ReentParser::NewTypeIdContext* ReentParser::NewExpressionContext::newTypeId() {
  return getRuleContext<ReentParser::NewTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::NewExpressionContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

ReentParser::NewPlacementContext* ReentParser::NewExpressionContext::newPlacement() {
  return getRuleContext<ReentParser::NewPlacementContext>(0);
}

ReentParser::NewInitializerContext* ReentParser::NewExpressionContext::newInitializer() {
  return getRuleContext<ReentParser::NewInitializerContext>(0);
}

tree::TerminalNode* ReentParser::NewExpressionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::TheTypeIdContext* ReentParser::NewExpressionContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::NewExpressionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::NewExpressionContext::getRuleIndex() const {
  return ReentParser::RuleNewExpression;
}

void ReentParser::NewExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewExpression(this);
}

void ReentParser::NewExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewExpression(this);
}

ReentParser::NewExpressionContext* ReentParser::newExpression() {
  NewExpressionContext *_localctx = _tracker.createInstance<NewExpressionContext>(_ctx, getState());
  enterRule(_localctx, 48, ReentParser::RuleNewExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(825);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Doublecolon) {
      setState(824);
      match(ReentParser::Doublecolon);
    }
    setState(827);
    match(ReentParser::New);
    setState(829);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      setState(828);
      newPlacement();
      break;
    }

    default:
      break;
    }
    setState(836);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Cfunnel:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Class:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Const:
      case ReentParser::Csem:
      case ReentParser::Cvar:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::Double:
      case ReentParser::End:
      case ReentParser::Enum:
      case ReentParser::Float:
      case ReentParser::Funnel:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Plan_item_type:
      case ReentParser::Plan_type:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Soft_transact_array:
      case ReentParser::Soft_transact_in:
      case ReentParser::Soft_transact_out:
      case ReentParser::Soft_transact_var:
      case ReentParser::Struct:
      case ReentParser::Typename_:
      case ReentParser::Union:
      case ReentParser::Unsigned:
      case ReentParser::Vectorized:
      case ReentParser::Void:
      case ReentParser::Volatile:
      case ReentParser::Wchar:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        setState(831);
        newTypeId();
        break;
      }

      case ReentParser::LeftParen: {
        setState(832);
        match(ReentParser::LeftParen);
        setState(833);
        theTypeId();
        setState(834);
        match(ReentParser::RightParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::LeftParen

    || _la == ReentParser::LeftBrace) {
      setState(838);
      newInitializer();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NewPlacementContext ------------------------------------------------------------------

ReentParser::NewPlacementContext::NewPlacementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NewPlacementContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionListContext* ReentParser::NewPlacementContext::expressionList() {
  return getRuleContext<ReentParser::ExpressionListContext>(0);
}

tree::TerminalNode* ReentParser::NewPlacementContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::NewPlacementContext::getRuleIndex() const {
  return ReentParser::RuleNewPlacement;
}

void ReentParser::NewPlacementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewPlacement(this);
}

void ReentParser::NewPlacementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewPlacement(this);
}

ReentParser::NewPlacementContext* ReentParser::newPlacement() {
  NewPlacementContext *_localctx = _tracker.createInstance<NewPlacementContext>(_ctx, getState());
  enterRule(_localctx, 50, ReentParser::RuleNewPlacement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(841);
    match(ReentParser::LeftParen);
    setState(842);
    expressionList();
    setState(843);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NewTypeIdContext ------------------------------------------------------------------

ReentParser::NewTypeIdContext::NewTypeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TypeSpecifierSeqContext* ReentParser::NewTypeIdContext::typeSpecifierSeq() {
  return getRuleContext<ReentParser::TypeSpecifierSeqContext>(0);
}

ReentParser::NewDeclaratorContext* ReentParser::NewTypeIdContext::newDeclarator() {
  return getRuleContext<ReentParser::NewDeclaratorContext>(0);
}


size_t ReentParser::NewTypeIdContext::getRuleIndex() const {
  return ReentParser::RuleNewTypeId;
}

void ReentParser::NewTypeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewTypeId(this);
}

void ReentParser::NewTypeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewTypeId(this);
}

ReentParser::NewTypeIdContext* ReentParser::newTypeId() {
  NewTypeIdContext *_localctx = _tracker.createInstance<NewTypeIdContext>(_ctx, getState());
  enterRule(_localctx, 52, ReentParser::RuleNewTypeId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(845);
    typeSpecifierSeq();
    setState(847);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
    case 1: {
      setState(846);
      newDeclarator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NewDeclaratorContext ------------------------------------------------------------------

ReentParser::NewDeclaratorContext::NewDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::PointerOperatorContext* ReentParser::NewDeclaratorContext::pointerOperator() {
  return getRuleContext<ReentParser::PointerOperatorContext>(0);
}

ReentParser::NewDeclaratorContext* ReentParser::NewDeclaratorContext::newDeclarator() {
  return getRuleContext<ReentParser::NewDeclaratorContext>(0);
}

ReentParser::NoPointerNewDeclaratorContext* ReentParser::NewDeclaratorContext::noPointerNewDeclarator() {
  return getRuleContext<ReentParser::NoPointerNewDeclaratorContext>(0);
}


size_t ReentParser::NewDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleNewDeclarator;
}

void ReentParser::NewDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewDeclarator(this);
}

void ReentParser::NewDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewDeclarator(this);
}

ReentParser::NewDeclaratorContext* ReentParser::newDeclarator() {
  NewDeclaratorContext *_localctx = _tracker.createInstance<NewDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 54, ReentParser::RuleNewDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(854);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Star:
      case ReentParser::And:
      case ReentParser::AndAnd:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(849);
        pointerOperator();
        setState(851);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
        case 1: {
          setState(850);
          newDeclarator();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::LeftBracket: {
        enterOuterAlt(_localctx, 2);
        setState(853);
        noPointerNewDeclarator(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoPointerNewDeclaratorContext ------------------------------------------------------------------

ReentParser::NoPointerNewDeclaratorContext::NoPointerNewDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NoPointerNewDeclaratorContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

ReentParser::ExpressionContext* ReentParser::NoPointerNewDeclaratorContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::NoPointerNewDeclaratorContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::NoPointerNewDeclaratorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::NoPointerNewDeclaratorContext* ReentParser::NoPointerNewDeclaratorContext::noPointerNewDeclarator() {
  return getRuleContext<ReentParser::NoPointerNewDeclaratorContext>(0);
}

ReentParser::ConstantExpressionContext* ReentParser::NoPointerNewDeclaratorContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}


size_t ReentParser::NoPointerNewDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleNoPointerNewDeclarator;
}

void ReentParser::NoPointerNewDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoPointerNewDeclarator(this);
}

void ReentParser::NoPointerNewDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoPointerNewDeclarator(this);
}


ReentParser::NoPointerNewDeclaratorContext* ReentParser::noPointerNewDeclarator() {
   return noPointerNewDeclarator(0);
}

ReentParser::NoPointerNewDeclaratorContext* ReentParser::noPointerNewDeclarator(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ReentParser::NoPointerNewDeclaratorContext *_localctx = _tracker.createInstance<NoPointerNewDeclaratorContext>(_ctx, parentState);
  ReentParser::NoPointerNewDeclaratorContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 56;
  enterRecursionRule(_localctx, 56, ReentParser::RuleNoPointerNewDeclarator, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(857);
    match(ReentParser::LeftBracket);
    setState(858);
    expression();
    setState(859);
    match(ReentParser::RightBracket);
    setState(861);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
    case 1: {
      setState(860);
      attributeSpecifierSeq();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(872);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<NoPointerNewDeclaratorContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleNoPointerNewDeclarator);
        setState(863);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(864);
        match(ReentParser::LeftBracket);
        setState(865);
        constantExpression();
        setState(866);
        match(ReentParser::RightBracket);
        setState(868);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
        case 1: {
          setState(867);
          attributeSpecifierSeq();
          break;
        }

        default:
          break;
        } 
      }
      setState(874);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- NewInitializerContext ------------------------------------------------------------------

ReentParser::NewInitializerContext::NewInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NewInitializerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::NewInitializerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::ExpressionListContext* ReentParser::NewInitializerContext::expressionList() {
  return getRuleContext<ReentParser::ExpressionListContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::NewInitializerContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}


size_t ReentParser::NewInitializerContext::getRuleIndex() const {
  return ReentParser::RuleNewInitializer;
}

void ReentParser::NewInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNewInitializer(this);
}

void ReentParser::NewInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNewInitializer(this);
}

ReentParser::NewInitializerContext* ReentParser::newInitializer() {
  NewInitializerContext *_localctx = _tracker.createInstance<NewInitializerContext>(_ctx, getState());
  enterRule(_localctx, 58, ReentParser::RuleNewInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(881);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftParen: {
        enterOuterAlt(_localctx, 1);
        setState(875);
        match(ReentParser::LeftParen);
        setState(877);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
        case 1: {
          setState(876);
          expressionList();
          break;
        }

        default:
          break;
        }
        setState(879);
        match(ReentParser::RightParen);
        break;
      }

      case ReentParser::LeftBrace: {
        enterOuterAlt(_localctx, 2);
        setState(880);
        bracedInitList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteExpressionContext ------------------------------------------------------------------

ReentParser::DeleteExpressionContext::DeleteExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::DeleteExpressionContext::Delete() {
  return getToken(ReentParser::Delete, 0);
}

ReentParser::CastExpressionContext* ReentParser::DeleteExpressionContext::castExpression() {
  return getRuleContext<ReentParser::CastExpressionContext>(0);
}

tree::TerminalNode* ReentParser::DeleteExpressionContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

tree::TerminalNode* ReentParser::DeleteExpressionContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::DeleteExpressionContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}


size_t ReentParser::DeleteExpressionContext::getRuleIndex() const {
  return ReentParser::RuleDeleteExpression;
}

void ReentParser::DeleteExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteExpression(this);
}

void ReentParser::DeleteExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteExpression(this);
}

ReentParser::DeleteExpressionContext* ReentParser::deleteExpression() {
  DeleteExpressionContext *_localctx = _tracker.createInstance<DeleteExpressionContext>(_ctx, getState());
  enterRule(_localctx, 60, ReentParser::RuleDeleteExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(884);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Doublecolon) {
      setState(883);
      match(ReentParser::Doublecolon);
    }
    setState(886);
    match(ReentParser::Delete);
    setState(889);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
    case 1: {
      setState(887);
      match(ReentParser::LeftBracket);
      setState(888);
      match(ReentParser::RightBracket);
      break;
    }

    default:
      break;
    }
    setState(891);
    castExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoExceptExpressionContext ------------------------------------------------------------------

ReentParser::NoExceptExpressionContext::NoExceptExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NoExceptExpressionContext::Noexcept() {
  return getToken(ReentParser::Noexcept, 0);
}

tree::TerminalNode* ReentParser::NoExceptExpressionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::NoExceptExpressionContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::NoExceptExpressionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::NoExceptExpressionContext::getRuleIndex() const {
  return ReentParser::RuleNoExceptExpression;
}

void ReentParser::NoExceptExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoExceptExpression(this);
}

void ReentParser::NoExceptExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoExceptExpression(this);
}

ReentParser::NoExceptExpressionContext* ReentParser::noExceptExpression() {
  NoExceptExpressionContext *_localctx = _tracker.createInstance<NoExceptExpressionContext>(_ctx, getState());
  enterRule(_localctx, 62, ReentParser::RuleNoExceptExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(893);
    match(ReentParser::Noexcept);
    setState(894);
    match(ReentParser::LeftParen);
    setState(895);
    expression();
    setState(896);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastExpressionContext ------------------------------------------------------------------

ReentParser::CastExpressionContext::CastExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::UnaryExpressionContext* ReentParser::CastExpressionContext::unaryExpression() {
  return getRuleContext<ReentParser::UnaryExpressionContext>(0);
}

tree::TerminalNode* ReentParser::CastExpressionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::TheTypeIdContext* ReentParser::CastExpressionContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::CastExpressionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::CastExpressionContext* ReentParser::CastExpressionContext::castExpression() {
  return getRuleContext<ReentParser::CastExpressionContext>(0);
}


size_t ReentParser::CastExpressionContext::getRuleIndex() const {
  return ReentParser::RuleCastExpression;
}

void ReentParser::CastExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastExpression(this);
}

void ReentParser::CastExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastExpression(this);
}

ReentParser::CastExpressionContext* ReentParser::castExpression() {
  CastExpressionContext *_localctx = _tracker.createInstance<CastExpressionContext>(_ctx, getState());
  enterRule(_localctx, 64, ReentParser::RuleCastExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(904);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(898);
      unaryExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(899);
      match(ReentParser::LeftParen);
      setState(900);
      theTypeId();
      setState(901);
      match(ReentParser::RightParen);
      setState(902);
      castExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerMemberExpressionContext ------------------------------------------------------------------

ReentParser::PointerMemberExpressionContext::PointerMemberExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::CastExpressionContext *> ReentParser::PointerMemberExpressionContext::castExpression() {
  return getRuleContexts<ReentParser::CastExpressionContext>();
}

ReentParser::CastExpressionContext* ReentParser::PointerMemberExpressionContext::castExpression(size_t i) {
  return getRuleContext<ReentParser::CastExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::PointerMemberExpressionContext::DotStar() {
  return getTokens(ReentParser::DotStar);
}

tree::TerminalNode* ReentParser::PointerMemberExpressionContext::DotStar(size_t i) {
  return getToken(ReentParser::DotStar, i);
}

std::vector<tree::TerminalNode *> ReentParser::PointerMemberExpressionContext::ArrowStar() {
  return getTokens(ReentParser::ArrowStar);
}

tree::TerminalNode* ReentParser::PointerMemberExpressionContext::ArrowStar(size_t i) {
  return getToken(ReentParser::ArrowStar, i);
}


size_t ReentParser::PointerMemberExpressionContext::getRuleIndex() const {
  return ReentParser::RulePointerMemberExpression;
}

void ReentParser::PointerMemberExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointerMemberExpression(this);
}

void ReentParser::PointerMemberExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointerMemberExpression(this);
}

ReentParser::PointerMemberExpressionContext* ReentParser::pointerMemberExpression() {
  PointerMemberExpressionContext *_localctx = _tracker.createInstance<PointerMemberExpressionContext>(_ctx, getState());
  enterRule(_localctx, 66, ReentParser::RulePointerMemberExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(906);
    castExpression();
    setState(911);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::ArrowStar

    || _la == ReentParser::DotStar) {
      setState(907);
      _la = _input->LA(1);
      if (!(_la == ReentParser::ArrowStar

      || _la == ReentParser::DotStar)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(908);
      castExpression();
      setState(913);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultiplicativeExpressionContext ------------------------------------------------------------------

ReentParser::MultiplicativeExpressionContext::MultiplicativeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::PointerMemberExpressionContext *> ReentParser::MultiplicativeExpressionContext::pointerMemberExpression() {
  return getRuleContexts<ReentParser::PointerMemberExpressionContext>();
}

ReentParser::PointerMemberExpressionContext* ReentParser::MultiplicativeExpressionContext::pointerMemberExpression(size_t i) {
  return getRuleContext<ReentParser::PointerMemberExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::MultiplicativeExpressionContext::Star() {
  return getTokens(ReentParser::Star);
}

tree::TerminalNode* ReentParser::MultiplicativeExpressionContext::Star(size_t i) {
  return getToken(ReentParser::Star, i);
}

std::vector<tree::TerminalNode *> ReentParser::MultiplicativeExpressionContext::Div() {
  return getTokens(ReentParser::Div);
}

tree::TerminalNode* ReentParser::MultiplicativeExpressionContext::Div(size_t i) {
  return getToken(ReentParser::Div, i);
}

std::vector<tree::TerminalNode *> ReentParser::MultiplicativeExpressionContext::Mod() {
  return getTokens(ReentParser::Mod);
}

tree::TerminalNode* ReentParser::MultiplicativeExpressionContext::Mod(size_t i) {
  return getToken(ReentParser::Mod, i);
}


size_t ReentParser::MultiplicativeExpressionContext::getRuleIndex() const {
  return ReentParser::RuleMultiplicativeExpression;
}

void ReentParser::MultiplicativeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicativeExpression(this);
}

void ReentParser::MultiplicativeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicativeExpression(this);
}

ReentParser::MultiplicativeExpressionContext* ReentParser::multiplicativeExpression() {
  MultiplicativeExpressionContext *_localctx = _tracker.createInstance<MultiplicativeExpressionContext>(_ctx, getState());
  enterRule(_localctx, 68, ReentParser::RuleMultiplicativeExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    pointerMemberExpression();
    setState(919);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 164) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 164)) & ((1ULL << (ReentParser::Star - 164))
      | (1ULL << (ReentParser::Div - 164))
      | (1ULL << (ReentParser::Mod - 164)))) != 0)) {
      setState(915);
      _la = _input->LA(1);
      if (!(((((_la - 164) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 164)) & ((1ULL << (ReentParser::Star - 164))
        | (1ULL << (ReentParser::Div - 164))
        | (1ULL << (ReentParser::Mod - 164)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(916);
      pointerMemberExpression();
      setState(921);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdditiveExpressionContext ------------------------------------------------------------------

ReentParser::AdditiveExpressionContext::AdditiveExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::MultiplicativeExpressionContext *> ReentParser::AdditiveExpressionContext::multiplicativeExpression() {
  return getRuleContexts<ReentParser::MultiplicativeExpressionContext>();
}

ReentParser::MultiplicativeExpressionContext* ReentParser::AdditiveExpressionContext::multiplicativeExpression(size_t i) {
  return getRuleContext<ReentParser::MultiplicativeExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::AdditiveExpressionContext::Plus() {
  return getTokens(ReentParser::Plus);
}

tree::TerminalNode* ReentParser::AdditiveExpressionContext::Plus(size_t i) {
  return getToken(ReentParser::Plus, i);
}

std::vector<tree::TerminalNode *> ReentParser::AdditiveExpressionContext::Minus() {
  return getTokens(ReentParser::Minus);
}

tree::TerminalNode* ReentParser::AdditiveExpressionContext::Minus(size_t i) {
  return getToken(ReentParser::Minus, i);
}


size_t ReentParser::AdditiveExpressionContext::getRuleIndex() const {
  return ReentParser::RuleAdditiveExpression;
}

void ReentParser::AdditiveExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditiveExpression(this);
}

void ReentParser::AdditiveExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditiveExpression(this);
}

ReentParser::AdditiveExpressionContext* ReentParser::additiveExpression() {
  AdditiveExpressionContext *_localctx = _tracker.createInstance<AdditiveExpressionContext>(_ctx, getState());
  enterRule(_localctx, 70, ReentParser::RuleAdditiveExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(922);
    multiplicativeExpression();
    setState(927);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Plus

    || _la == ReentParser::Minus) {
      setState(923);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Plus

      || _la == ReentParser::Minus)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(924);
      multiplicativeExpression();
      setState(929);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShiftExpressionContext ------------------------------------------------------------------

ReentParser::ShiftExpressionContext::ShiftExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AdditiveExpressionContext *> ReentParser::ShiftExpressionContext::additiveExpression() {
  return getRuleContexts<ReentParser::AdditiveExpressionContext>();
}

ReentParser::AdditiveExpressionContext* ReentParser::ShiftExpressionContext::additiveExpression(size_t i) {
  return getRuleContext<ReentParser::AdditiveExpressionContext>(i);
}

std::vector<ReentParser::ShiftOperatorContext *> ReentParser::ShiftExpressionContext::shiftOperator() {
  return getRuleContexts<ReentParser::ShiftOperatorContext>();
}

ReentParser::ShiftOperatorContext* ReentParser::ShiftExpressionContext::shiftOperator(size_t i) {
  return getRuleContext<ReentParser::ShiftOperatorContext>(i);
}


size_t ReentParser::ShiftExpressionContext::getRuleIndex() const {
  return ReentParser::RuleShiftExpression;
}

void ReentParser::ShiftExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShiftExpression(this);
}

void ReentParser::ShiftExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShiftExpression(this);
}

ReentParser::ShiftExpressionContext* ReentParser::shiftExpression() {
  ShiftExpressionContext *_localctx = _tracker.createInstance<ShiftExpressionContext>(_ctx, getState());
  enterRule(_localctx, 72, ReentParser::RuleShiftExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(930);
    additiveExpression();
    setState(936);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(931);
        shiftOperator();
        setState(932);
        additiveExpression(); 
      }
      setState(938);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShiftOperatorContext ------------------------------------------------------------------

ReentParser::ShiftOperatorContext::ShiftOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ReentParser::ShiftOperatorContext::Greater() {
  return getTokens(ReentParser::Greater);
}

tree::TerminalNode* ReentParser::ShiftOperatorContext::Greater(size_t i) {
  return getToken(ReentParser::Greater, i);
}

std::vector<tree::TerminalNode *> ReentParser::ShiftOperatorContext::Less() {
  return getTokens(ReentParser::Less);
}

tree::TerminalNode* ReentParser::ShiftOperatorContext::Less(size_t i) {
  return getToken(ReentParser::Less, i);
}


size_t ReentParser::ShiftOperatorContext::getRuleIndex() const {
  return ReentParser::RuleShiftOperator;
}

void ReentParser::ShiftOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShiftOperator(this);
}

void ReentParser::ShiftOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShiftOperator(this);
}

ReentParser::ShiftOperatorContext* ReentParser::shiftOperator() {
  ShiftOperatorContext *_localctx = _tracker.createInstance<ShiftOperatorContext>(_ctx, getState());
  enterRule(_localctx, 74, ReentParser::RuleShiftOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(943);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Greater: {
        enterOuterAlt(_localctx, 1);
        setState(939);
        match(ReentParser::Greater);
        setState(940);
        match(ReentParser::Greater);
        break;
      }

      case ReentParser::Less: {
        enterOuterAlt(_localctx, 2);
        setState(941);
        match(ReentParser::Less);
        setState(942);
        match(ReentParser::Less);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RelationalExpressionContext ------------------------------------------------------------------

ReentParser::RelationalExpressionContext::RelationalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::ShiftExpressionContext *> ReentParser::RelationalExpressionContext::shiftExpression() {
  return getRuleContexts<ReentParser::ShiftExpressionContext>();
}

ReentParser::ShiftExpressionContext* ReentParser::RelationalExpressionContext::shiftExpression(size_t i) {
  return getRuleContext<ReentParser::ShiftExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::RelationalExpressionContext::Less() {
  return getTokens(ReentParser::Less);
}

tree::TerminalNode* ReentParser::RelationalExpressionContext::Less(size_t i) {
  return getToken(ReentParser::Less, i);
}

std::vector<tree::TerminalNode *> ReentParser::RelationalExpressionContext::Greater() {
  return getTokens(ReentParser::Greater);
}

tree::TerminalNode* ReentParser::RelationalExpressionContext::Greater(size_t i) {
  return getToken(ReentParser::Greater, i);
}

std::vector<tree::TerminalNode *> ReentParser::RelationalExpressionContext::LessEqual() {
  return getTokens(ReentParser::LessEqual);
}

tree::TerminalNode* ReentParser::RelationalExpressionContext::LessEqual(size_t i) {
  return getToken(ReentParser::LessEqual, i);
}

std::vector<tree::TerminalNode *> ReentParser::RelationalExpressionContext::GreaterEqual() {
  return getTokens(ReentParser::GreaterEqual);
}

tree::TerminalNode* ReentParser::RelationalExpressionContext::GreaterEqual(size_t i) {
  return getToken(ReentParser::GreaterEqual, i);
}


size_t ReentParser::RelationalExpressionContext::getRuleIndex() const {
  return ReentParser::RuleRelationalExpression;
}

void ReentParser::RelationalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelationalExpression(this);
}

void ReentParser::RelationalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelationalExpression(this);
}

ReentParser::RelationalExpressionContext* ReentParser::relationalExpression() {
  RelationalExpressionContext *_localctx = _tracker.createInstance<RelationalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 76, ReentParser::RuleRelationalExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(945);
    shiftExpression();
    setState(950);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(946);
        _la = _input->LA(1);
        if (!(((((_la - 173) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 173)) & ((1ULL << (ReentParser::Less - 173))
          | (1ULL << (ReentParser::Greater - 173))
          | (1ULL << (ReentParser::LessEqual - 173))
          | (1ULL << (ReentParser::GreaterEqual - 173)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(947);
        shiftExpression(); 
      }
      setState(952);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualityExpressionContext ------------------------------------------------------------------

ReentParser::EqualityExpressionContext::EqualityExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::RelationalExpressionContext *> ReentParser::EqualityExpressionContext::relationalExpression() {
  return getRuleContexts<ReentParser::RelationalExpressionContext>();
}

ReentParser::RelationalExpressionContext* ReentParser::EqualityExpressionContext::relationalExpression(size_t i) {
  return getRuleContext<ReentParser::RelationalExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::EqualityExpressionContext::Equal() {
  return getTokens(ReentParser::Equal);
}

tree::TerminalNode* ReentParser::EqualityExpressionContext::Equal(size_t i) {
  return getToken(ReentParser::Equal, i);
}

std::vector<tree::TerminalNode *> ReentParser::EqualityExpressionContext::NotEqual() {
  return getTokens(ReentParser::NotEqual);
}

tree::TerminalNode* ReentParser::EqualityExpressionContext::NotEqual(size_t i) {
  return getToken(ReentParser::NotEqual, i);
}


size_t ReentParser::EqualityExpressionContext::getRuleIndex() const {
  return ReentParser::RuleEqualityExpression;
}

void ReentParser::EqualityExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityExpression(this);
}

void ReentParser::EqualityExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityExpression(this);
}

ReentParser::EqualityExpressionContext* ReentParser::equalityExpression() {
  EqualityExpressionContext *_localctx = _tracker.createInstance<EqualityExpressionContext>(_ctx, getState());
  enterRule(_localctx, 78, ReentParser::RuleEqualityExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(953);
    relationalExpression();
    setState(958);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Equal

    || _la == ReentParser::NotEqual) {
      setState(954);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Equal

      || _la == ReentParser::NotEqual)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(955);
      relationalExpression();
      setState(960);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AndExpressionContext ------------------------------------------------------------------

ReentParser::AndExpressionContext::AndExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::EqualityExpressionContext *> ReentParser::AndExpressionContext::equalityExpression() {
  return getRuleContexts<ReentParser::EqualityExpressionContext>();
}

ReentParser::EqualityExpressionContext* ReentParser::AndExpressionContext::equalityExpression(size_t i) {
  return getRuleContext<ReentParser::EqualityExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::AndExpressionContext::And() {
  return getTokens(ReentParser::And);
}

tree::TerminalNode* ReentParser::AndExpressionContext::And(size_t i) {
  return getToken(ReentParser::And, i);
}


size_t ReentParser::AndExpressionContext::getRuleIndex() const {
  return ReentParser::RuleAndExpression;
}

void ReentParser::AndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAndExpression(this);
}

void ReentParser::AndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAndExpression(this);
}

ReentParser::AndExpressionContext* ReentParser::andExpression() {
  AndExpressionContext *_localctx = _tracker.createInstance<AndExpressionContext>(_ctx, getState());
  enterRule(_localctx, 80, ReentParser::RuleAndExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(961);
    equalityExpression();
    setState(966);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::And) {
      setState(962);
      match(ReentParser::And);
      setState(963);
      equalityExpression();
      setState(968);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExclusiveOrExpressionContext ------------------------------------------------------------------

ReentParser::ExclusiveOrExpressionContext::ExclusiveOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AndExpressionContext *> ReentParser::ExclusiveOrExpressionContext::andExpression() {
  return getRuleContexts<ReentParser::AndExpressionContext>();
}

ReentParser::AndExpressionContext* ReentParser::ExclusiveOrExpressionContext::andExpression(size_t i) {
  return getRuleContext<ReentParser::AndExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::ExclusiveOrExpressionContext::Caret() {
  return getTokens(ReentParser::Caret);
}

tree::TerminalNode* ReentParser::ExclusiveOrExpressionContext::Caret(size_t i) {
  return getToken(ReentParser::Caret, i);
}


size_t ReentParser::ExclusiveOrExpressionContext::getRuleIndex() const {
  return ReentParser::RuleExclusiveOrExpression;
}

void ReentParser::ExclusiveOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExclusiveOrExpression(this);
}

void ReentParser::ExclusiveOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExclusiveOrExpression(this);
}

ReentParser::ExclusiveOrExpressionContext* ReentParser::exclusiveOrExpression() {
  ExclusiveOrExpressionContext *_localctx = _tracker.createInstance<ExclusiveOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 82, ReentParser::RuleExclusiveOrExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(969);
    andExpression();
    setState(974);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Caret) {
      setState(970);
      match(ReentParser::Caret);
      setState(971);
      andExpression();
      setState(976);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InclusiveOrExpressionContext ------------------------------------------------------------------

ReentParser::InclusiveOrExpressionContext::InclusiveOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::ExclusiveOrExpressionContext *> ReentParser::InclusiveOrExpressionContext::exclusiveOrExpression() {
  return getRuleContexts<ReentParser::ExclusiveOrExpressionContext>();
}

ReentParser::ExclusiveOrExpressionContext* ReentParser::InclusiveOrExpressionContext::exclusiveOrExpression(size_t i) {
  return getRuleContext<ReentParser::ExclusiveOrExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::InclusiveOrExpressionContext::Or() {
  return getTokens(ReentParser::Or);
}

tree::TerminalNode* ReentParser::InclusiveOrExpressionContext::Or(size_t i) {
  return getToken(ReentParser::Or, i);
}


size_t ReentParser::InclusiveOrExpressionContext::getRuleIndex() const {
  return ReentParser::RuleInclusiveOrExpression;
}

void ReentParser::InclusiveOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInclusiveOrExpression(this);
}

void ReentParser::InclusiveOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInclusiveOrExpression(this);
}

ReentParser::InclusiveOrExpressionContext* ReentParser::inclusiveOrExpression() {
  InclusiveOrExpressionContext *_localctx = _tracker.createInstance<InclusiveOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 84, ReentParser::RuleInclusiveOrExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(977);
    exclusiveOrExpression();
    setState(982);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Or) {
      setState(978);
      match(ReentParser::Or);
      setState(979);
      exclusiveOrExpression();
      setState(984);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalAndExpressionContext ------------------------------------------------------------------

ReentParser::LogicalAndExpressionContext::LogicalAndExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::InclusiveOrExpressionContext *> ReentParser::LogicalAndExpressionContext::inclusiveOrExpression() {
  return getRuleContexts<ReentParser::InclusiveOrExpressionContext>();
}

ReentParser::InclusiveOrExpressionContext* ReentParser::LogicalAndExpressionContext::inclusiveOrExpression(size_t i) {
  return getRuleContext<ReentParser::InclusiveOrExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::LogicalAndExpressionContext::AndAnd() {
  return getTokens(ReentParser::AndAnd);
}

tree::TerminalNode* ReentParser::LogicalAndExpressionContext::AndAnd(size_t i) {
  return getToken(ReentParser::AndAnd, i);
}


size_t ReentParser::LogicalAndExpressionContext::getRuleIndex() const {
  return ReentParser::RuleLogicalAndExpression;
}

void ReentParser::LogicalAndExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalAndExpression(this);
}

void ReentParser::LogicalAndExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalAndExpression(this);
}

ReentParser::LogicalAndExpressionContext* ReentParser::logicalAndExpression() {
  LogicalAndExpressionContext *_localctx = _tracker.createInstance<LogicalAndExpressionContext>(_ctx, getState());
  enterRule(_localctx, 86, ReentParser::RuleLogicalAndExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(985);
    inclusiveOrExpression();
    setState(990);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::AndAnd) {
      setState(986);
      match(ReentParser::AndAnd);
      setState(987);
      inclusiveOrExpression();
      setState(992);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicalOrExpressionContext ------------------------------------------------------------------

ReentParser::LogicalOrExpressionContext::LogicalOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::LogicalAndExpressionContext *> ReentParser::LogicalOrExpressionContext::logicalAndExpression() {
  return getRuleContexts<ReentParser::LogicalAndExpressionContext>();
}

ReentParser::LogicalAndExpressionContext* ReentParser::LogicalOrExpressionContext::logicalAndExpression(size_t i) {
  return getRuleContext<ReentParser::LogicalAndExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::LogicalOrExpressionContext::OrOr() {
  return getTokens(ReentParser::OrOr);
}

tree::TerminalNode* ReentParser::LogicalOrExpressionContext::OrOr(size_t i) {
  return getToken(ReentParser::OrOr, i);
}


size_t ReentParser::LogicalOrExpressionContext::getRuleIndex() const {
  return ReentParser::RuleLogicalOrExpression;
}

void ReentParser::LogicalOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogicalOrExpression(this);
}

void ReentParser::LogicalOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogicalOrExpression(this);
}

ReentParser::LogicalOrExpressionContext* ReentParser::logicalOrExpression() {
  LogicalOrExpressionContext *_localctx = _tracker.createInstance<LogicalOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 88, ReentParser::RuleLogicalOrExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(993);
    logicalAndExpression();
    setState(998);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::OrOr) {
      setState(994);
      match(ReentParser::OrOr);
      setState(995);
      logicalAndExpression();
      setState(1000);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionalExpressionContext ------------------------------------------------------------------

ReentParser::ConditionalExpressionContext::ConditionalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::LogicalOrExpressionContext* ReentParser::ConditionalExpressionContext::logicalOrExpression() {
  return getRuleContext<ReentParser::LogicalOrExpressionContext>(0);
}

tree::TerminalNode* ReentParser::ConditionalExpressionContext::Question() {
  return getToken(ReentParser::Question, 0);
}

ReentParser::ExpressionContext* ReentParser::ConditionalExpressionContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::ConditionalExpressionContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::ConditionalExpressionContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}


size_t ReentParser::ConditionalExpressionContext::getRuleIndex() const {
  return ReentParser::RuleConditionalExpression;
}

void ReentParser::ConditionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalExpression(this);
}

void ReentParser::ConditionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalExpression(this);
}

ReentParser::ConditionalExpressionContext* ReentParser::conditionalExpression() {
  ConditionalExpressionContext *_localctx = _tracker.createInstance<ConditionalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 90, ReentParser::RuleConditionalExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1001);
    logicalOrExpression();
    setState(1007);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Question) {
      setState(1002);
      match(ReentParser::Question);
      setState(1003);
      expression();
      setState(1004);
      match(ReentParser::Colon);
      setState(1005);
      assignmentExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentExpressionContext ------------------------------------------------------------------

ReentParser::AssignmentExpressionContext::AssignmentExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ConditionalExpressionContext* ReentParser::AssignmentExpressionContext::conditionalExpression() {
  return getRuleContext<ReentParser::ConditionalExpressionContext>(0);
}

ReentParser::LogicalOrExpressionContext* ReentParser::AssignmentExpressionContext::logicalOrExpression() {
  return getRuleContext<ReentParser::LogicalOrExpressionContext>(0);
}

ReentParser::AssignmentOperatorContext* ReentParser::AssignmentExpressionContext::assignmentOperator() {
  return getRuleContext<ReentParser::AssignmentOperatorContext>(0);
}

ReentParser::InitializerClauseContext* ReentParser::AssignmentExpressionContext::initializerClause() {
  return getRuleContext<ReentParser::InitializerClauseContext>(0);
}

ReentParser::ThrowExpressionContext* ReentParser::AssignmentExpressionContext::throwExpression() {
  return getRuleContext<ReentParser::ThrowExpressionContext>(0);
}


size_t ReentParser::AssignmentExpressionContext::getRuleIndex() const {
  return ReentParser::RuleAssignmentExpression;
}

void ReentParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}

void ReentParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}

ReentParser::AssignmentExpressionContext* ReentParser::assignmentExpression() {
  AssignmentExpressionContext *_localctx = _tracker.createInstance<AssignmentExpressionContext>(_ctx, getState());
  enterRule(_localctx, 92, ReentParser::RuleAssignmentExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1015);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1009);
      conditionalExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1010);
      logicalOrExpression();
      setState(1011);
      assignmentOperator();
      setState(1012);
      initializerClause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1014);
      throwExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

ReentParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::StarAssign() {
  return getToken(ReentParser::StarAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::DivAssign() {
  return getToken(ReentParser::DivAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::ModAssign() {
  return getToken(ReentParser::ModAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::PlusAssign() {
  return getToken(ReentParser::PlusAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::MinusAssign() {
  return getToken(ReentParser::MinusAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::RightShiftAssign() {
  return getToken(ReentParser::RightShiftAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::LeftShiftAssign() {
  return getToken(ReentParser::LeftShiftAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::AndAssign() {
  return getToken(ReentParser::AndAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::XorAssign() {
  return getToken(ReentParser::XorAssign, 0);
}

tree::TerminalNode* ReentParser::AssignmentOperatorContext::OrAssign() {
  return getToken(ReentParser::OrAssign, 0);
}


size_t ReentParser::AssignmentOperatorContext::getRuleIndex() const {
  return ReentParser::RuleAssignmentOperator;
}

void ReentParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void ReentParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

ReentParser::AssignmentOperatorContext* ReentParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 94, ReentParser::RuleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1017);
    _la = _input->LA(1);
    if (!(((((_la - 172) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 172)) & ((1ULL << (ReentParser::Assign - 172))
      | (1ULL << (ReentParser::PlusAssign - 172))
      | (1ULL << (ReentParser::MinusAssign - 172))
      | (1ULL << (ReentParser::StarAssign - 172))
      | (1ULL << (ReentParser::DivAssign - 172))
      | (1ULL << (ReentParser::ModAssign - 172))
      | (1ULL << (ReentParser::XorAssign - 172))
      | (1ULL << (ReentParser::AndAssign - 172))
      | (1ULL << (ReentParser::OrAssign - 172))
      | (1ULL << (ReentParser::LeftShiftAssign - 172))
      | (1ULL << (ReentParser::RightShiftAssign - 172)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

ReentParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AssignmentExpressionContext *> ReentParser::ExpressionContext::assignmentExpression() {
  return getRuleContexts<ReentParser::AssignmentExpressionContext>();
}

ReentParser::AssignmentExpressionContext* ReentParser::ExpressionContext::assignmentExpression(size_t i) {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::ExpressionContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::ExpressionContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::ExpressionContext::getRuleIndex() const {
  return ReentParser::RuleExpression;
}

void ReentParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void ReentParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

ReentParser::ExpressionContext* ReentParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 96, ReentParser::RuleExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1019);
    assignmentExpression();
    setState(1024);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1020);
        match(ReentParser::Comma);
        setState(1021);
        assignmentExpression(); 
      }
      setState(1026);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantExpressionContext ------------------------------------------------------------------

ReentParser::ConstantExpressionContext::ConstantExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ConditionalExpressionContext* ReentParser::ConstantExpressionContext::conditionalExpression() {
  return getRuleContext<ReentParser::ConditionalExpressionContext>(0);
}


size_t ReentParser::ConstantExpressionContext::getRuleIndex() const {
  return ReentParser::RuleConstantExpression;
}

void ReentParser::ConstantExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstantExpression(this);
}

void ReentParser::ConstantExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstantExpression(this);
}

ReentParser::ConstantExpressionContext* ReentParser::constantExpression() {
  ConstantExpressionContext *_localctx = _tracker.createInstance<ConstantExpressionContext>(_ctx, getState());
  enterRule(_localctx, 98, ReentParser::RuleConstantExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1027);
    conditionalExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

ReentParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::LabeledStatementContext* ReentParser::StatementContext::labeledStatement() {
  return getRuleContext<ReentParser::LabeledStatementContext>(0);
}

ReentParser::Cilk_syncContext* ReentParser::StatementContext::cilk_sync() {
  return getRuleContext<ReentParser::Cilk_syncContext>(0);
}

ReentParser::Start_chainContext* ReentParser::StatementContext::start_chain() {
  return getRuleContext<ReentParser::Start_chainContext>(0);
}

ReentParser::Start_topologyContext* ReentParser::StatementContext::start_topology() {
  return getRuleContext<ReentParser::Start_topologyContext>(0);
}

ReentParser::Fill_into_planContext* ReentParser::StatementContext::fill_into_plan() {
  return getRuleContext<ReentParser::Fill_into_planContext>(0);
}

ReentParser::Fill_from_planContext* ReentParser::StatementContext::fill_from_plan() {
  return getRuleContext<ReentParser::Fill_from_planContext>(0);
}

ReentParser::Plan_criticalContext* ReentParser::StatementContext::plan_critical() {
  return getRuleContext<ReentParser::Plan_criticalContext>(0);
}

ReentParser::Reent_statementContext* ReentParser::StatementContext::reent_statement() {
  return getRuleContext<ReentParser::Reent_statementContext>(0);
}

ReentParser::Chain_statementContext* ReentParser::StatementContext::chain_statement() {
  return getRuleContext<ReentParser::Chain_statementContext>(0);
}

ReentParser::Reent_special_callContext* ReentParser::StatementContext::reent_special_call() {
  return getRuleContext<ReentParser::Reent_special_callContext>(0);
}

ReentParser::Atomic_blockContext* ReentParser::StatementContext::atomic_block() {
  return getRuleContext<ReentParser::Atomic_blockContext>(0);
}

ReentParser::Soft_atomic_blockContext* ReentParser::StatementContext::soft_atomic_block() {
  return getRuleContext<ReentParser::Soft_atomic_blockContext>(0);
}

ReentParser::Spawned_call_statementContext* ReentParser::StatementContext::spawned_call_statement() {
  return getRuleContext<ReentParser::Spawned_call_statementContext>(0);
}

tree::TerminalNode* ReentParser::StatementContext::Cilk_spawn() {
  return getToken(ReentParser::Cilk_spawn, 0);
}

tree::TerminalNode* ReentParser::StatementContext::Cilk_spawn_() {
  return getToken(ReentParser::Cilk_spawn_, 0);
}

ReentParser::Qualified_call_statementContext* ReentParser::StatementContext::qualified_call_statement() {
  return getRuleContext<ReentParser::Qualified_call_statementContext>(0);
}

ReentParser::DeclarationStatementContext* ReentParser::StatementContext::declarationStatement() {
  return getRuleContext<ReentParser::DeclarationStatementContext>(0);
}

ReentParser::ExpressionStatementContext* ReentParser::StatementContext::expressionStatement() {
  return getRuleContext<ReentParser::ExpressionStatementContext>(0);
}

ReentParser::CompoundStatementContext* ReentParser::StatementContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}

ReentParser::SelectionStatementContext* ReentParser::StatementContext::selectionStatement() {
  return getRuleContext<ReentParser::SelectionStatementContext>(0);
}

ReentParser::IterationStatementContext* ReentParser::StatementContext::iterationStatement() {
  return getRuleContext<ReentParser::IterationStatementContext>(0);
}

ReentParser::JumpStatementContext* ReentParser::StatementContext::jumpStatement() {
  return getRuleContext<ReentParser::JumpStatementContext>(0);
}

ReentParser::TryBlockContext* ReentParser::StatementContext::tryBlock() {
  return getRuleContext<ReentParser::TryBlockContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::StatementContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::StatementContext::getRuleIndex() const {
  return ReentParser::RuleStatement;
}

void ReentParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void ReentParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

ReentParser::StatementContext* ReentParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 100, ReentParser::RuleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1056);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1029);
      labeledStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1030);
      cilk_sync();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1031);
      start_chain();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1032);
      start_topology();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1033);
      fill_into_plan();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1034);
      fill_from_plan();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1035);
      plan_critical();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1036);
      reent_statement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1037);
      chain_statement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1038);
      reent_special_call();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1039);
      atomic_block();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1040);
      soft_atomic_block();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1041);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Cilk_spawn

      || _la == ReentParser::Cilk_spawn_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1042);
      spawned_call_statement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1043);
      qualified_call_statement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1044);
      declarationStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1046);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
      case 1: {
        setState(1045);
        attributeSpecifierSeq();
        break;
      }

      default:
        break;
      }
      setState(1054);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
      case 1: {
        setState(1048);
        expressionStatement();
        break;
      }

      case 2: {
        setState(1049);
        compoundStatement();
        break;
      }

      case 3: {
        setState(1050);
        selectionStatement();
        break;
      }

      case 4: {
        setState(1051);
        iterationStatement();
        break;
      }

      case 5: {
        setState(1052);
        jumpStatement();
        break;
      }

      case 6: {
        setState(1053);
        tryBlock();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledStatementContext ------------------------------------------------------------------

ReentParser::LabeledStatementContext::LabeledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::LabeledStatementContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::StatementContext* ReentParser::LabeledStatementContext::statement() {
  return getRuleContext<ReentParser::StatementContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::LabeledStatementContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::LabeledStatementContext::Case() {
  return getToken(ReentParser::Case, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::LabeledStatementContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::LabeledStatementContext::Default() {
  return getToken(ReentParser::Default, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::LabeledStatementContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::LabeledStatementContext::getRuleIndex() const {
  return ReentParser::RuleLabeledStatement;
}

void ReentParser::LabeledStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledStatement(this);
}

void ReentParser::LabeledStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledStatement(this);
}

ReentParser::LabeledStatementContext* ReentParser::labeledStatement() {
  LabeledStatementContext *_localctx = _tracker.createInstance<LabeledStatementContext>(_ctx, getState());
  enterRule(_localctx, 102, ReentParser::RuleLabeledStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1059);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(1058);
      attributeSpecifierSeq();
    }
    setState(1065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Identifier: {
        setState(1061);
        anyIdentifier();
        break;
      }

      case ReentParser::Case: {
        setState(1062);
        match(ReentParser::Case);
        setState(1063);
        constantExpression();
        break;
      }

      case ReentParser::Default: {
        setState(1064);
        match(ReentParser::Default);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1067);
    match(ReentParser::Colon);
    setState(1068);
    statement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cilk_syncContext ------------------------------------------------------------------

ReentParser::Cilk_syncContext::Cilk_syncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Cilk_syncContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::Cilk_syncContext::Cilk_sync() {
  return getToken(ReentParser::Cilk_sync, 0);
}

tree::TerminalNode* ReentParser::Cilk_syncContext::Cilk_sync_() {
  return getToken(ReentParser::Cilk_sync_, 0);
}


size_t ReentParser::Cilk_syncContext::getRuleIndex() const {
  return ReentParser::RuleCilk_sync;
}

void ReentParser::Cilk_syncContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCilk_sync(this);
}

void ReentParser::Cilk_syncContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCilk_sync(this);
}

ReentParser::Cilk_syncContext* ReentParser::cilk_sync() {
  Cilk_syncContext *_localctx = _tracker.createInstance<Cilk_syncContext>(_ctx, getState());
  enterRule(_localctx, 104, ReentParser::RuleCilk_sync);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1070);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Cilk_sync

    || _la == ReentParser::Cilk_sync_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1071);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fill_into_planContext ------------------------------------------------------------------

ReentParser::Fill_into_planContext::Fill_into_planContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Fill_into_planContext::Star() {
  return getToken(ReentParser::Star, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Fill_into_planContext::Less() {
  return getTokens(ReentParser::Less);
}

tree::TerminalNode* ReentParser::Fill_into_planContext::Less(size_t i) {
  return getToken(ReentParser::Less, i);
}

tree::TerminalNode* ReentParser::Fill_into_planContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

std::vector<ReentParser::Reent_fillerContext *> ReentParser::Fill_into_planContext::reent_filler() {
  return getRuleContexts<ReentParser::Reent_fillerContext>();
}

ReentParser::Reent_fillerContext* ReentParser::Fill_into_planContext::reent_filler(size_t i) {
  return getRuleContext<ReentParser::Reent_fillerContext>(i);
}

tree::TerminalNode* ReentParser::Fill_into_planContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

tree::TerminalNode* ReentParser::Fill_into_planContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::Fill_into_planContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Fill_into_planContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::Fill_into_planContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::Fill_into_planContext::getRuleIndex() const {
  return ReentParser::RuleFill_into_plan;
}

void ReentParser::Fill_into_planContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFill_into_plan(this);
}

void ReentParser::Fill_into_planContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFill_into_plan(this);
}

ReentParser::Fill_into_planContext* ReentParser::fill_into_plan() {
  Fill_into_planContext *_localctx = _tracker.createInstance<Fill_into_planContext>(_ctx, getState());
  enterRule(_localctx, 106, ReentParser::RuleFill_into_plan);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1073);
    match(ReentParser::Star);
    setState(1074);
    dynamic_cast<Fill_into_planContext *>(_localctx)->ident = match(ReentParser::Identifier);
    setState(1075);
    match(ReentParser::Less);
    setState(1076);
    match(ReentParser::Less);
    setState(1077);
    match(ReentParser::LeftBracket);
     if (reenterables.find((dynamic_cast<Fill_into_planContext *>(_localctx)->ident != nullptr ? dynamic_cast<Fill_into_planContext *>(_localctx)->ident->getText() : "")) == reenterables.end() || (reenterables[(dynamic_cast<Fill_into_planContext *>(_localctx)->ident != nullptr ? dynamic_cast<Fill_into_planContext *>(_localctx)->ident->getText() : "")] & static_flag) == 0)
    		throw FailedPredicateException(this, "This action can be applied to Static Reenterable Procedure only");
    	
    setState(1079);
    reent_filler();
    setState(1084);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(1080);
      match(ReentParser::Comma);
      setState(1081);
      reent_filler();
      setState(1086);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1087);
    match(ReentParser::RightBracket);
    setState(1088);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Fill_from_planContext ------------------------------------------------------------------

ReentParser::Fill_from_planContext::Fill_from_planContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Fill_from_planContext::Star() {
  return getToken(ReentParser::Star, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Fill_from_planContext::Greater() {
  return getTokens(ReentParser::Greater);
}

tree::TerminalNode* ReentParser::Fill_from_planContext::Greater(size_t i) {
  return getToken(ReentParser::Greater, i);
}

tree::TerminalNode* ReentParser::Fill_from_planContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

std::vector<ReentParser::Reent_readerContext *> ReentParser::Fill_from_planContext::reent_reader() {
  return getRuleContexts<ReentParser::Reent_readerContext>();
}

ReentParser::Reent_readerContext* ReentParser::Fill_from_planContext::reent_reader(size_t i) {
  return getRuleContext<ReentParser::Reent_readerContext>(i);
}

tree::TerminalNode* ReentParser::Fill_from_planContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

tree::TerminalNode* ReentParser::Fill_from_planContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::Fill_from_planContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Fill_from_planContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::Fill_from_planContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::Fill_from_planContext::getRuleIndex() const {
  return ReentParser::RuleFill_from_plan;
}

void ReentParser::Fill_from_planContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFill_from_plan(this);
}

void ReentParser::Fill_from_planContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFill_from_plan(this);
}

ReentParser::Fill_from_planContext* ReentParser::fill_from_plan() {
  Fill_from_planContext *_localctx = _tracker.createInstance<Fill_from_planContext>(_ctx, getState());
  enterRule(_localctx, 108, ReentParser::RuleFill_from_plan);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1090);
    match(ReentParser::Star);
    setState(1091);
    dynamic_cast<Fill_from_planContext *>(_localctx)->ident = match(ReentParser::Identifier);
    setState(1092);
    match(ReentParser::Greater);
    setState(1093);
    match(ReentParser::Greater);
    setState(1094);
    match(ReentParser::LeftBracket);
     if (reenterables.find((dynamic_cast<Fill_from_planContext *>(_localctx)->ident != nullptr ? dynamic_cast<Fill_from_planContext *>(_localctx)->ident->getText() : "")) == reenterables.end() || (reenterables[(dynamic_cast<Fill_from_planContext *>(_localctx)->ident != nullptr ? dynamic_cast<Fill_from_planContext *>(_localctx)->ident->getText() : "")] & static_flag) == 0)
    		throw FailedPredicateException(this, "This action can be applied to Static Reenterable Procedure only");
    	
    setState(1096);
    reent_reader();
    setState(1101);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(1097);
      match(ReentParser::Comma);
      setState(1098);
      reent_reader();
      setState(1103);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1104);
    match(ReentParser::RightBracket);
    setState(1105);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_fillerContext ------------------------------------------------------------------

ReentParser::Reent_fillerContext::Reent_fillerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_fillerContext::Underscore() {
  return getToken(ReentParser::Underscore, 0);
}

ReentParser::Reent_filler_arrayContext* ReentParser::Reent_fillerContext::reent_filler_array() {
  return getRuleContext<ReentParser::Reent_filler_arrayContext>(0);
}

ReentParser::ExpressionContext* ReentParser::Reent_fillerContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}


size_t ReentParser::Reent_fillerContext::getRuleIndex() const {
  return ReentParser::RuleReent_filler;
}

void ReentParser::Reent_fillerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_filler(this);
}

void ReentParser::Reent_fillerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_filler(this);
}

ReentParser::Reent_fillerContext* ReentParser::reent_filler() {
  Reent_fillerContext *_localctx = _tracker.createInstance<Reent_fillerContext>(_ctx, getState());
  enterRule(_localctx, 110, ReentParser::RuleReent_filler);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1110);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1107);
      match(ReentParser::Underscore);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1108);
      reent_filler_array();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1109);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_readerContext ------------------------------------------------------------------

ReentParser::Reent_readerContext::Reent_readerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_readerContext::Underscore() {
  return getToken(ReentParser::Underscore, 0);
}

ReentParser::Reent_filler_arrayContext* ReentParser::Reent_readerContext::reent_filler_array() {
  return getRuleContext<ReentParser::Reent_filler_arrayContext>(0);
}

tree::TerminalNode* ReentParser::Reent_readerContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}


size_t ReentParser::Reent_readerContext::getRuleIndex() const {
  return ReentParser::RuleReent_reader;
}

void ReentParser::Reent_readerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_reader(this);
}

void ReentParser::Reent_readerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_reader(this);
}

ReentParser::Reent_readerContext* ReentParser::reent_reader() {
  Reent_readerContext *_localctx = _tracker.createInstance<Reent_readerContext>(_ctx, getState());
  enterRule(_localctx, 112, ReentParser::RuleReent_reader);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1115);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1112);
      match(ReentParser::Underscore);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1113);
      reent_filler_array();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1114);
      match(ReentParser::Identifier);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_filler_arrayContext ------------------------------------------------------------------

ReentParser::Reent_filler_arrayContext::Reent_filler_arrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_filler_arrayContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Reent_filler_arrayContext::LeftBracket() {
  return getTokens(ReentParser::LeftBracket);
}

tree::TerminalNode* ReentParser::Reent_filler_arrayContext::LeftBracket(size_t i) {
  return getToken(ReentParser::LeftBracket, i);
}

std::vector<tree::TerminalNode *> ReentParser::Reent_filler_arrayContext::RightBracket() {
  return getTokens(ReentParser::RightBracket);
}

tree::TerminalNode* ReentParser::Reent_filler_arrayContext::RightBracket(size_t i) {
  return getToken(ReentParser::RightBracket, i);
}


size_t ReentParser::Reent_filler_arrayContext::getRuleIndex() const {
  return ReentParser::RuleReent_filler_array;
}

void ReentParser::Reent_filler_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_filler_array(this);
}

void ReentParser::Reent_filler_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_filler_array(this);
}

ReentParser::Reent_filler_arrayContext* ReentParser::reent_filler_array() {
  Reent_filler_arrayContext *_localctx = _tracker.createInstance<Reent_filler_arrayContext>(_ctx, getState());
  enterRule(_localctx, 114, ReentParser::RuleReent_filler_array);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1117);
    match(ReentParser::Identifier);
    setState(1120); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1118);
      match(ReentParser::LeftBracket);
      setState(1119);
      match(ReentParser::RightBracket);
      setState(1122); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ReentParser::LeftBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_statementContext ------------------------------------------------------------------

ReentParser::Reent_statementContext::Reent_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Plan_firstContext* ReentParser::Reent_statementContext::plan_first() {
  return getRuleContext<ReentParser::Plan_firstContext>(0);
}

ReentParser::Plan_lastContext* ReentParser::Reent_statementContext::plan_last() {
  return getRuleContext<ReentParser::Plan_lastContext>(0);
}

ReentParser::Plan_stopContext* ReentParser::Reent_statementContext::plan_stop() {
  return getRuleContext<ReentParser::Plan_stopContext>(0);
}

ReentParser::Clear_planContext* ReentParser::Reent_statementContext::clear_plan() {
  return getRuleContext<ReentParser::Clear_planContext>(0);
}

ReentParser::Plan_get_firstContext* ReentParser::Reent_statementContext::plan_get_first() {
  return getRuleContext<ReentParser::Plan_get_firstContext>(0);
}

ReentParser::Plan_get_lastContext* ReentParser::Reent_statementContext::plan_get_last() {
  return getRuleContext<ReentParser::Plan_get_lastContext>(0);
}

ReentParser::Plan_registerContext* ReentParser::Reent_statementContext::plan_register() {
  return getRuleContext<ReentParser::Plan_registerContext>(0);
}

ReentParser::Plan_registered_barrierContext* ReentParser::Reent_statementContext::plan_registered_barrier() {
  return getRuleContext<ReentParser::Plan_registered_barrierContext>(0);
}

ReentParser::Plan_group_firstContext* ReentParser::Reent_statementContext::plan_group_first() {
  return getRuleContext<ReentParser::Plan_group_firstContext>(0);
}

ReentParser::Plan_group_lastContext* ReentParser::Reent_statementContext::plan_group_last() {
  return getRuleContext<ReentParser::Plan_group_lastContext>(0);
}

ReentParser::Plan_group_parallelizeContext* ReentParser::Reent_statementContext::plan_group_parallelize() {
  return getRuleContext<ReentParser::Plan_group_parallelizeContext>(0);
}

ReentParser::Plan_group_vectorizeContext* ReentParser::Reent_statementContext::plan_group_vectorize() {
  return getRuleContext<ReentParser::Plan_group_vectorizeContext>(0);
}

ReentParser::Plan_group_atomizeContext* ReentParser::Reent_statementContext::plan_group_atomize() {
  return getRuleContext<ReentParser::Plan_group_atomizeContext>(0);
}


size_t ReentParser::Reent_statementContext::getRuleIndex() const {
  return ReentParser::RuleReent_statement;
}

void ReentParser::Reent_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_statement(this);
}

void ReentParser::Reent_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_statement(this);
}

ReentParser::Reent_statementContext* ReentParser::reent_statement() {
  Reent_statementContext *_localctx = _tracker.createInstance<Reent_statementContext>(_ctx, getState());
  enterRule(_localctx, 116, ReentParser::RuleReent_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1124);

    if (!((in_reenterable || in_chain))) throw FailedPredicateException(this, "(in_reenterable || in_chain)");
    setState(1138);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Plan_first: {
        setState(1125);
        plan_first();
        break;
      }

      case ReentParser::Plan_last: {
        setState(1126);
        plan_last();
        break;
      }

      case ReentParser::Plan_stop: {
        setState(1127);
        plan_stop();
        break;
      }

      case ReentParser::Clear_plan: {
        setState(1128);
        clear_plan();
        break;
      }

      case ReentParser::Plan_get_first: {
        setState(1129);
        plan_get_first();
        break;
      }

      case ReentParser::Plan_get_last: {
        setState(1130);
        plan_get_last();
        break;
      }

      case ReentParser::Plan_register: {
        setState(1131);
        plan_register();
        break;
      }

      case ReentParser::Plan_registered_barrier: {
        setState(1132);
        plan_registered_barrier();
        break;
      }

      case ReentParser::Plan_group_first: {
        setState(1133);
        plan_group_first();
        break;
      }

      case ReentParser::Plan_group_last: {
        setState(1134);
        plan_group_last();
        break;
      }

      case ReentParser::Plan_group_parallelize: {
        setState(1135);
        plan_group_parallelize();
        break;
      }

      case ReentParser::Plan_group_vectorize: {
        setState(1136);
        plan_group_vectorize();
        break;
      }

      case ReentParser::Plan_group_atomize: {
        setState(1137);
        plan_group_atomize();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chain_statementContext ------------------------------------------------------------------

ReentParser::Chain_statementContext::Chain_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Throw_firstContext* ReentParser::Chain_statementContext::throw_first() {
  return getRuleContext<ReentParser::Throw_firstContext>(0);
}

ReentParser::Throw_lastContext* ReentParser::Chain_statementContext::throw_last() {
  return getRuleContext<ReentParser::Throw_lastContext>(0);
}


size_t ReentParser::Chain_statementContext::getRuleIndex() const {
  return ReentParser::RuleChain_statement;
}

void ReentParser::Chain_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChain_statement(this);
}

void ReentParser::Chain_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChain_statement(this);
}

ReentParser::Chain_statementContext* ReentParser::chain_statement() {
  Chain_statementContext *_localctx = _tracker.createInstance<Chain_statementContext>(_ctx, getState());
  enterRule(_localctx, 118, ReentParser::RuleChain_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1140);

    if (!(in_chain)) throw FailedPredicateException(this, "in_chain");
    setState(1143);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Throw_first: {
        setState(1141);
        throw_first();
        break;
      }

      case ReentParser::Throw_last: {
        setState(1142);
        throw_last();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Atomic_blockContext ------------------------------------------------------------------

ReentParser::Atomic_blockContext::Atomic_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Atomic_blockContext::Plan_atomize() {
  return getToken(ReentParser::Plan_atomize, 0);
}

ReentParser::CompoundStatementContext* ReentParser::Atomic_blockContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}


size_t ReentParser::Atomic_blockContext::getRuleIndex() const {
  return ReentParser::RuleAtomic_block;
}

void ReentParser::Atomic_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAtomic_block(this);
}

void ReentParser::Atomic_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAtomic_block(this);
}

ReentParser::Atomic_blockContext* ReentParser::atomic_block() {
  Atomic_blockContext *_localctx = _tracker.createInstance<Atomic_blockContext>(_ctx, getState());
  enterRule(_localctx, 120, ReentParser::RuleAtomic_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1145);

    if (!((!in_reenterable && !in_chain))) throw FailedPredicateException(this, "(!in_reenterable && !in_chain)");
    setState(1146);
    match(ReentParser::Plan_atomize);
    setState(1147);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Soft_atomic_blockContext ------------------------------------------------------------------

ReentParser::Soft_atomic_blockContext::Soft_atomic_blockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Soft_atomic_blockContext::Transaction_atomic() {
  return getToken(ReentParser::Transaction_atomic, 0);
}

tree::TerminalNode* ReentParser::Soft_atomic_blockContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Soft_atomic_blockContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Soft_atomic_blockContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::CompoundStatementContext* ReentParser::Soft_atomic_blockContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}


size_t ReentParser::Soft_atomic_blockContext::getRuleIndex() const {
  return ReentParser::RuleSoft_atomic_block;
}

void ReentParser::Soft_atomic_blockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSoft_atomic_block(this);
}

void ReentParser::Soft_atomic_blockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSoft_atomic_block(this);
}

ReentParser::Soft_atomic_blockContext* ReentParser::soft_atomic_block() {
  Soft_atomic_blockContext *_localctx = _tracker.createInstance<Soft_atomic_blockContext>(_ctx, getState());
  enterRule(_localctx, 122, ReentParser::RuleSoft_atomic_block);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1149);
    match(ReentParser::Transaction_atomic);
    setState(1150);
    match(ReentParser::LeftParen);
    setState(1151);
    primaryExpression();
    setState(1152);
    match(ReentParser::RightParen);
    setState(1153);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_firstContext ------------------------------------------------------------------

ReentParser::Plan_firstContext::Plan_firstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_firstContext::Plan_first() {
  return getToken(ReentParser::Plan_first, 0);
}

tree::TerminalNode* ReentParser::Plan_firstContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::Planning_paramsContext* ReentParser::Plan_firstContext::planning_params() {
  return getRuleContext<ReentParser::Planning_paramsContext>(0);
}

tree::TerminalNode* ReentParser::Plan_firstContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_firstContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_firstContext::getRuleIndex() const {
  return ReentParser::RulePlan_first;
}

void ReentParser::Plan_firstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_first(this);
}

void ReentParser::Plan_firstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_first(this);
}

ReentParser::Plan_firstContext* ReentParser::plan_first() {
  Plan_firstContext *_localctx = _tracker.createInstance<Plan_firstContext>(_ctx, getState());
  enterRule(_localctx, 124, ReentParser::RulePlan_first);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1155);
    match(ReentParser::Plan_first);
    setState(1156);
    match(ReentParser::LeftParen);
    setState(1157);
    planning_params();
    setState(1158);
    match(ReentParser::RightParen);
    setState(1159);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_get_firstContext ------------------------------------------------------------------

ReentParser::Plan_get_firstContext::Plan_get_firstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_get_firstContext::Plan_get_first() {
  return getToken(ReentParser::Plan_get_first, 0);
}

tree::TerminalNode* ReentParser::Plan_get_firstContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::Plan_get_firstContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Plan_get_firstContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_get_firstContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_get_firstContext::getRuleIndex() const {
  return ReentParser::RulePlan_get_first;
}

void ReentParser::Plan_get_firstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_get_first(this);
}

void ReentParser::Plan_get_firstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_get_first(this);
}

ReentParser::Plan_get_firstContext* ReentParser::plan_get_first() {
  Plan_get_firstContext *_localctx = _tracker.createInstance<Plan_get_firstContext>(_ctx, getState());
  enterRule(_localctx, 126, ReentParser::RulePlan_get_first);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1161);
    match(ReentParser::Plan_get_first);
    setState(1162);
    match(ReentParser::LeftParen);
    setState(1163);
    expression();
    setState(1164);
    match(ReentParser::RightParen);
    setState(1165);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_lastContext ------------------------------------------------------------------

ReentParser::Plan_lastContext::Plan_lastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_lastContext::Plan_last() {
  return getToken(ReentParser::Plan_last, 0);
}

tree::TerminalNode* ReentParser::Plan_lastContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::Planning_paramsContext* ReentParser::Plan_lastContext::planning_params() {
  return getRuleContext<ReentParser::Planning_paramsContext>(0);
}

tree::TerminalNode* ReentParser::Plan_lastContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_lastContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_lastContext::getRuleIndex() const {
  return ReentParser::RulePlan_last;
}

void ReentParser::Plan_lastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_last(this);
}

void ReentParser::Plan_lastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_last(this);
}

ReentParser::Plan_lastContext* ReentParser::plan_last() {
  Plan_lastContext *_localctx = _tracker.createInstance<Plan_lastContext>(_ctx, getState());
  enterRule(_localctx, 128, ReentParser::RulePlan_last);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1167);
    match(ReentParser::Plan_last);
    setState(1168);
    match(ReentParser::LeftParen);
    setState(1169);
    planning_params();
    setState(1170);
    match(ReentParser::RightParen);
    setState(1171);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_get_lastContext ------------------------------------------------------------------

ReentParser::Plan_get_lastContext::Plan_get_lastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_get_lastContext::Plan_get_last() {
  return getToken(ReentParser::Plan_get_last, 0);
}

tree::TerminalNode* ReentParser::Plan_get_lastContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::Plan_get_lastContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Plan_get_lastContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_get_lastContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_get_lastContext::getRuleIndex() const {
  return ReentParser::RulePlan_get_last;
}

void ReentParser::Plan_get_lastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_get_last(this);
}

void ReentParser::Plan_get_lastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_get_last(this);
}

ReentParser::Plan_get_lastContext* ReentParser::plan_get_last() {
  Plan_get_lastContext *_localctx = _tracker.createInstance<Plan_get_lastContext>(_ctx, getState());
  enterRule(_localctx, 130, ReentParser::RulePlan_get_last);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1173);
    match(ReentParser::Plan_get_last);
    setState(1174);
    match(ReentParser::LeftParen);
    setState(1175);
    expression();
    setState(1176);
    match(ReentParser::RightParen);
    setState(1177);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_registerContext ------------------------------------------------------------------

ReentParser::Plan_registerContext::Plan_registerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_registerContext::Plan_register() {
  return getToken(ReentParser::Plan_register, 0);
}

tree::TerminalNode* ReentParser::Plan_registerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::Plan_registerContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::Plan_registerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_registerContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_registerContext::getRuleIndex() const {
  return ReentParser::RulePlan_register;
}

void ReentParser::Plan_registerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_register(this);
}

void ReentParser::Plan_registerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_register(this);
}

ReentParser::Plan_registerContext* ReentParser::plan_register() {
  Plan_registerContext *_localctx = _tracker.createInstance<Plan_registerContext>(_ctx, getState());
  enterRule(_localctx, 132, ReentParser::RulePlan_register);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1179);
    match(ReentParser::Plan_register);
    setState(1180);
    match(ReentParser::LeftParen);
    setState(1181);
    anyIdentifier();
    setState(1182);
    match(ReentParser::RightParen);
    setState(1183);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_registered_barrierContext ------------------------------------------------------------------

ReentParser::Plan_registered_barrierContext::Plan_registered_barrierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_registered_barrierContext::Plan_registered_barrier() {
  return getToken(ReentParser::Plan_registered_barrier, 0);
}

tree::TerminalNode* ReentParser::Plan_registered_barrierContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::Plan_registered_barrierContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::Plan_registered_barrierContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_registered_barrierContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_registered_barrierContext::getRuleIndex() const {
  return ReentParser::RulePlan_registered_barrier;
}

void ReentParser::Plan_registered_barrierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_registered_barrier(this);
}

void ReentParser::Plan_registered_barrierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_registered_barrier(this);
}

ReentParser::Plan_registered_barrierContext* ReentParser::plan_registered_barrier() {
  Plan_registered_barrierContext *_localctx = _tracker.createInstance<Plan_registered_barrierContext>(_ctx, getState());
  enterRule(_localctx, 134, ReentParser::RulePlan_registered_barrier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1185);
    match(ReentParser::Plan_registered_barrier);
    setState(1186);
    match(ReentParser::LeftParen);
    setState(1187);
    anyIdentifier();
    setState(1188);
    match(ReentParser::RightParen);
    setState(1189);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_criticalContext ------------------------------------------------------------------

ReentParser::Plan_criticalContext::Plan_criticalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_criticalContext::Plan_critical() {
  return getToken(ReentParser::Plan_critical, 0);
}

tree::TerminalNode* ReentParser::Plan_criticalContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::Plan_criticalContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::Plan_criticalContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::CompoundStatementContext* ReentParser::Plan_criticalContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}


size_t ReentParser::Plan_criticalContext::getRuleIndex() const {
  return ReentParser::RulePlan_critical;
}

void ReentParser::Plan_criticalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_critical(this);
}

void ReentParser::Plan_criticalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_critical(this);
}

ReentParser::Plan_criticalContext* ReentParser::plan_critical() {
  Plan_criticalContext *_localctx = _tracker.createInstance<Plan_criticalContext>(_ctx, getState());
  enterRule(_localctx, 136, ReentParser::RulePlan_critical);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1191);
    match(ReentParser::Plan_critical);
    setState(1192);
    match(ReentParser::LeftParen);
    setState(1193);
    anyIdentifier();
    setState(1194);
    match(ReentParser::RightParen);
    setState(1195);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_stopContext ------------------------------------------------------------------

ReentParser::Plan_stopContext::Plan_stopContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_stopContext::Plan_stop() {
  return getToken(ReentParser::Plan_stop, 0);
}

tree::TerminalNode* ReentParser::Plan_stopContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_stopContext::getRuleIndex() const {
  return ReentParser::RulePlan_stop;
}

void ReentParser::Plan_stopContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_stop(this);
}

void ReentParser::Plan_stopContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_stop(this);
}

ReentParser::Plan_stopContext* ReentParser::plan_stop() {
  Plan_stopContext *_localctx = _tracker.createInstance<Plan_stopContext>(_ctx, getState());
  enterRule(_localctx, 138, ReentParser::RulePlan_stop);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1197);
    match(ReentParser::Plan_stop);
    setState(1198);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Clear_planContext ------------------------------------------------------------------

ReentParser::Clear_planContext::Clear_planContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Clear_planContext::Clear_plan() {
  return getToken(ReentParser::Clear_plan, 0);
}

tree::TerminalNode* ReentParser::Clear_planContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Clear_planContext::getRuleIndex() const {
  return ReentParser::RuleClear_plan;
}

void ReentParser::Clear_planContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClear_plan(this);
}

void ReentParser::Clear_planContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClear_plan(this);
}

ReentParser::Clear_planContext* ReentParser::clear_plan() {
  Clear_planContext *_localctx = _tracker.createInstance<Clear_planContext>(_ctx, getState());
  enterRule(_localctx, 140, ReentParser::RuleClear_plan);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1200);
    match(ReentParser::Clear_plan);
    setState(1201);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_group_firstContext ------------------------------------------------------------------

ReentParser::Plan_group_firstContext::Plan_group_firstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_group_firstContext::Plan_group_first() {
  return getToken(ReentParser::Plan_group_first, 0);
}

tree::TerminalNode* ReentParser::Plan_group_firstContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_group_firstContext::getRuleIndex() const {
  return ReentParser::RulePlan_group_first;
}

void ReentParser::Plan_group_firstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_group_first(this);
}

void ReentParser::Plan_group_firstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_group_first(this);
}

ReentParser::Plan_group_firstContext* ReentParser::plan_group_first() {
  Plan_group_firstContext *_localctx = _tracker.createInstance<Plan_group_firstContext>(_ctx, getState());
  enterRule(_localctx, 142, ReentParser::RulePlan_group_first);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1203);
    match(ReentParser::Plan_group_first);
    setState(1204);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_group_lastContext ------------------------------------------------------------------

ReentParser::Plan_group_lastContext::Plan_group_lastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_group_lastContext::Plan_group_last() {
  return getToken(ReentParser::Plan_group_last, 0);
}

tree::TerminalNode* ReentParser::Plan_group_lastContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_group_lastContext::getRuleIndex() const {
  return ReentParser::RulePlan_group_last;
}

void ReentParser::Plan_group_lastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_group_last(this);
}

void ReentParser::Plan_group_lastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_group_last(this);
}

ReentParser::Plan_group_lastContext* ReentParser::plan_group_last() {
  Plan_group_lastContext *_localctx = _tracker.createInstance<Plan_group_lastContext>(_ctx, getState());
  enterRule(_localctx, 144, ReentParser::RulePlan_group_last);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1206);
    match(ReentParser::Plan_group_last);
    setState(1207);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_group_parallelizeContext ------------------------------------------------------------------

ReentParser::Plan_group_parallelizeContext::Plan_group_parallelizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_group_parallelizeContext::Plan_group_parallelize() {
  return getToken(ReentParser::Plan_group_parallelize, 0);
}

tree::TerminalNode* ReentParser::Plan_group_parallelizeContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_group_parallelizeContext::getRuleIndex() const {
  return ReentParser::RulePlan_group_parallelize;
}

void ReentParser::Plan_group_parallelizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_group_parallelize(this);
}

void ReentParser::Plan_group_parallelizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_group_parallelize(this);
}

ReentParser::Plan_group_parallelizeContext* ReentParser::plan_group_parallelize() {
  Plan_group_parallelizeContext *_localctx = _tracker.createInstance<Plan_group_parallelizeContext>(_ctx, getState());
  enterRule(_localctx, 146, ReentParser::RulePlan_group_parallelize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1209);
    match(ReentParser::Plan_group_parallelize);
    setState(1210);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_group_atomizeContext ------------------------------------------------------------------

ReentParser::Plan_group_atomizeContext::Plan_group_atomizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_group_atomizeContext::Plan_group_atomize() {
  return getToken(ReentParser::Plan_group_atomize, 0);
}

tree::TerminalNode* ReentParser::Plan_group_atomizeContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_group_atomizeContext::getRuleIndex() const {
  return ReentParser::RulePlan_group_atomize;
}

void ReentParser::Plan_group_atomizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_group_atomize(this);
}

void ReentParser::Plan_group_atomizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_group_atomize(this);
}

ReentParser::Plan_group_atomizeContext* ReentParser::plan_group_atomize() {
  Plan_group_atomizeContext *_localctx = _tracker.createInstance<Plan_group_atomizeContext>(_ctx, getState());
  enterRule(_localctx, 148, ReentParser::RulePlan_group_atomize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1212);
    match(ReentParser::Plan_group_atomize);
    setState(1213);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_group_soft_atomizeContext ------------------------------------------------------------------

ReentParser::Plan_group_soft_atomizeContext::Plan_group_soft_atomizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_group_soft_atomizeContext::Plan_group_soft_atomize() {
  return getToken(ReentParser::Plan_group_soft_atomize, 0);
}

tree::TerminalNode* ReentParser::Plan_group_soft_atomizeContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_group_soft_atomizeContext::getRuleIndex() const {
  return ReentParser::RulePlan_group_soft_atomize;
}

void ReentParser::Plan_group_soft_atomizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_group_soft_atomize(this);
}

void ReentParser::Plan_group_soft_atomizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_group_soft_atomize(this);
}

ReentParser::Plan_group_soft_atomizeContext* ReentParser::plan_group_soft_atomize() {
  Plan_group_soft_atomizeContext *_localctx = _tracker.createInstance<Plan_group_soft_atomizeContext>(_ctx, getState());
  enterRule(_localctx, 150, ReentParser::RulePlan_group_soft_atomize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1215);
    match(ReentParser::Plan_group_soft_atomize);
    setState(1216);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_group_vectorizeContext ------------------------------------------------------------------

ReentParser::Plan_group_vectorizeContext::Plan_group_vectorizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_group_vectorizeContext::Plan_group_vectorize() {
  return getToken(ReentParser::Plan_group_vectorize, 0);
}

tree::TerminalNode* ReentParser::Plan_group_vectorizeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::Plan_group_vectorizeContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Plan_group_vectorizeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Plan_group_vectorizeContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Plan_group_vectorizeContext::getRuleIndex() const {
  return ReentParser::RulePlan_group_vectorize;
}

void ReentParser::Plan_group_vectorizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_group_vectorize(this);
}

void ReentParser::Plan_group_vectorizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_group_vectorize(this);
}

ReentParser::Plan_group_vectorizeContext* ReentParser::plan_group_vectorize() {
  Plan_group_vectorizeContext *_localctx = _tracker.createInstance<Plan_group_vectorizeContext>(_ctx, getState());
  enterRule(_localctx, 152, ReentParser::RulePlan_group_vectorize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1218);
    match(ReentParser::Plan_group_vectorize);

    		if (!allow_vectorized)
    			throw FailedPredicateException(this, "'plan_group_vectorize' without '#pragma plan vectorized'");
    	
    setState(1220);
    match(ReentParser::LeftParen);
    setState(1221);
    assignmentExpression();
    setState(1222);
    match(ReentParser::RightParen);
    setState(1223);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_firstContext ------------------------------------------------------------------

ReentParser::Throw_firstContext::Throw_firstContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Throw_firstContext::Throw_first() {
  return getToken(ReentParser::Throw_first, 0);
}

tree::TerminalNode* ReentParser::Throw_firstContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::Planning_paramsContext* ReentParser::Throw_firstContext::planning_params() {
  return getRuleContext<ReentParser::Planning_paramsContext>(0);
}

tree::TerminalNode* ReentParser::Throw_firstContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Throw_firstContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Throw_firstContext::getRuleIndex() const {
  return ReentParser::RuleThrow_first;
}

void ReentParser::Throw_firstContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_first(this);
}

void ReentParser::Throw_firstContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_first(this);
}

ReentParser::Throw_firstContext* ReentParser::throw_first() {
  Throw_firstContext *_localctx = _tracker.createInstance<Throw_firstContext>(_ctx, getState());
  enterRule(_localctx, 154, ReentParser::RuleThrow_first);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1225);
    match(ReentParser::Throw_first);
    setState(1226);
    match(ReentParser::LeftParen);
    setState(1227);
    planning_params();
    setState(1228);
    match(ReentParser::RightParen);
    setState(1229);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Throw_lastContext ------------------------------------------------------------------

ReentParser::Throw_lastContext::Throw_lastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Throw_lastContext::Throw_last() {
  return getToken(ReentParser::Throw_last, 0);
}

tree::TerminalNode* ReentParser::Throw_lastContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::Planning_paramsContext* ReentParser::Throw_lastContext::planning_params() {
  return getRuleContext<ReentParser::Planning_paramsContext>(0);
}

tree::TerminalNode* ReentParser::Throw_lastContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Throw_lastContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Throw_lastContext::getRuleIndex() const {
  return ReentParser::RuleThrow_last;
}

void ReentParser::Throw_lastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrow_last(this);
}

void ReentParser::Throw_lastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrow_last(this);
}

ReentParser::Throw_lastContext* ReentParser::throw_last() {
  Throw_lastContext *_localctx = _tracker.createInstance<Throw_lastContext>(_ctx, getState());
  enterRule(_localctx, 156, ReentParser::RuleThrow_last);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1231);
    match(ReentParser::Throw_last);
    setState(1232);
    match(ReentParser::LeftParen);
    setState(1233);
    planning_params();
    setState(1234);
    match(ReentParser::RightParen);
    setState(1235);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Planning_paramsContext ------------------------------------------------------------------

ReentParser::Planning_paramsContext::Planning_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AssignmentExpressionContext *> ReentParser::Planning_paramsContext::assignmentExpression() {
  return getRuleContexts<ReentParser::AssignmentExpressionContext>();
}

ReentParser::AssignmentExpressionContext* ReentParser::Planning_paramsContext::assignmentExpression(size_t i) {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(i);
}

std::vector<ReentParser::Reent_parameter_cutContext *> ReentParser::Planning_paramsContext::reent_parameter_cut() {
  return getRuleContexts<ReentParser::Reent_parameter_cutContext>();
}

ReentParser::Reent_parameter_cutContext* ReentParser::Planning_paramsContext::reent_parameter_cut(size_t i) {
  return getRuleContext<ReentParser::Reent_parameter_cutContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::Planning_paramsContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::Planning_paramsContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::Planning_paramsContext::getRuleIndex() const {
  return ReentParser::RulePlanning_params;
}

void ReentParser::Planning_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlanning_params(this);
}

void ReentParser::Planning_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlanning_params(this);
}

ReentParser::Planning_paramsContext* ReentParser::planning_params() {
  Planning_paramsContext *_localctx = _tracker.createInstance<Planning_paramsContext>(_ctx, getState());
  enterRule(_localctx, 158, ReentParser::RulePlanning_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1237);
    assignmentExpression();
    setState(1239);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Not) {
      setState(1238);
      reent_parameter_cut();
    }
    setState(1248);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(1241);
      match(ReentParser::Comma);
      setState(1242);
      assignmentExpression();
      setState(1244);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Not) {
        setState(1243);
        reent_parameter_cut();
      }
      setState(1250);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_parameter_cutContext ------------------------------------------------------------------

ReentParser::Reent_parameter_cutContext::Reent_parameter_cutContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_parameter_cutContext::Not() {
  return getToken(ReentParser::Not, 0);
}


size_t ReentParser::Reent_parameter_cutContext::getRuleIndex() const {
  return ReentParser::RuleReent_parameter_cut;
}

void ReentParser::Reent_parameter_cutContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_parameter_cut(this);
}

void ReentParser::Reent_parameter_cutContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_parameter_cut(this);
}

ReentParser::Reent_parameter_cutContext* ReentParser::reent_parameter_cut() {
  Reent_parameter_cutContext *_localctx = _tracker.createInstance<Reent_parameter_cutContext>(_ctx, getState());
  enterRule(_localctx, 160, ReentParser::RuleReent_parameter_cut);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1251);
    match(ReentParser::Not);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_special_callContext ------------------------------------------------------------------

ReentParser::Reent_special_callContext::Reent_special_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Reent_continue_any_callContext* ReentParser::Reent_special_callContext::reent_continue_any_call() {
  return getRuleContext<ReentParser::Reent_continue_any_callContext>(0);
}

ReentParser::Reent_compact_continueContext* ReentParser::Reent_special_callContext::reent_compact_continue() {
  return getRuleContext<ReentParser::Reent_compact_continueContext>(0);
}

ReentParser::Reent_np_callContext* ReentParser::Reent_special_callContext::reent_np_call() {
  return getRuleContext<ReentParser::Reent_np_callContext>(0);
}


size_t ReentParser::Reent_special_callContext::getRuleIndex() const {
  return ReentParser::RuleReent_special_call;
}

void ReentParser::Reent_special_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_special_call(this);
}

void ReentParser::Reent_special_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_special_call(this);
}

ReentParser::Reent_special_callContext* ReentParser::reent_special_call() {
  Reent_special_callContext *_localctx = _tracker.createInstance<Reent_special_callContext>(_ctx, getState());
  enterRule(_localctx, 162, ReentParser::RuleReent_special_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1256);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1253);
      reent_continue_any_call();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1254);
      reent_compact_continue();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1255);
      reent_np_call();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_continue_any_callContext ------------------------------------------------------------------

ReentParser::Reent_continue_any_callContext::Reent_continue_any_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_continue_any_callContext::Continue() {
  return getToken(ReentParser::Continue, 0);
}

tree::TerminalNode* ReentParser::Reent_continue_any_callContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_continue_any_callContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_continue_any_callContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::Reent_continue_any_callContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::ExpressionContext* ReentParser::Reent_continue_any_callContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_continue_any_callContext::Div() {
  return getToken(ReentParser::Div, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Reent_continue_any_callContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}


size_t ReentParser::Reent_continue_any_callContext::getRuleIndex() const {
  return ReentParser::RuleReent_continue_any_call;
}

void ReentParser::Reent_continue_any_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_continue_any_call(this);
}

void ReentParser::Reent_continue_any_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_continue_any_call(this);
}

ReentParser::Reent_continue_any_callContext* ReentParser::reent_continue_any_call() {
  Reent_continue_any_callContext *_localctx = _tracker.createInstance<Reent_continue_any_callContext>(_ctx, getState());
  enterRule(_localctx, 164, ReentParser::RuleReent_continue_any_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1258);
    match(ReentParser::Continue);
    setState(1259);
    dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident = anyIdentifier();
     if (reenterables.find((dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident->start, dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident->stop) : nullptr)) == reenterables.end() || (reenterables[(dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident->start, dynamic_cast<Reent_continue_any_callContext *>(_localctx)->ident->stop) : nullptr)] & static_flag) == 0)
    		throw FailedPredicateException(this, "Continue can be applied to Static Reenterable Procedure only");
    	
    setState(1261);
    match(ReentParser::LeftParen);
    setState(1263);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(1262);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1265);
    match(ReentParser::RightParen);
    setState(1268);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Div) {
      setState(1266);
      match(ReentParser::Div);
      setState(1267);
      primaryExpression();
    }
    setState(1270);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_compact_continueContext ------------------------------------------------------------------

ReentParser::Reent_compact_continueContext::Reent_compact_continueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_compact_continueContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_compact_continueContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::Reent_compact_continueContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

tree::TerminalNode* ReentParser::Reent_compact_continueContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_compact_continueContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::Reent_compact_continueContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::ExpressionContext* ReentParser::Reent_compact_continueContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_compact_continueContext::Div() {
  return getToken(ReentParser::Div, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Reent_compact_continueContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}


size_t ReentParser::Reent_compact_continueContext::getRuleIndex() const {
  return ReentParser::RuleReent_compact_continue;
}

void ReentParser::Reent_compact_continueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_compact_continue(this);
}

void ReentParser::Reent_compact_continueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_compact_continue(this);
}

ReentParser::Reent_compact_continueContext* ReentParser::reent_compact_continue() {
  Reent_compact_continueContext *_localctx = _tracker.createInstance<Reent_compact_continueContext>(_ctx, getState());
  enterRule(_localctx, 166, ReentParser::RuleReent_compact_continue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1272);
    dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident = anyIdentifier();
    setState(1273);
    match(ReentParser::LeftParen);
    setState(1274);
    match(ReentParser::LeftBracket);
     if (reenterables.find((dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident->start, dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident->stop) : nullptr)) == reenterables.end() || (reenterables[(dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident->start, dynamic_cast<Reent_compact_continueContext *>(_localctx)->ident->stop) : nullptr)] & static_flag) == 0)
    		throw FailedPredicateException(this, "Continuing ([Call]) can be applied to Static Reenterable Procedure only");
    	
    setState(1277);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
    case 1: {
      setState(1276);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1279);
    match(ReentParser::RightBracket);
    setState(1280);
    match(ReentParser::RightParen);
    setState(1283);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Div) {
      setState(1281);
      match(ReentParser::Div);
      setState(1282);
      primaryExpression();
    }
    setState(1285);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_np_callContext ------------------------------------------------------------------

ReentParser::Reent_np_callContext::Reent_np_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_np_callContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_np_callContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_np_callContext::Div() {
  return getToken(ReentParser::Div, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Reent_np_callContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_np_callContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::Reent_np_callContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::ExpressionContext* ReentParser::Reent_np_callContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}


size_t ReentParser::Reent_np_callContext::getRuleIndex() const {
  return ReentParser::RuleReent_np_call;
}

void ReentParser::Reent_np_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_np_call(this);
}

void ReentParser::Reent_np_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_np_call(this);
}

ReentParser::Reent_np_callContext* ReentParser::reent_np_call() {
  Reent_np_callContext *_localctx = _tracker.createInstance<Reent_np_callContext>(_ctx, getState());
  enterRule(_localctx, 168, ReentParser::RuleReent_np_call);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1287);
    dynamic_cast<Reent_np_callContext *>(_localctx)->ident = anyIdentifier();
    setState(1288);
    match(ReentParser::LeftParen);
    setState(1290);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(1289);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1292);
    match(ReentParser::RightParen);
     if (_input->LT(1)->getText() == "/" && chains.find((dynamic_cast<Reent_np_callContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Reent_np_callContext *>(_localctx)->ident->start, dynamic_cast<Reent_np_callContext *>(_localctx)->ident->stop) : nullptr)) == chains.end() && reenterables.find((dynamic_cast<Reent_np_callContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Reent_np_callContext *>(_localctx)->ident->start, dynamic_cast<Reent_np_callContext *>(_localctx)->ident->stop) : nullptr)) == reenterables.end())
    		throw FailedPredicateException(this, "Clause '/NumberOfProcessors' can be applied to Chain/Reenterable Procedure only");
    	
    setState(1294);
    match(ReentParser::Div);
    setState(1295);
    primaryExpression();
    setState(1296);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_chainContext ------------------------------------------------------------------

ReentParser::Start_chainContext::Start_chainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Start_single_proc_chainContext* ReentParser::Start_chainContext::start_single_proc_chain() {
  return getRuleContext<ReentParser::Start_single_proc_chainContext>(0);
}

ReentParser::Start_multi_proc_chainContext* ReentParser::Start_chainContext::start_multi_proc_chain() {
  return getRuleContext<ReentParser::Start_multi_proc_chainContext>(0);
}


size_t ReentParser::Start_chainContext::getRuleIndex() const {
  return ReentParser::RuleStart_chain;
}

void ReentParser::Start_chainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart_chain(this);
}

void ReentParser::Start_chainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart_chain(this);
}

ReentParser::Start_chainContext* ReentParser::start_chain() {
  Start_chainContext *_localctx = _tracker.createInstance<Start_chainContext>(_ctx, getState());
  enterRule(_localctx, 170, ReentParser::RuleStart_chain);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1300);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Plan_chain: {
        enterOuterAlt(_localctx, 1);
        setState(1298);
        start_single_proc_chain();
        break;
      }

      case ReentParser::Clustered:
      case ReentParser::Plan_parallel_chain: {
        enterOuterAlt(_localctx, 2);
        setState(1299);
        start_multi_proc_chain();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_single_proc_chainContext ------------------------------------------------------------------

ReentParser::Start_single_proc_chainContext::Start_single_proc_chainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Start_single_proc_chainContext::Plan_chain() {
  return getToken(ReentParser::Plan_chain, 0);
}

tree::TerminalNode* ReentParser::Start_single_proc_chainContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Start_single_proc_chainContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Start_single_proc_chainContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

ReentParser::Chain_descriptorContext* ReentParser::Start_single_proc_chainContext::chain_descriptor() {
  return getRuleContext<ReentParser::Chain_descriptorContext>(0);
}

tree::TerminalNode* ReentParser::Start_single_proc_chainContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Start_single_proc_chainContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::Start_single_proc_chainContext::getRuleIndex() const {
  return ReentParser::RuleStart_single_proc_chain;
}

void ReentParser::Start_single_proc_chainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart_single_proc_chain(this);
}

void ReentParser::Start_single_proc_chainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart_single_proc_chain(this);
}

ReentParser::Start_single_proc_chainContext* ReentParser::start_single_proc_chain() {
  Start_single_proc_chainContext *_localctx = _tracker.createInstance<Start_single_proc_chainContext>(_ctx, getState());
  enterRule(_localctx, 172, ReentParser::RuleStart_single_proc_chain);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1302);
    match(ReentParser::Plan_chain);
    setState(1303);
    match(ReentParser::LeftParen);
    setState(1304);
    primaryExpression();
    setState(1305);
    match(ReentParser::Comma);
    setState(1306);
    chain_descriptor();
    setState(1307);
    match(ReentParser::RightParen);
    setState(1308);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_multi_proc_chainContext ------------------------------------------------------------------

ReentParser::Start_multi_proc_chainContext::Start_multi_proc_chainContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Start_multi_proc_chainContext::Plan_parallel_chain() {
  return getToken(ReentParser::Plan_parallel_chain, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Start_multi_proc_chainContext::LeftParen() {
  return getTokens(ReentParser::LeftParen);
}

tree::TerminalNode* ReentParser::Start_multi_proc_chainContext::LeftParen(size_t i) {
  return getToken(ReentParser::LeftParen, i);
}

ReentParser::PrimaryExpressionContext* ReentParser::Start_multi_proc_chainContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Start_multi_proc_chainContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

ReentParser::Chain_descriptorContext* ReentParser::Start_multi_proc_chainContext::chain_descriptor() {
  return getRuleContext<ReentParser::Chain_descriptorContext>(0);
}

std::vector<tree::TerminalNode *> ReentParser::Start_multi_proc_chainContext::RightParen() {
  return getTokens(ReentParser::RightParen);
}

tree::TerminalNode* ReentParser::Start_multi_proc_chainContext::RightParen(size_t i) {
  return getToken(ReentParser::RightParen, i);
}

tree::TerminalNode* ReentParser::Start_multi_proc_chainContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::Start_multi_proc_chainContext::Clustered() {
  return getToken(ReentParser::Clustered, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::Start_multi_proc_chainContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}


size_t ReentParser::Start_multi_proc_chainContext::getRuleIndex() const {
  return ReentParser::RuleStart_multi_proc_chain;
}

void ReentParser::Start_multi_proc_chainContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart_multi_proc_chain(this);
}

void ReentParser::Start_multi_proc_chainContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart_multi_proc_chain(this);
}

ReentParser::Start_multi_proc_chainContext* ReentParser::start_multi_proc_chain() {
  Start_multi_proc_chainContext *_localctx = _tracker.createInstance<Start_multi_proc_chainContext>(_ctx, getState());
  enterRule(_localctx, 174, ReentParser::RuleStart_multi_proc_chain);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
     if (_input->LT(1)->getText() == "clustered")
    		if (!allow_clustered)
    			throw FailedPredicateException(this, "clustered chain without previous '#pragma plan clustered'");
    	
    setState(1316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Clustered) {
      setState(1311);
      match(ReentParser::Clustered);
      setState(1312);
      match(ReentParser::LeftParen);
      setState(1313);
      assignmentExpression();
      setState(1314);
      match(ReentParser::RightParen);
    }
    setState(1318);
    match(ReentParser::Plan_parallel_chain);
    setState(1319);
    match(ReentParser::LeftParen);
    setState(1320);
    primaryExpression();
    setState(1321);
    match(ReentParser::Comma);
    setState(1322);
    chain_descriptor();
    setState(1323);
    match(ReentParser::RightParen);
    setState(1324);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chain_descriptorContext ------------------------------------------------------------------

ReentParser::Chain_descriptorContext::Chain_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Vector_chain_descriptorContext* ReentParser::Chain_descriptorContext::vector_chain_descriptor() {
  return getRuleContext<ReentParser::Vector_chain_descriptorContext>(0);
}

ReentParser::List_chain_descriptorContext* ReentParser::Chain_descriptorContext::list_chain_descriptor() {
  return getRuleContext<ReentParser::List_chain_descriptorContext>(0);
}


size_t ReentParser::Chain_descriptorContext::getRuleIndex() const {
  return ReentParser::RuleChain_descriptor;
}

void ReentParser::Chain_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChain_descriptor(this);
}

void ReentParser::Chain_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChain_descriptor(this);
}

ReentParser::Chain_descriptorContext* ReentParser::chain_descriptor() {
  Chain_descriptorContext *_localctx = _tracker.createInstance<Chain_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 176, ReentParser::RuleChain_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 93, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1326);
      vector_chain_descriptor();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1327);
      list_chain_descriptor();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vector_chain_descriptorContext ------------------------------------------------------------------

ReentParser::Vector_chain_descriptorContext::Vector_chain_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Vector_chain_descriptorContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

ReentParser::Chain_callContext* ReentParser::Vector_chain_descriptorContext::chain_call() {
  return getRuleContext<ReentParser::Chain_callContext>(0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Vector_chain_descriptorContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}


size_t ReentParser::Vector_chain_descriptorContext::getRuleIndex() const {
  return ReentParser::RuleVector_chain_descriptor;
}

void ReentParser::Vector_chain_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVector_chain_descriptor(this);
}

void ReentParser::Vector_chain_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVector_chain_descriptor(this);
}

ReentParser::Vector_chain_descriptorContext* ReentParser::vector_chain_descriptor() {
  Vector_chain_descriptorContext *_localctx = _tracker.createInstance<Vector_chain_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 178, ReentParser::RuleVector_chain_descriptor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1330);
    dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident = primaryExpression();
    setState(1331);

    if (!( chains.find((dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident->start, dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident->stop) : nullptr)) == chains.end() )) throw FailedPredicateException(this, " chains.find($ident.text) == chains.end() ");
    setState(1332);
    match(ReentParser::Comma);
    setState(1333);
    chain_call();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- List_chain_descriptorContext ------------------------------------------------------------------

ReentParser::List_chain_descriptorContext::List_chain_descriptorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::Chain_callContext *> ReentParser::List_chain_descriptorContext::chain_call() {
  return getRuleContexts<ReentParser::Chain_callContext>();
}

ReentParser::Chain_callContext* ReentParser::List_chain_descriptorContext::chain_call(size_t i) {
  return getRuleContext<ReentParser::Chain_callContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::List_chain_descriptorContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::List_chain_descriptorContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}

std::vector<tree::TerminalNode *> ReentParser::List_chain_descriptorContext::Arrow() {
  return getTokens(ReentParser::Arrow);
}

tree::TerminalNode* ReentParser::List_chain_descriptorContext::Arrow(size_t i) {
  return getToken(ReentParser::Arrow, i);
}


size_t ReentParser::List_chain_descriptorContext::getRuleIndex() const {
  return ReentParser::RuleList_chain_descriptor;
}

void ReentParser::List_chain_descriptorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterList_chain_descriptor(this);
}

void ReentParser::List_chain_descriptorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitList_chain_descriptor(this);
}

ReentParser::List_chain_descriptorContext* ReentParser::list_chain_descriptor() {
  List_chain_descriptorContext *_localctx = _tracker.createInstance<List_chain_descriptorContext>(_ctx, getState());
  enterRule(_localctx, 180, ReentParser::RuleList_chain_descriptor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1335);
    chain_call();
    setState(1340);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma

    || _la == ReentParser::Arrow) {
      setState(1336);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Comma

      || _la == ReentParser::Arrow)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1337);
      chain_call();
      setState(1342);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Start_topologyContext ------------------------------------------------------------------

ReentParser::Start_topologyContext::Start_topologyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Start_topologyContext::Plan_topology() {
  return getToken(ReentParser::Plan_topology, 0);
}

tree::TerminalNode* ReentParser::Start_topologyContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::Start_topologyContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

tree::TerminalNode* ReentParser::Start_topologyContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::Start_topologyContext::Clustered() {
  return getToken(ReentParser::Clustered, 0);
}

tree::TerminalNode* ReentParser::Start_topologyContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::Start_topologyContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Start_topologyContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

std::vector<ReentParser::Topology_itemContext *> ReentParser::Start_topologyContext::topology_item() {
  return getRuleContexts<ReentParser::Topology_itemContext>();
}

ReentParser::Topology_itemContext* ReentParser::Start_topologyContext::topology_item(size_t i) {
  return getRuleContext<ReentParser::Topology_itemContext>(i);
}

tree::TerminalNode* ReentParser::Start_topologyContext::Div() {
  return getToken(ReentParser::Div, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Start_topologyContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}


size_t ReentParser::Start_topologyContext::getRuleIndex() const {
  return ReentParser::RuleStart_topology;
}

void ReentParser::Start_topologyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStart_topology(this);
}

void ReentParser::Start_topologyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStart_topology(this);
}

ReentParser::Start_topologyContext* ReentParser::start_topology() {
  Start_topologyContext *_localctx = _tracker.createInstance<Start_topologyContext>(_ctx, getState());
  enterRule(_localctx, 182, ReentParser::RuleStart_topology);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
     if (_input->LT(1)->getText() == "clustered")
    		if (!allow_clustered)
    			throw FailedPredicateException(this, "clustered topology without previous '#pragma plan clustered'");
    	
    setState(1349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Clustered) {
      setState(1344);
      match(ReentParser::Clustered);
      setState(1345);
      match(ReentParser::LeftParen);
      setState(1346);
      assignmentExpression();
      setState(1347);
      match(ReentParser::RightParen);
    }
    setState(1351);
    match(ReentParser::Plan_topology);
    setState(1352);
    match(ReentParser::LeftBrace);
    setState(1354); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1353);
      topology_item();
      setState(1356); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ReentParser::Plan_parallel_chain

    || _la == ReentParser::Plan_parallel_reverse);
    setState(1358);
    match(ReentParser::RightBrace);
    setState(1361);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Div) {
      setState(1359);
      match(ReentParser::Div);
      setState(1360);
      primaryExpression();
    }
    setState(1363);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topology_itemContext ------------------------------------------------------------------

ReentParser::Topology_itemContext::Topology_itemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Topology_itemContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::Topology_lineContext* ReentParser::Topology_itemContext::topology_line() {
  return getRuleContext<ReentParser::Topology_lineContext>(0);
}

ReentParser::Topology_reverseContext* ReentParser::Topology_itemContext::topology_reverse() {
  return getRuleContext<ReentParser::Topology_reverseContext>(0);
}


size_t ReentParser::Topology_itemContext::getRuleIndex() const {
  return ReentParser::RuleTopology_item;
}

void ReentParser::Topology_itemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopology_item(this);
}

void ReentParser::Topology_itemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopology_item(this);
}

ReentParser::Topology_itemContext* ReentParser::topology_item() {
  Topology_itemContext *_localctx = _tracker.createInstance<Topology_itemContext>(_ctx, getState());
  enterRule(_localctx, 184, ReentParser::RuleTopology_item);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1367);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Plan_parallel_chain: {
        setState(1365);
        topology_line();
        break;
      }

      case ReentParser::Plan_parallel_reverse: {
        setState(1366);
        topology_reverse();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1369);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topology_lineContext ------------------------------------------------------------------

ReentParser::Topology_lineContext::Topology_lineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Topology_lineContext::Plan_parallel_chain() {
  return getToken(ReentParser::Plan_parallel_chain, 0);
}

tree::TerminalNode* ReentParser::Topology_lineContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

std::vector<ReentParser::Topology_nodeContext *> ReentParser::Topology_lineContext::topology_node() {
  return getRuleContexts<ReentParser::Topology_nodeContext>();
}

ReentParser::Topology_nodeContext* ReentParser::Topology_lineContext::topology_node(size_t i) {
  return getRuleContext<ReentParser::Topology_nodeContext>(i);
}

tree::TerminalNode* ReentParser::Topology_lineContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

std::vector<tree::TerminalNode *> ReentParser::Topology_lineContext::Arrow() {
  return getTokens(ReentParser::Arrow);
}

tree::TerminalNode* ReentParser::Topology_lineContext::Arrow(size_t i) {
  return getToken(ReentParser::Arrow, i);
}

std::vector<tree::TerminalNode *> ReentParser::Topology_lineContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::Topology_lineContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::Topology_lineContext::getRuleIndex() const {
  return ReentParser::RuleTopology_line;
}

void ReentParser::Topology_lineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopology_line(this);
}

void ReentParser::Topology_lineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopology_line(this);
}

ReentParser::Topology_lineContext* ReentParser::topology_line() {
  Topology_lineContext *_localctx = _tracker.createInstance<Topology_lineContext>(_ctx, getState());
  enterRule(_localctx, 186, ReentParser::RuleTopology_line);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1371);
    match(ReentParser::Plan_parallel_chain);
    setState(1372);
    match(ReentParser::LeftParen);
    setState(1373);
    topology_node();
    setState(1378);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma

    || _la == ReentParser::Arrow) {
      setState(1374);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Comma

      || _la == ReentParser::Arrow)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1375);
      topology_node();
      setState(1380);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1381);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topology_reverseContext ------------------------------------------------------------------

ReentParser::Topology_reverseContext::Topology_reverseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Topology_reverseContext::Plan_parallel_reverse() {
  return getToken(ReentParser::Plan_parallel_reverse, 0);
}

tree::TerminalNode* ReentParser::Topology_reverseContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

std::vector<ReentParser::Topology_nodeContext *> ReentParser::Topology_reverseContext::topology_node() {
  return getRuleContexts<ReentParser::Topology_nodeContext>();
}

ReentParser::Topology_nodeContext* ReentParser::Topology_reverseContext::topology_node(size_t i) {
  return getRuleContext<ReentParser::Topology_nodeContext>(i);
}

tree::TerminalNode* ReentParser::Topology_reverseContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Topology_reverseContext::Arrow() {
  return getToken(ReentParser::Arrow, 0);
}

tree::TerminalNode* ReentParser::Topology_reverseContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}


size_t ReentParser::Topology_reverseContext::getRuleIndex() const {
  return ReentParser::RuleTopology_reverse;
}

void ReentParser::Topology_reverseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopology_reverse(this);
}

void ReentParser::Topology_reverseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopology_reverse(this);
}

ReentParser::Topology_reverseContext* ReentParser::topology_reverse() {
  Topology_reverseContext *_localctx = _tracker.createInstance<Topology_reverseContext>(_ctx, getState());
  enterRule(_localctx, 188, ReentParser::RuleTopology_reverse);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1383);
    match(ReentParser::Plan_parallel_reverse);
    setState(1384);
    match(ReentParser::LeftParen);
    setState(1385);
    topology_node();
    setState(1386);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Comma

    || _la == ReentParser::Arrow)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1387);
    topology_node();
    setState(1388);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Topology_nodeContext ------------------------------------------------------------------

ReentParser::Topology_nodeContext::Topology_nodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Topology_nodeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Topology_nodeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Topology_nodeContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}

tree::TerminalNode* ReentParser::Topology_nodeContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::Topology_nodeContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::ExpressionContext* ReentParser::Topology_nodeContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Topology_nodeContext::Div() {
  return getToken(ReentParser::Div, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Topology_nodeContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}

std::vector<tree::TerminalNode *> ReentParser::Topology_nodeContext::IntegerLiteral() {
  return getTokens(ReentParser::IntegerLiteral);
}

tree::TerminalNode* ReentParser::Topology_nodeContext::IntegerLiteral(size_t i) {
  return getToken(ReentParser::IntegerLiteral, i);
}


size_t ReentParser::Topology_nodeContext::getRuleIndex() const {
  return ReentParser::RuleTopology_node;
}

void ReentParser::Topology_nodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTopology_node(this);
}

void ReentParser::Topology_nodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTopology_node(this);
}

ReentParser::Topology_nodeContext* ReentParser::topology_node() {
  Topology_nodeContext *_localctx = _tracker.createInstance<Topology_nodeContext>(_ctx, getState());
  enterRule(_localctx, 190, ReentParser::RuleTopology_node);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1390);
    dynamic_cast<Topology_nodeContext *>(_localctx)->ident = match(ReentParser::Identifier);
    setState(1398);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::LeftBracket) {
      setState(1391);
      match(ReentParser::LeftBracket);
      setState(1393); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1392);
        match(ReentParser::IntegerLiteral);
        setState(1395); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == ReentParser::IntegerLiteral);
      setState(1397);
      match(ReentParser::RightBracket);
    }
     if (chains.find((dynamic_cast<Topology_nodeContext *>(_localctx)->ident != nullptr ? dynamic_cast<Topology_nodeContext *>(_localctx)->ident->getText() : "")) == chains.end()) throw FailedPredicateException(this, "Chain procedure Identifier expected in topology"); 
    setState(1401);
    match(ReentParser::LeftParen);
    setState(1403);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
    case 1: {
      setState(1402);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1405);
    match(ReentParser::RightParen);
    setState(1408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Div) {
      setState(1406);
      match(ReentParser::Div);
      setState(1407);
      primaryExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chain_callContext ------------------------------------------------------------------

ReentParser::Chain_callContext::Chain_callContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Chain_callContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Chain_callContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Chain_callContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}

ReentParser::ExpressionContext* ReentParser::Chain_callContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Chain_callContext::Div() {
  return getToken(ReentParser::Div, 0);
}

ReentParser::PrimaryExpressionContext* ReentParser::Chain_callContext::primaryExpression() {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(0);
}


size_t ReentParser::Chain_callContext::getRuleIndex() const {
  return ReentParser::RuleChain_call;
}

void ReentParser::Chain_callContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChain_call(this);
}

void ReentParser::Chain_callContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChain_call(this);
}

ReentParser::Chain_callContext* ReentParser::chain_call() {
  Chain_callContext *_localctx = _tracker.createInstance<Chain_callContext>(_ctx, getState());
  enterRule(_localctx, 192, ReentParser::RuleChain_call);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1410);
    dynamic_cast<Chain_callContext *>(_localctx)->ident = match(ReentParser::Identifier);
     if (chains.find((dynamic_cast<Chain_callContext *>(_localctx)->ident != nullptr ? dynamic_cast<Chain_callContext *>(_localctx)->ident->getText() : "")) == chains.end()) throw FailedPredicateException(this, "Chain procedure Identifier expected"); 
    setState(1412);
    match(ReentParser::LeftParen);
    setState(1414);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
    case 1: {
      setState(1413);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1416);
    match(ReentParser::RightParen);
    setState(1419);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Div) {
      setState(1417);
      match(ReentParser::Div);
      setState(1418);
      primaryExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_call_statementContext ------------------------------------------------------------------

ReentParser::Qualified_call_statementContext::Qualified_call_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::QualifiedIdContext* ReentParser::Qualified_call_statementContext::qualifiedId() {
  return getRuleContext<ReentParser::QualifiedIdContext>(0);
}

tree::TerminalNode* ReentParser::Qualified_call_statementContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Qualified_call_statementContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Qualified_call_statementContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::ExpressionContext* ReentParser::Qualified_call_statementContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}


size_t ReentParser::Qualified_call_statementContext::getRuleIndex() const {
  return ReentParser::RuleQualified_call_statement;
}

void ReentParser::Qualified_call_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualified_call_statement(this);
}

void ReentParser::Qualified_call_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualified_call_statement(this);
}

ReentParser::Qualified_call_statementContext* ReentParser::qualified_call_statement() {
  Qualified_call_statementContext *_localctx = _tracker.createInstance<Qualified_call_statementContext>(_ctx, getState());
  enterRule(_localctx, 194, ReentParser::RuleQualified_call_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1421);
    qualifiedId();
    setState(1422);
    match(ReentParser::LeftParen);
    setState(1424);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(1423);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1426);
    match(ReentParser::RightParen);
    setState(1427);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Spawned_call_statementContext ------------------------------------------------------------------

ReentParser::Spawned_call_statementContext::Spawned_call_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::IdExpressionContext* ReentParser::Spawned_call_statementContext::idExpression() {
  return getRuleContext<ReentParser::IdExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Spawned_call_statementContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Spawned_call_statementContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Spawned_call_statementContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::ExpressionContext* ReentParser::Spawned_call_statementContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}


size_t ReentParser::Spawned_call_statementContext::getRuleIndex() const {
  return ReentParser::RuleSpawned_call_statement;
}

void ReentParser::Spawned_call_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpawned_call_statement(this);
}

void ReentParser::Spawned_call_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpawned_call_statement(this);
}

ReentParser::Spawned_call_statementContext* ReentParser::spawned_call_statement() {
  Spawned_call_statementContext *_localctx = _tracker.createInstance<Spawned_call_statementContext>(_ctx, getState());
  enterRule(_localctx, 196, ReentParser::RuleSpawned_call_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1429);
    idExpression();
    setState(1430);
    match(ReentParser::LeftParen);
    setState(1432);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(1431);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1434);
    match(ReentParser::RightParen);
    setState(1435);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

ReentParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ExpressionStatementContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::ExpressionContext* ReentParser::ExpressionStatementContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}


size_t ReentParser::ExpressionStatementContext::getRuleIndex() const {
  return ReentParser::RuleExpressionStatement;
}

void ReentParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void ReentParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

ReentParser::ExpressionStatementContext* ReentParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 198, ReentParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1438);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      setState(1437);
      expression();
      break;
    }

    default:
      break;
    }
    setState(1440);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

ReentParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::CompoundStatementContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::CompoundStatementContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

ReentParser::StatementSeqContext* ReentParser::CompoundStatementContext::statementSeq() {
  return getRuleContext<ReentParser::StatementSeqContext>(0);
}


size_t ReentParser::CompoundStatementContext::getRuleIndex() const {
  return ReentParser::RuleCompoundStatement;
}

void ReentParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void ReentParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}

ReentParser::CompoundStatementContext* ReentParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 200, ReentParser::RuleCompoundStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1442);
    match(ReentParser::LeftBrace);
    setState(1444);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      setState(1443);
      statementSeq();
      break;
    }

    default:
      break;
    }
    setState(1446);
    match(ReentParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementSeqContext ------------------------------------------------------------------

ReentParser::StatementSeqContext::StatementSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::StatementContext *> ReentParser::StatementSeqContext::statement() {
  return getRuleContexts<ReentParser::StatementContext>();
}

ReentParser::StatementContext* ReentParser::StatementSeqContext::statement(size_t i) {
  return getRuleContext<ReentParser::StatementContext>(i);
}


size_t ReentParser::StatementSeqContext::getRuleIndex() const {
  return ReentParser::RuleStatementSeq;
}

void ReentParser::StatementSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementSeq(this);
}

void ReentParser::StatementSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementSeq(this);
}

ReentParser::StatementSeqContext* ReentParser::statementSeq() {
  StatementSeqContext *_localctx = _tracker.createInstance<StatementSeqContext>(_ctx, getState());
  enterRule(_localctx, 202, ReentParser::RuleStatementSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1449); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1448);
              statement();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1451); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectionStatementContext ------------------------------------------------------------------

ReentParser::SelectionStatementContext::SelectionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::SelectionStatementContext::If() {
  return getToken(ReentParser::If, 0);
}

tree::TerminalNode* ReentParser::SelectionStatementContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ConditionContext* ReentParser::SelectionStatementContext::condition() {
  return getRuleContext<ReentParser::ConditionContext>(0);
}

tree::TerminalNode* ReentParser::SelectionStatementContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

std::vector<ReentParser::StatementContext *> ReentParser::SelectionStatementContext::statement() {
  return getRuleContexts<ReentParser::StatementContext>();
}

ReentParser::StatementContext* ReentParser::SelectionStatementContext::statement(size_t i) {
  return getRuleContext<ReentParser::StatementContext>(i);
}

tree::TerminalNode* ReentParser::SelectionStatementContext::Else() {
  return getToken(ReentParser::Else, 0);
}

tree::TerminalNode* ReentParser::SelectionStatementContext::Switch() {
  return getToken(ReentParser::Switch, 0);
}


size_t ReentParser::SelectionStatementContext::getRuleIndex() const {
  return ReentParser::RuleSelectionStatement;
}

void ReentParser::SelectionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectionStatement(this);
}

void ReentParser::SelectionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectionStatement(this);
}

ReentParser::SelectionStatementContext* ReentParser::selectionStatement() {
  SelectionStatementContext *_localctx = _tracker.createInstance<SelectionStatementContext>(_ctx, getState());
  enterRule(_localctx, 204, ReentParser::RuleSelectionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1468);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::If: {
        enterOuterAlt(_localctx, 1);
        setState(1453);
        match(ReentParser::If);
        setState(1454);
        match(ReentParser::LeftParen);
        setState(1455);
        condition();
        setState(1456);
        match(ReentParser::RightParen);
        setState(1457);
        statement();
        setState(1460);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
        case 1: {
          setState(1458);
          match(ReentParser::Else);
          setState(1459);
          statement();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::Switch: {
        enterOuterAlt(_localctx, 2);
        setState(1462);
        match(ReentParser::Switch);
        setState(1463);
        match(ReentParser::LeftParen);
        setState(1464);
        condition();
        setState(1465);
        match(ReentParser::RightParen);
        setState(1466);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionContext ------------------------------------------------------------------

ReentParser::ConditionContext::ConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ExpressionContext* ReentParser::ConditionContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::ConditionContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::DeclaratorContext* ReentParser::ConditionContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

tree::TerminalNode* ReentParser::ConditionContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::InitializerClauseContext* ReentParser::ConditionContext::initializerClause() {
  return getRuleContext<ReentParser::InitializerClauseContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::ConditionContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ConditionContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::ConditionContext::getRuleIndex() const {
  return ReentParser::RuleCondition;
}

void ReentParser::ConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCondition(this);
}

void ReentParser::ConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCondition(this);
}

ReentParser::ConditionContext* ReentParser::condition() {
  ConditionContext *_localctx = _tracker.createInstance<ConditionContext>(_ctx, getState());
  enterRule(_localctx, 206, ReentParser::RuleCondition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1481);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1470);
      expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1472);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
        setState(1471);
        attributeSpecifierSeq();
      }
      setState(1474);
      declSpecifierSeq();
      setState(1475);
      declarator();
      setState(1479);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ReentParser::Assign: {
          setState(1476);
          match(ReentParser::Assign);
          setState(1477);
          initializerClause();
          break;
        }

        case ReentParser::LeftBrace: {
          setState(1478);
          bracedInitList();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterationStatementContext ------------------------------------------------------------------

ReentParser::IterationStatementContext::IterationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::IterationStatementContext::While() {
  return getToken(ReentParser::While, 0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ConditionContext* ReentParser::IterationStatementContext::condition() {
  return getRuleContext<ReentParser::ConditionContext>(0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::StatementContext* ReentParser::IterationStatementContext::statement() {
  return getRuleContext<ReentParser::StatementContext>(0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::Do() {
  return getToken(ReentParser::Do, 0);
}

ReentParser::ExpressionContext* ReentParser::IterationStatementContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::For() {
  return getToken(ReentParser::For, 0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::Cilk_for() {
  return getToken(ReentParser::Cilk_for, 0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::Cilk_for_() {
  return getToken(ReentParser::Cilk_for_, 0);
}

ReentParser::ForInitStatementContext* ReentParser::IterationStatementContext::forInitStatement() {
  return getRuleContext<ReentParser::ForInitStatementContext>(0);
}

ReentParser::ForRangeDeclarationContext* ReentParser::IterationStatementContext::forRangeDeclaration() {
  return getRuleContext<ReentParser::ForRangeDeclarationContext>(0);
}

tree::TerminalNode* ReentParser::IterationStatementContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::ForRangeInitializerContext* ReentParser::IterationStatementContext::forRangeInitializer() {
  return getRuleContext<ReentParser::ForRangeInitializerContext>(0);
}


size_t ReentParser::IterationStatementContext::getRuleIndex() const {
  return ReentParser::RuleIterationStatement;
}

void ReentParser::IterationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterationStatement(this);
}

void ReentParser::IterationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterationStatement(this);
}

ReentParser::IterationStatementContext* ReentParser::iterationStatement() {
  IterationStatementContext *_localctx = _tracker.createInstance<IterationStatementContext>(_ctx, getState());
  enterRule(_localctx, 208, ReentParser::RuleIterationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1516);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::While: {
        enterOuterAlt(_localctx, 1);
        setState(1483);
        match(ReentParser::While);
        setState(1484);
        match(ReentParser::LeftParen);
        setState(1485);
        condition();
        setState(1486);
        match(ReentParser::RightParen);
        setState(1487);
        statement();
        break;
      }

      case ReentParser::Do: {
        enterOuterAlt(_localctx, 2);
        setState(1489);
        match(ReentParser::Do);
        setState(1490);
        statement();
        setState(1491);
        match(ReentParser::While);
        setState(1492);
        match(ReentParser::LeftParen);
        setState(1493);
        expression();
        setState(1494);
        match(ReentParser::RightParen);
        setState(1495);
        match(ReentParser::Semi);
        break;
      }

      case ReentParser::Cilk_for:
      case ReentParser::Cilk_for_:
      case ReentParser::For: {
        enterOuterAlt(_localctx, 3);
        setState(1497);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ReentParser::Cilk_for)
          | (1ULL << ReentParser::Cilk_for_)
          | (1ULL << ReentParser::For))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1498);
        match(ReentParser::LeftParen);
        setState(1511);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
        case 1: {
          setState(1499);
          forInitStatement();
          setState(1501);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
          case 1: {
            setState(1500);
            condition();
            break;
          }

          default:
            break;
          }
          setState(1503);
          match(ReentParser::Semi);
          setState(1505);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
          case 1: {
            setState(1504);
            expression();
            break;
          }

          default:
            break;
          }
          break;
        }

        case 2: {
          setState(1507);
          forRangeDeclaration();
          setState(1508);
          match(ReentParser::Colon);
          setState(1509);
          forRangeInitializer();
          break;
        }

        default:
          break;
        }
        setState(1513);
        match(ReentParser::RightParen);
        setState(1514);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForInitStatementContext ------------------------------------------------------------------

ReentParser::ForInitStatementContext::ForInitStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ExpressionStatementContext* ReentParser::ForInitStatementContext::expressionStatement() {
  return getRuleContext<ReentParser::ExpressionStatementContext>(0);
}

ReentParser::SimpleDeclarationContext* ReentParser::ForInitStatementContext::simpleDeclaration() {
  return getRuleContext<ReentParser::SimpleDeclarationContext>(0);
}


size_t ReentParser::ForInitStatementContext::getRuleIndex() const {
  return ReentParser::RuleForInitStatement;
}

void ReentParser::ForInitStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForInitStatement(this);
}

void ReentParser::ForInitStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForInitStatement(this);
}

ReentParser::ForInitStatementContext* ReentParser::forInitStatement() {
  ForInitStatementContext *_localctx = _tracker.createInstance<ForInitStatementContext>(_ctx, getState());
  enterRule(_localctx, 210, ReentParser::RuleForInitStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1520);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1518);
      expressionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1519);
      simpleDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForRangeDeclarationContext ------------------------------------------------------------------

ReentParser::ForRangeDeclarationContext::ForRangeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclSpecifierSeqContext* ReentParser::ForRangeDeclarationContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::DeclaratorContext* ReentParser::ForRangeDeclarationContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ForRangeDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::ForRangeDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleForRangeDeclaration;
}

void ReentParser::ForRangeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForRangeDeclaration(this);
}

void ReentParser::ForRangeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForRangeDeclaration(this);
}

ReentParser::ForRangeDeclarationContext* ReentParser::forRangeDeclaration() {
  ForRangeDeclarationContext *_localctx = _tracker.createInstance<ForRangeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 212, ReentParser::RuleForRangeDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1523);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(1522);
      attributeSpecifierSeq();
    }
    setState(1525);
    declSpecifierSeq();
    setState(1526);
    declarator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ForRangeInitializerContext ------------------------------------------------------------------

ReentParser::ForRangeInitializerContext::ForRangeInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ExpressionContext* ReentParser::ForRangeInitializerContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::ForRangeInitializerContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}


size_t ReentParser::ForRangeInitializerContext::getRuleIndex() const {
  return ReentParser::RuleForRangeInitializer;
}

void ReentParser::ForRangeInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForRangeInitializer(this);
}

void ReentParser::ForRangeInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForRangeInitializer(this);
}

ReentParser::ForRangeInitializerContext* ReentParser::forRangeInitializer() {
  ForRangeInitializerContext *_localctx = _tracker.createInstance<ForRangeInitializerContext>(_ctx, getState());
  enterRule(_localctx, 214, ReentParser::RuleForRangeInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1530);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1528);
      expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1529);
      bracedInitList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JumpStatementContext ------------------------------------------------------------------

ReentParser::JumpStatementContext::JumpStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::JumpStatementContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::JumpStatementContext::Break() {
  return getToken(ReentParser::Break, 0);
}

tree::TerminalNode* ReentParser::JumpStatementContext::Continue() {
  return getToken(ReentParser::Continue, 0);
}

tree::TerminalNode* ReentParser::JumpStatementContext::Return() {
  return getToken(ReentParser::Return, 0);
}

tree::TerminalNode* ReentParser::JumpStatementContext::Goto() {
  return getToken(ReentParser::Goto, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::JumpStatementContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::ExpressionContext* ReentParser::JumpStatementContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::JumpStatementContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}


size_t ReentParser::JumpStatementContext::getRuleIndex() const {
  return ReentParser::RuleJumpStatement;
}

void ReentParser::JumpStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJumpStatement(this);
}

void ReentParser::JumpStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJumpStatement(this);
}

ReentParser::JumpStatementContext* ReentParser::jumpStatement() {
  JumpStatementContext *_localctx = _tracker.createInstance<JumpStatementContext>(_ctx, getState());
  enterRule(_localctx, 216, ReentParser::RuleJumpStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1541);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Break: {
        setState(1532);
        match(ReentParser::Break);
        break;
      }

      case ReentParser::Continue: {
        setState(1533);
        match(ReentParser::Continue);
        break;
      }

      case ReentParser::Return: {
        setState(1534);
        match(ReentParser::Return);
        setState(1537);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
        case 1: {
          setState(1535);
          expression();
          break;
        }

        case 2: {
          setState(1536);
          bracedInitList();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::Goto: {
        setState(1539);
        match(ReentParser::Goto);
        setState(1540);
        anyIdentifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1543);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationStatementContext ------------------------------------------------------------------

ReentParser::DeclarationStatementContext::DeclarationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::BlockDeclarationContext* ReentParser::DeclarationStatementContext::blockDeclaration() {
  return getRuleContext<ReentParser::BlockDeclarationContext>(0);
}


size_t ReentParser::DeclarationStatementContext::getRuleIndex() const {
  return ReentParser::RuleDeclarationStatement;
}

void ReentParser::DeclarationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclarationStatement(this);
}

void ReentParser::DeclarationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclarationStatement(this);
}

ReentParser::DeclarationStatementContext* ReentParser::declarationStatement() {
  DeclarationStatementContext *_localctx = _tracker.createInstance<DeclarationStatementContext>(_ctx, getState());
  enterRule(_localctx, 218, ReentParser::RuleDeclarationStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1545);
    blockDeclaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationseqContext ------------------------------------------------------------------

ReentParser::DeclarationseqContext::DeclarationseqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::DeclarationContext *> ReentParser::DeclarationseqContext::declaration() {
  return getRuleContexts<ReentParser::DeclarationContext>();
}

ReentParser::DeclarationContext* ReentParser::DeclarationseqContext::declaration(size_t i) {
  return getRuleContext<ReentParser::DeclarationContext>(i);
}


size_t ReentParser::DeclarationseqContext::getRuleIndex() const {
  return ReentParser::RuleDeclarationseq;
}

void ReentParser::DeclarationseqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclarationseq(this);
}

void ReentParser::DeclarationseqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclarationseq(this);
}

ReentParser::DeclarationseqContext* ReentParser::declarationseq() {
  DeclarationseqContext *_localctx = _tracker.createInstance<DeclarationseqContext>(_ctx, getState());
  enterRule(_localctx, 220, ReentParser::RuleDeclarationseq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1548); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1547);
      declaration();
      setState(1550); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 8) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 8)) & ((1ULL << (ReentParser::PlanPragma - 8))
      | (1ULL << (ReentParser::Alignas - 8))
      | (1ULL << (ReentParser::Asm - 8))
      | (1ULL << (ReentParser::Auto - 8))
      | (1ULL << (ReentParser::Begin - 8))
      | (1ULL << (ReentParser::Bool - 8))
      | (1ULL << (ReentParser::Cfunnel - 8))
      | (1ULL << (ReentParser::Chain - 8))
      | (1ULL << (ReentParser::Char - 8))
      | (1ULL << (ReentParser::Char16 - 8))
      | (1ULL << (ReentParser::Char32 - 8))
      | (1ULL << (ReentParser::Class - 8))
      | (1ULL << (ReentParser::Clustered - 8))
      | (1ULL << (ReentParser::Common - 8))
      | (1ULL << (ReentParser::Const - 8))
      | (1ULL << (ReentParser::Constexpr - 8))
      | (1ULL << (ReentParser::Csem - 8))
      | (1ULL << (ReentParser::Cvar - 8))
      | (1ULL << (ReentParser::Decltype - 8))
      | (1ULL << (ReentParser::Depends - 8))
      | (1ULL << (ReentParser::Double - 8))
      | (1ULL << (ReentParser::End - 8))
      | (1ULL << (ReentParser::Enum - 8))
      | (1ULL << (ReentParser::Explicit - 8))
      | (1ULL << (ReentParser::Extern - 8))
      | (1ULL << (ReentParser::Float - 8))
      | (1ULL << (ReentParser::Friend - 8))
      | (1ULL << (ReentParser::Funnel - 8))
      | (1ULL << (ReentParser::Global - 8))
      | (1ULL << (ReentParser::Gpu - 8))
      | (1ULL << (ReentParser::Id - 8))
      | (1ULL << (ReentParser::In - 8)))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ReentParser::Inline - 72))
      | (1ULL << (ReentParser::Int - 72))
      | (1ULL << (ReentParser::Local - 72))
      | (1ULL << (ReentParser::Long - 72))
      | (1ULL << (ReentParser::MarkPreCondition - 72))
      | (1ULL << (ReentParser::MarkState - 72))
      | (1ULL << (ReentParser::Markupdef - 72))
      | (1ULL << (ReentParser::Mutable - 72))
      | (1ULL << (ReentParser::Namespace - 72))
      | (1ULL << (ReentParser::Operator - 72))
      | (1ULL << (ReentParser::Out - 72))
      | (1ULL << (ReentParser::Plan - 72))
      | (1ULL << (ReentParser::Plan_item_type - 72))
      | (1ULL << (ReentParser::Plan_type - 72))
      | (1ULL << (ReentParser::Reenterable - 72))
      | (1ULL << (ReentParser::Register - 72))
      | (1ULL << (ReentParser::Reset - 72))
      | (1ULL << (ReentParser::Set - 72))
      | (1ULL << (ReentParser::Short - 72))
      | (1ULL << (ReentParser::Signed - 72))
      | (1ULL << (ReentParser::Soft_transact_array - 72))
      | (1ULL << (ReentParser::Soft_transact_in - 72))
      | (1ULL << (ReentParser::Soft_transact_out - 72))
      | (1ULL << (ReentParser::Soft_transact_var - 72))
      | (1ULL << (ReentParser::Static - 72))
      | (1ULL << (ReentParser::Static_assert - 72))
      | (1ULL << (ReentParser::Struct - 72))
      | (1ULL << (ReentParser::Template - 72))
      | (1ULL << (ReentParser::Thread_local - 72)))) != 0) || ((((_la - 140) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 140)) & ((1ULL << (ReentParser::Typedef - 140))
      | (1ULL << (ReentParser::Typename_ - 140))
      | (1ULL << (ReentParser::Union - 140))
      | (1ULL << (ReentParser::Unsigned - 140))
      | (1ULL << (ReentParser::Using - 140))
      | (1ULL << (ReentParser::Vectorized - 140))
      | (1ULL << (ReentParser::Virtual - 140))
      | (1ULL << (ReentParser::Void - 140))
      | (1ULL << (ReentParser::Volatile - 140))
      | (1ULL << (ReentParser::Wchar - 140))
      | (1ULL << (ReentParser::LeftParen - 140))
      | (1ULL << (ReentParser::LeftBracket - 140))
      | (1ULL << (ReentParser::Star - 140))
      | (1ULL << (ReentParser::And - 140))
      | (1ULL << (ReentParser::Tilde - 140))
      | (1ULL << (ReentParser::AndAnd - 140))
      | (1ULL << (ReentParser::Doublecolon - 140))
      | (1ULL << (ReentParser::Semi - 140))
      | (1ULL << (ReentParser::Ellipsis - 140))
      | (1ULL << (ReentParser::Identifier - 140)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

ReentParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Plan_pragmaContext* ReentParser::DeclarationContext::plan_pragma() {
  return getRuleContext<ReentParser::Plan_pragmaContext>(0);
}

ReentParser::ReenterableDeclarationContext* ReentParser::DeclarationContext::reenterableDeclaration() {
  return getRuleContext<ReentParser::ReenterableDeclarationContext>(0);
}

ReentParser::ReenterableDefinitionContext* ReentParser::DeclarationContext::reenterableDefinition() {
  return getRuleContext<ReentParser::ReenterableDefinitionContext>(0);
}

ReentParser::ChainDeclarationContext* ReentParser::DeclarationContext::chainDeclaration() {
  return getRuleContext<ReentParser::ChainDeclarationContext>(0);
}

ReentParser::ChainDefinitionContext* ReentParser::DeclarationContext::chainDefinition() {
  return getRuleContext<ReentParser::ChainDefinitionContext>(0);
}

ReentParser::FunctionDefinitionContext* ReentParser::DeclarationContext::functionDefinition() {
  return getRuleContext<ReentParser::FunctionDefinitionContext>(0);
}

ReentParser::BlockDeclarationContext* ReentParser::DeclarationContext::blockDeclaration() {
  return getRuleContext<ReentParser::BlockDeclarationContext>(0);
}

ReentParser::TemplateDeclarationContext* ReentParser::DeclarationContext::templateDeclaration() {
  return getRuleContext<ReentParser::TemplateDeclarationContext>(0);
}

ReentParser::ExplicitInstantiationContext* ReentParser::DeclarationContext::explicitInstantiation() {
  return getRuleContext<ReentParser::ExplicitInstantiationContext>(0);
}

ReentParser::ExplicitSpecializationContext* ReentParser::DeclarationContext::explicitSpecialization() {
  return getRuleContext<ReentParser::ExplicitSpecializationContext>(0);
}

ReentParser::LinkageSpecificationContext* ReentParser::DeclarationContext::linkageSpecification() {
  return getRuleContext<ReentParser::LinkageSpecificationContext>(0);
}

ReentParser::NamespaceDefinitionContext* ReentParser::DeclarationContext::namespaceDefinition() {
  return getRuleContext<ReentParser::NamespaceDefinitionContext>(0);
}

ReentParser::EmptyDeclarationContext* ReentParser::DeclarationContext::emptyDeclaration() {
  return getRuleContext<ReentParser::EmptyDeclarationContext>(0);
}

ReentParser::AttributeDeclarationContext* ReentParser::DeclarationContext::attributeDeclaration() {
  return getRuleContext<ReentParser::AttributeDeclarationContext>(0);
}


size_t ReentParser::DeclarationContext::getRuleIndex() const {
  return ReentParser::RuleDeclaration;
}

void ReentParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void ReentParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

ReentParser::DeclarationContext* ReentParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 222, ReentParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1566);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1552);
      plan_pragma();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1553);
      reenterableDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1554);
      reenterableDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1555);
      chainDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1556);
      chainDefinition();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1557);
      functionDefinition();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1558);
      blockDeclaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1559);
      templateDeclaration();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1560);
      explicitInstantiation();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1561);
      explicitSpecialization();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1562);
      linkageSpecification();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1563);
      namespaceDefinition();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1564);
      emptyDeclaration();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1565);
      attributeDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BlockDeclarationContext ------------------------------------------------------------------

ReentParser::BlockDeclarationContext::BlockDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::SimpleDeclarationContext* ReentParser::BlockDeclarationContext::simpleDeclaration() {
  return getRuleContext<ReentParser::SimpleDeclarationContext>(0);
}

ReentParser::AsmDefinitionContext* ReentParser::BlockDeclarationContext::asmDefinition() {
  return getRuleContext<ReentParser::AsmDefinitionContext>(0);
}

ReentParser::NamespaceAliasDefinitionContext* ReentParser::BlockDeclarationContext::namespaceAliasDefinition() {
  return getRuleContext<ReentParser::NamespaceAliasDefinitionContext>(0);
}

ReentParser::UsingDeclarationContext* ReentParser::BlockDeclarationContext::usingDeclaration() {
  return getRuleContext<ReentParser::UsingDeclarationContext>(0);
}

ReentParser::UsingDirectiveContext* ReentParser::BlockDeclarationContext::usingDirective() {
  return getRuleContext<ReentParser::UsingDirectiveContext>(0);
}

ReentParser::StaticAssertDeclarationContext* ReentParser::BlockDeclarationContext::staticAssertDeclaration() {
  return getRuleContext<ReentParser::StaticAssertDeclarationContext>(0);
}

ReentParser::AliasDeclarationContext* ReentParser::BlockDeclarationContext::aliasDeclaration() {
  return getRuleContext<ReentParser::AliasDeclarationContext>(0);
}

ReentParser::OpaqueEnumDeclarationContext* ReentParser::BlockDeclarationContext::opaqueEnumDeclaration() {
  return getRuleContext<ReentParser::OpaqueEnumDeclarationContext>(0);
}


size_t ReentParser::BlockDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleBlockDeclaration;
}

void ReentParser::BlockDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBlockDeclaration(this);
}

void ReentParser::BlockDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBlockDeclaration(this);
}

ReentParser::BlockDeclarationContext* ReentParser::blockDeclaration() {
  BlockDeclarationContext *_localctx = _tracker.createInstance<BlockDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 224, ReentParser::RuleBlockDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1576);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1568);
      simpleDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1569);
      asmDefinition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1570);
      namespaceAliasDefinition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1571);
      usingDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1572);
      usingDirective();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1573);
      staticAssertDeclaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1574);
      aliasDeclaration();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1575);
      opaqueEnumDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasDeclarationContext ------------------------------------------------------------------

ReentParser::AliasDeclarationContext::AliasDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AliasDeclarationContext::Using() {
  return getToken(ReentParser::Using, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::AliasDeclarationContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::AliasDeclarationContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::TheTypeIdContext* ReentParser::AliasDeclarationContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::AliasDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::AliasDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::AliasDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleAliasDeclaration;
}

void ReentParser::AliasDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAliasDeclaration(this);
}

void ReentParser::AliasDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAliasDeclaration(this);
}

ReentParser::AliasDeclarationContext* ReentParser::aliasDeclaration() {
  AliasDeclarationContext *_localctx = _tracker.createInstance<AliasDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 226, ReentParser::RuleAliasDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1578);
    match(ReentParser::Using);
    setState(1579);
    anyIdentifier();
    setState(1581);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(1580);
      attributeSpecifierSeq();
    }
    setState(1583);
    match(ReentParser::Assign);
    setState(1584);
    theTypeId();
    setState(1585);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleDeclarationContext ------------------------------------------------------------------

ReentParser::SimpleDeclarationContext::SimpleDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::SimpleDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::SimpleDeclarationContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::InitDeclaratorListContext* ReentParser::SimpleDeclarationContext::initDeclaratorList() {
  return getRuleContext<ReentParser::InitDeclaratorListContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::SimpleDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::SimpleDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleSimpleDeclaration;
}

void ReentParser::SimpleDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleDeclaration(this);
}

void ReentParser::SimpleDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleDeclaration(this);
}

ReentParser::SimpleDeclarationContext* ReentParser::simpleDeclaration() {
  SimpleDeclarationContext *_localctx = _tracker.createInstance<SimpleDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 228, ReentParser::RuleSimpleDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1599);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Cfunnel:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Class:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Const:
      case ReentParser::Constexpr:
      case ReentParser::Csem:
      case ReentParser::Cvar:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::Double:
      case ReentParser::End:
      case ReentParser::Enum:
      case ReentParser::Explicit:
      case ReentParser::Extern:
      case ReentParser::Float:
      case ReentParser::Friend:
      case ReentParser::Funnel:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Inline:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Markupdef:
      case ReentParser::Mutable:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Plan_item_type:
      case ReentParser::Plan_type:
      case ReentParser::Register:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Soft_transact_array:
      case ReentParser::Soft_transact_in:
      case ReentParser::Soft_transact_out:
      case ReentParser::Soft_transact_var:
      case ReentParser::Static:
      case ReentParser::Struct:
      case ReentParser::Thread_local:
      case ReentParser::Typedef:
      case ReentParser::Typename_:
      case ReentParser::Union:
      case ReentParser::Unsigned:
      case ReentParser::Vectorized:
      case ReentParser::Virtual:
      case ReentParser::Void:
      case ReentParser::Volatile:
      case ReentParser::Wchar:
      case ReentParser::Doublecolon:
      case ReentParser::Semi:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(1591);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 18) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 18)) & ((1ULL << (ReentParser::Auto - 18))
          | (1ULL << (ReentParser::Begin - 18))
          | (1ULL << (ReentParser::Bool - 18))
          | (1ULL << (ReentParser::Cfunnel - 18))
          | (1ULL << (ReentParser::Char - 18))
          | (1ULL << (ReentParser::Char16 - 18))
          | (1ULL << (ReentParser::Char32 - 18))
          | (1ULL << (ReentParser::Class - 18))
          | (1ULL << (ReentParser::Clustered - 18))
          | (1ULL << (ReentParser::Common - 18))
          | (1ULL << (ReentParser::Const - 18))
          | (1ULL << (ReentParser::Constexpr - 18))
          | (1ULL << (ReentParser::Csem - 18))
          | (1ULL << (ReentParser::Cvar - 18))
          | (1ULL << (ReentParser::Decltype - 18))
          | (1ULL << (ReentParser::Depends - 18))
          | (1ULL << (ReentParser::Double - 18))
          | (1ULL << (ReentParser::End - 18))
          | (1ULL << (ReentParser::Enum - 18))
          | (1ULL << (ReentParser::Explicit - 18))
          | (1ULL << (ReentParser::Extern - 18))
          | (1ULL << (ReentParser::Float - 18))
          | (1ULL << (ReentParser::Friend - 18))
          | (1ULL << (ReentParser::Funnel - 18))
          | (1ULL << (ReentParser::Global - 18))
          | (1ULL << (ReentParser::Gpu - 18))
          | (1ULL << (ReentParser::Id - 18))
          | (1ULL << (ReentParser::In - 18))
          | (1ULL << (ReentParser::Inline - 18))
          | (1ULL << (ReentParser::Int - 18))
          | (1ULL << (ReentParser::Local - 18))
          | (1ULL << (ReentParser::Long - 18))
          | (1ULL << (ReentParser::MarkPreCondition - 18))
          | (1ULL << (ReentParser::MarkState - 18))
          | (1ULL << (ReentParser::Markupdef - 18))
          | (1ULL << (ReentParser::Mutable - 18)))) != 0) || ((((_la - 85) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 85)) & ((1ULL << (ReentParser::Out - 85))
          | (1ULL << (ReentParser::Plan - 85))
          | (1ULL << (ReentParser::Plan_item_type - 85))
          | (1ULL << (ReentParser::Plan_type - 85))
          | (1ULL << (ReentParser::Register - 85))
          | (1ULL << (ReentParser::Reset - 85))
          | (1ULL << (ReentParser::Set - 85))
          | (1ULL << (ReentParser::Short - 85))
          | (1ULL << (ReentParser::Signed - 85))
          | (1ULL << (ReentParser::Soft_transact_array - 85))
          | (1ULL << (ReentParser::Soft_transact_in - 85))
          | (1ULL << (ReentParser::Soft_transact_out - 85))
          | (1ULL << (ReentParser::Soft_transact_var - 85))
          | (1ULL << (ReentParser::Static - 85))
          | (1ULL << (ReentParser::Struct - 85))
          | (1ULL << (ReentParser::Thread_local - 85))
          | (1ULL << (ReentParser::Typedef - 85))
          | (1ULL << (ReentParser::Typename_ - 85))
          | (1ULL << (ReentParser::Union - 85))
          | (1ULL << (ReentParser::Unsigned - 85))
          | (1ULL << (ReentParser::Vectorized - 85))
          | (1ULL << (ReentParser::Virtual - 85))
          | (1ULL << (ReentParser::Void - 85)))) != 0) || ((((_la - 149) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 149)) & ((1ULL << (ReentParser::Volatile - 149))
          | (1ULL << (ReentParser::Wchar - 149))
          | (1ULL << (ReentParser::Doublecolon - 149))
          | (1ULL << (ReentParser::Identifier - 149)))) != 0)) {
          setState(1587);
          declSpecifierSeq();
          setState(1589);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if ((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & ((1ULL << ReentParser::Begin)
            | (1ULL << ReentParser::Clustered)
            | (1ULL << ReentParser::Common)
            | (1ULL << ReentParser::Decltype)
            | (1ULL << ReentParser::Depends)
            | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
            | (1ULL << (ReentParser::Gpu - 64))
            | (1ULL << (ReentParser::Id - 64))
            | (1ULL << (ReentParser::In - 64))
            | (1ULL << (ReentParser::Local - 64))
            | (1ULL << (ReentParser::MarkPreCondition - 64))
            | (1ULL << (ReentParser::MarkState - 64))
            | (1ULL << (ReentParser::Operator - 64))
            | (1ULL << (ReentParser::Out - 64))
            | (1ULL << (ReentParser::Plan - 64))
            | (1ULL << (ReentParser::Reset - 64))
            | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
            | (1ULL << (ReentParser::LeftParen - 146))
            | (1ULL << (ReentParser::Star - 146))
            | (1ULL << (ReentParser::And - 146))
            | (1ULL << (ReentParser::Tilde - 146))
            | (1ULL << (ReentParser::AndAnd - 146))
            | (1ULL << (ReentParser::Doublecolon - 146))
            | (1ULL << (ReentParser::Ellipsis - 146))
            | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
            setState(1588);
            initDeclaratorList();
          }
        }
        setState(1593);
        match(ReentParser::Semi);
        break;
      }

      case ReentParser::Alignas:
      case ReentParser::LeftBracket: {
        enterOuterAlt(_localctx, 2);
        setState(1594);
        attributeSpecifierSeq();
        setState(1595);
        declSpecifierSeq();
        setState(1596);
        initDeclaratorList();
        setState(1597);
        match(ReentParser::Semi);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StaticAssertDeclarationContext ------------------------------------------------------------------

ReentParser::StaticAssertDeclarationContext::StaticAssertDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::StaticAssertDeclarationContext::Static_assert() {
  return getToken(ReentParser::Static_assert, 0);
}

tree::TerminalNode* ReentParser::StaticAssertDeclarationContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::StaticAssertDeclarationContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::StaticAssertDeclarationContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

tree::TerminalNode* ReentParser::StaticAssertDeclarationContext::StringLiteral() {
  return getToken(ReentParser::StringLiteral, 0);
}

tree::TerminalNode* ReentParser::StaticAssertDeclarationContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::StaticAssertDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::StaticAssertDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleStaticAssertDeclaration;
}

void ReentParser::StaticAssertDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStaticAssertDeclaration(this);
}

void ReentParser::StaticAssertDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStaticAssertDeclaration(this);
}

ReentParser::StaticAssertDeclarationContext* ReentParser::staticAssertDeclaration() {
  StaticAssertDeclarationContext *_localctx = _tracker.createInstance<StaticAssertDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 230, ReentParser::RuleStaticAssertDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1601);
    match(ReentParser::Static_assert);
    setState(1602);
    match(ReentParser::LeftParen);
    setState(1603);
    constantExpression();
    setState(1604);
    match(ReentParser::Comma);
    setState(1605);
    match(ReentParser::StringLiteral);
    setState(1606);
    match(ReentParser::RightParen);
    setState(1607);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyDeclarationContext ------------------------------------------------------------------

ReentParser::EmptyDeclarationContext::EmptyDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::EmptyDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::EmptyDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleEmptyDeclaration;
}

void ReentParser::EmptyDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyDeclaration(this);
}

void ReentParser::EmptyDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyDeclaration(this);
}

ReentParser::EmptyDeclarationContext* ReentParser::emptyDeclaration() {
  EmptyDeclarationContext *_localctx = _tracker.createInstance<EmptyDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 232, ReentParser::RuleEmptyDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1609);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeDeclarationContext ------------------------------------------------------------------

ReentParser::AttributeDeclarationContext::AttributeDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::AttributeDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

tree::TerminalNode* ReentParser::AttributeDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::AttributeDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleAttributeDeclaration;
}

void ReentParser::AttributeDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeDeclaration(this);
}

void ReentParser::AttributeDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeDeclaration(this);
}

ReentParser::AttributeDeclarationContext* ReentParser::attributeDeclaration() {
  AttributeDeclarationContext *_localctx = _tracker.createInstance<AttributeDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 234, ReentParser::RuleAttributeDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1611);
    attributeSpecifierSeq();
    setState(1612);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclSpecifierContext ------------------------------------------------------------------

ReentParser::DeclSpecifierContext::DeclSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::DeclSpecifierContext::Friend() {
  return getToken(ReentParser::Friend, 0);
}

tree::TerminalNode* ReentParser::DeclSpecifierContext::Typedef() {
  return getToken(ReentParser::Typedef, 0);
}

tree::TerminalNode* ReentParser::DeclSpecifierContext::Markupdef() {
  return getToken(ReentParser::Markupdef, 0);
}

tree::TerminalNode* ReentParser::DeclSpecifierContext::Constexpr() {
  return getToken(ReentParser::Constexpr, 0);
}

ReentParser::StorageClassSpecifierContext* ReentParser::DeclSpecifierContext::storageClassSpecifier() {
  return getRuleContext<ReentParser::StorageClassSpecifierContext>(0);
}

ReentParser::TypeSpecifierContext* ReentParser::DeclSpecifierContext::typeSpecifier() {
  return getRuleContext<ReentParser::TypeSpecifierContext>(0);
}

ReentParser::FunctionSpecifierContext* ReentParser::DeclSpecifierContext::functionSpecifier() {
  return getRuleContext<ReentParser::FunctionSpecifierContext>(0);
}


size_t ReentParser::DeclSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleDeclSpecifier;
}

void ReentParser::DeclSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclSpecifier(this);
}

void ReentParser::DeclSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclSpecifier(this);
}

ReentParser::DeclSpecifierContext* ReentParser::declSpecifier() {
  DeclSpecifierContext *_localctx = _tracker.createInstance<DeclSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 236, ReentParser::RuleDeclSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1621);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Friend: {
        enterOuterAlt(_localctx, 1);
        setState(1614);
        match(ReentParser::Friend);
        break;
      }

      case ReentParser::Typedef: {
        enterOuterAlt(_localctx, 2);
        setState(1615);
        match(ReentParser::Typedef);
        break;
      }

      case ReentParser::Markupdef: {
        enterOuterAlt(_localctx, 3);
        setState(1616);
        match(ReentParser::Markupdef);
        break;
      }

      case ReentParser::Constexpr: {
        enterOuterAlt(_localctx, 4);
        setState(1617);
        match(ReentParser::Constexpr);
        break;
      }

      case ReentParser::Extern:
      case ReentParser::Mutable:
      case ReentParser::Register:
      case ReentParser::Static:
      case ReentParser::Thread_local: {
        enterOuterAlt(_localctx, 5);
        setState(1618);
        storageClassSpecifier();
        break;
      }

      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Cfunnel:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Class:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Const:
      case ReentParser::Csem:
      case ReentParser::Cvar:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::Double:
      case ReentParser::End:
      case ReentParser::Enum:
      case ReentParser::Float:
      case ReentParser::Funnel:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Plan_item_type:
      case ReentParser::Plan_type:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Soft_transact_array:
      case ReentParser::Soft_transact_in:
      case ReentParser::Soft_transact_out:
      case ReentParser::Soft_transact_var:
      case ReentParser::Struct:
      case ReentParser::Typename_:
      case ReentParser::Union:
      case ReentParser::Unsigned:
      case ReentParser::Vectorized:
      case ReentParser::Void:
      case ReentParser::Volatile:
      case ReentParser::Wchar:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 6);
        setState(1619);
        typeSpecifier();
        break;
      }

      case ReentParser::Explicit:
      case ReentParser::Inline:
      case ReentParser::Virtual: {
        enterOuterAlt(_localctx, 7);
        setState(1620);
        functionSpecifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclSpecifierSeqContext ------------------------------------------------------------------

ReentParser::DeclSpecifierSeqContext::DeclSpecifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::DeclSpecifierContext *> ReentParser::DeclSpecifierSeqContext::declSpecifier() {
  return getRuleContexts<ReentParser::DeclSpecifierContext>();
}

ReentParser::DeclSpecifierContext* ReentParser::DeclSpecifierSeqContext::declSpecifier(size_t i) {
  return getRuleContext<ReentParser::DeclSpecifierContext>(i);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::DeclSpecifierSeqContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::DeclSpecifierSeqContext::getRuleIndex() const {
  return ReentParser::RuleDeclSpecifierSeq;
}

void ReentParser::DeclSpecifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclSpecifierSeq(this);
}

void ReentParser::DeclSpecifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclSpecifierSeq(this);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::declSpecifierSeq() {
  DeclSpecifierSeqContext *_localctx = _tracker.createInstance<DeclSpecifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 238, ReentParser::RuleDeclSpecifierSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1624); 
    _errHandler->sync(this);
    alt = 1 + 1;
    do {
      switch (alt) {
        case 1 + 1: {
              setState(1623);
              declSpecifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1626); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx);
    } while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 134, _ctx)) {
    case 1: {
      setState(1628);
      attributeSpecifierSeq();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_special_typeContext ------------------------------------------------------------------

ReentParser::Reent_special_typeContext::Reent_special_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Reent_funnel_typeContext* ReentParser::Reent_special_typeContext::reent_funnel_type() {
  return getRuleContext<ReentParser::Reent_funnel_typeContext>(0);
}

ReentParser::Reent_cfunnel_typeContext* ReentParser::Reent_special_typeContext::reent_cfunnel_type() {
  return getRuleContext<ReentParser::Reent_cfunnel_typeContext>(0);
}

ReentParser::Reent_cvar_typeContext* ReentParser::Reent_special_typeContext::reent_cvar_type() {
  return getRuleContext<ReentParser::Reent_cvar_typeContext>(0);
}

ReentParser::Reent_csem_typeContext* ReentParser::Reent_special_typeContext::reent_csem_type() {
  return getRuleContext<ReentParser::Reent_csem_typeContext>(0);
}

ReentParser::Reent_soft_transact_arrayContext* ReentParser::Reent_special_typeContext::reent_soft_transact_array() {
  return getRuleContext<ReentParser::Reent_soft_transact_arrayContext>(0);
}

ReentParser::Reent_soft_transact_varContext* ReentParser::Reent_special_typeContext::reent_soft_transact_var() {
  return getRuleContext<ReentParser::Reent_soft_transact_varContext>(0);
}

ReentParser::Reent_soft_transact_inContext* ReentParser::Reent_special_typeContext::reent_soft_transact_in() {
  return getRuleContext<ReentParser::Reent_soft_transact_inContext>(0);
}

ReentParser::Reent_soft_transact_outContext* ReentParser::Reent_special_typeContext::reent_soft_transact_out() {
  return getRuleContext<ReentParser::Reent_soft_transact_outContext>(0);
}

ReentParser::Reent_plan_typeContext* ReentParser::Reent_special_typeContext::reent_plan_type() {
  return getRuleContext<ReentParser::Reent_plan_typeContext>(0);
}

ReentParser::Reent_plan_item_typeContext* ReentParser::Reent_special_typeContext::reent_plan_item_type() {
  return getRuleContext<ReentParser::Reent_plan_item_typeContext>(0);
}


size_t ReentParser::Reent_special_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_special_type;
}

void ReentParser::Reent_special_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_special_type(this);
}

void ReentParser::Reent_special_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_special_type(this);
}

ReentParser::Reent_special_typeContext* ReentParser::reent_special_type() {
  Reent_special_typeContext *_localctx = _tracker.createInstance<Reent_special_typeContext>(_ctx, getState());
  enterRule(_localctx, 240, ReentParser::RuleReent_special_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1641);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Funnel: {
        enterOuterAlt(_localctx, 1);
        setState(1631);
        reent_funnel_type();
        break;
      }

      case ReentParser::Cfunnel: {
        enterOuterAlt(_localctx, 2);
        setState(1632);
        reent_cfunnel_type();
        break;
      }

      case ReentParser::Cvar: {
        enterOuterAlt(_localctx, 3);
        setState(1633);
        reent_cvar_type();
        break;
      }

      case ReentParser::Csem: {
        enterOuterAlt(_localctx, 4);
        setState(1634);
        reent_csem_type();
        break;
      }

      case ReentParser::Soft_transact_array: {
        enterOuterAlt(_localctx, 5);
        setState(1635);
        reent_soft_transact_array();
        break;
      }

      case ReentParser::Soft_transact_var: {
        enterOuterAlt(_localctx, 6);
        setState(1636);
        reent_soft_transact_var();
        break;
      }

      case ReentParser::Soft_transact_in: {
        enterOuterAlt(_localctx, 7);
        setState(1637);
        reent_soft_transact_in();
        break;
      }

      case ReentParser::Soft_transact_out: {
        enterOuterAlt(_localctx, 8);
        setState(1638);
        reent_soft_transact_out();
        break;
      }

      case ReentParser::Plan_type: {
        enterOuterAlt(_localctx, 9);
        setState(1639);
        reent_plan_type();
        break;
      }

      case ReentParser::Plan_item_type: {
        enterOuterAlt(_localctx, 10);
        setState(1640);
        reent_plan_item_type();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_funnel_typeContext ------------------------------------------------------------------

ReentParser::Reent_funnel_typeContext::Reent_funnel_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_funnel_typeContext::Funnel() {
  return getToken(ReentParser::Funnel, 0);
}

tree::TerminalNode* ReentParser::Reent_funnel_typeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_funnel_typeContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_funnel_typeContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_funnel_typeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_funnel_typeContext::In() {
  return getToken(ReentParser::In, 0);
}

tree::TerminalNode* ReentParser::Reent_funnel_typeContext::Out() {
  return getToken(ReentParser::Out, 0);
}


size_t ReentParser::Reent_funnel_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_funnel_type;
}

void ReentParser::Reent_funnel_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_funnel_type(this);
}

void ReentParser::Reent_funnel_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_funnel_type(this);
}

ReentParser::Reent_funnel_typeContext* ReentParser::reent_funnel_type() {
  Reent_funnel_typeContext *_localctx = _tracker.createInstance<Reent_funnel_typeContext>(_ctx, getState());
  enterRule(_localctx, 242, ReentParser::RuleReent_funnel_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1643);
    match(ReentParser::Funnel);
    setState(1644);
    match(ReentParser::LeftParen);
    setState(1645);
    _la = _input->LA(1);
    if (!(_la == ReentParser::In

    || _la == ReentParser::Out)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1646);
    match(ReentParser::Comma);
    setState(1647);
    simpleTypeSpecifier();
    setState(1648);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_cfunnel_typeContext ------------------------------------------------------------------

ReentParser::Reent_cfunnel_typeContext::Reent_cfunnel_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_cfunnel_typeContext::Cfunnel() {
  return getToken(ReentParser::Cfunnel, 0);
}

tree::TerminalNode* ReentParser::Reent_cfunnel_typeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_cfunnel_typeContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_cfunnel_typeContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_cfunnel_typeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_cfunnel_typeContext::In() {
  return getToken(ReentParser::In, 0);
}

tree::TerminalNode* ReentParser::Reent_cfunnel_typeContext::Out() {
  return getToken(ReentParser::Out, 0);
}


size_t ReentParser::Reent_cfunnel_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_cfunnel_type;
}

void ReentParser::Reent_cfunnel_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_cfunnel_type(this);
}

void ReentParser::Reent_cfunnel_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_cfunnel_type(this);
}

ReentParser::Reent_cfunnel_typeContext* ReentParser::reent_cfunnel_type() {
  Reent_cfunnel_typeContext *_localctx = _tracker.createInstance<Reent_cfunnel_typeContext>(_ctx, getState());
  enterRule(_localctx, 244, ReentParser::RuleReent_cfunnel_type);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1650);
    match(ReentParser::Cfunnel);

    		if (!allow_clustered)
    			throw FailedPredicateException(this, "using cfunnel without previous '#pragma plan clustered'");
    	
    setState(1652);
    match(ReentParser::LeftParen);
    setState(1653);
    _la = _input->LA(1);
    if (!(_la == ReentParser::In

    || _la == ReentParser::Out)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1654);
    match(ReentParser::Comma);
    setState(1655);
    simpleTypeSpecifier();
    setState(1656);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_cvar_typeContext ------------------------------------------------------------------

ReentParser::Reent_cvar_typeContext::Reent_cvar_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_cvar_typeContext::Cvar() {
  return getToken(ReentParser::Cvar, 0);
}

tree::TerminalNode* ReentParser::Reent_cvar_typeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_cvar_typeContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_cvar_typeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_cvar_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_cvar_type;
}

void ReentParser::Reent_cvar_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_cvar_type(this);
}

void ReentParser::Reent_cvar_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_cvar_type(this);
}

ReentParser::Reent_cvar_typeContext* ReentParser::reent_cvar_type() {
  Reent_cvar_typeContext *_localctx = _tracker.createInstance<Reent_cvar_typeContext>(_ctx, getState());
  enterRule(_localctx, 246, ReentParser::RuleReent_cvar_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1658);
    match(ReentParser::Cvar);

    		if (!allow_clustered)
    			throw FailedPredicateException(this, "using cvar without previous '#pragma plan clustered'");
    	
    setState(1660);
    match(ReentParser::LeftParen);
    setState(1661);
    simpleTypeSpecifier();
    setState(1662);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_csem_typeContext ------------------------------------------------------------------

ReentParser::Reent_csem_typeContext::Reent_csem_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_csem_typeContext::Csem() {
  return getToken(ReentParser::Csem, 0);
}


size_t ReentParser::Reent_csem_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_csem_type;
}

void ReentParser::Reent_csem_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_csem_type(this);
}

void ReentParser::Reent_csem_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_csem_type(this);
}

ReentParser::Reent_csem_typeContext* ReentParser::reent_csem_type() {
  Reent_csem_typeContext *_localctx = _tracker.createInstance<Reent_csem_typeContext>(_ctx, getState());
  enterRule(_localctx, 248, ReentParser::RuleReent_csem_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1664);
    match(ReentParser::Csem);

    		if (!allow_clustered)
    			throw FailedPredicateException(this, "using plan_csem_t without previous '#pragma plan clustered'");
    	
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_soft_transact_arrayContext ------------------------------------------------------------------

ReentParser::Reent_soft_transact_arrayContext::Reent_soft_transact_arrayContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_soft_transact_arrayContext::Soft_transact_array() {
  return getToken(ReentParser::Soft_transact_array, 0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_arrayContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_soft_transact_arrayContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_arrayContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_soft_transact_arrayContext::getRuleIndex() const {
  return ReentParser::RuleReent_soft_transact_array;
}

void ReentParser::Reent_soft_transact_arrayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_soft_transact_array(this);
}

void ReentParser::Reent_soft_transact_arrayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_soft_transact_array(this);
}

ReentParser::Reent_soft_transact_arrayContext* ReentParser::reent_soft_transact_array() {
  Reent_soft_transact_arrayContext *_localctx = _tracker.createInstance<Reent_soft_transact_arrayContext>(_ctx, getState());
  enterRule(_localctx, 250, ReentParser::RuleReent_soft_transact_array);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1667);
    match(ReentParser::Soft_transact_array);
    setState(1668);
    match(ReentParser::LeftParen);
    setState(1669);
    simpleTypeSpecifier();
    setState(1670);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_soft_transact_varContext ------------------------------------------------------------------

ReentParser::Reent_soft_transact_varContext::Reent_soft_transact_varContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_soft_transact_varContext::Soft_transact_var() {
  return getToken(ReentParser::Soft_transact_var, 0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_varContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_soft_transact_varContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_varContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_soft_transact_varContext::getRuleIndex() const {
  return ReentParser::RuleReent_soft_transact_var;
}

void ReentParser::Reent_soft_transact_varContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_soft_transact_var(this);
}

void ReentParser::Reent_soft_transact_varContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_soft_transact_var(this);
}

ReentParser::Reent_soft_transact_varContext* ReentParser::reent_soft_transact_var() {
  Reent_soft_transact_varContext *_localctx = _tracker.createInstance<Reent_soft_transact_varContext>(_ctx, getState());
  enterRule(_localctx, 252, ReentParser::RuleReent_soft_transact_var);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1672);
    match(ReentParser::Soft_transact_var);
    setState(1673);
    match(ReentParser::LeftParen);
    setState(1674);
    simpleTypeSpecifier();
    setState(1675);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_soft_transact_inContext ------------------------------------------------------------------

ReentParser::Reent_soft_transact_inContext::Reent_soft_transact_inContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_soft_transact_inContext::Soft_transact_in() {
  return getToken(ReentParser::Soft_transact_in, 0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_inContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_soft_transact_inContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_inContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_soft_transact_inContext::getRuleIndex() const {
  return ReentParser::RuleReent_soft_transact_in;
}

void ReentParser::Reent_soft_transact_inContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_soft_transact_in(this);
}

void ReentParser::Reent_soft_transact_inContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_soft_transact_in(this);
}

ReentParser::Reent_soft_transact_inContext* ReentParser::reent_soft_transact_in() {
  Reent_soft_transact_inContext *_localctx = _tracker.createInstance<Reent_soft_transact_inContext>(_ctx, getState());
  enterRule(_localctx, 254, ReentParser::RuleReent_soft_transact_in);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1677);
    match(ReentParser::Soft_transact_in);
    setState(1678);
    match(ReentParser::LeftParen);
    setState(1679);
    simpleTypeSpecifier();
    setState(1680);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_soft_transact_outContext ------------------------------------------------------------------

ReentParser::Reent_soft_transact_outContext::Reent_soft_transact_outContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_soft_transact_outContext::Soft_transact_out() {
  return getToken(ReentParser::Soft_transact_out, 0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_outContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::Reent_soft_transact_outContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::Reent_soft_transact_outContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_soft_transact_outContext::getRuleIndex() const {
  return ReentParser::RuleReent_soft_transact_out;
}

void ReentParser::Reent_soft_transact_outContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_soft_transact_out(this);
}

void ReentParser::Reent_soft_transact_outContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_soft_transact_out(this);
}

ReentParser::Reent_soft_transact_outContext* ReentParser::reent_soft_transact_out() {
  Reent_soft_transact_outContext *_localctx = _tracker.createInstance<Reent_soft_transact_outContext>(_ctx, getState());
  enterRule(_localctx, 256, ReentParser::RuleReent_soft_transact_out);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1682);
    match(ReentParser::Soft_transact_out);
    setState(1683);
    match(ReentParser::LeftParen);
    setState(1684);
    simpleTypeSpecifier();
    setState(1685);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_plan_typeContext ------------------------------------------------------------------

ReentParser::Reent_plan_typeContext::Reent_plan_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_plan_typeContext::Plan_type() {
  return getToken(ReentParser::Plan_type, 0);
}

tree::TerminalNode* ReentParser::Reent_plan_typeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_plan_typeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_plan_typeContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}


size_t ReentParser::Reent_plan_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_plan_type;
}

void ReentParser::Reent_plan_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_plan_type(this);
}

void ReentParser::Reent_plan_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_plan_type(this);
}

ReentParser::Reent_plan_typeContext* ReentParser::reent_plan_type() {
  Reent_plan_typeContext *_localctx = _tracker.createInstance<Reent_plan_typeContext>(_ctx, getState());
  enterRule(_localctx, 258, ReentParser::RuleReent_plan_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1687);
    match(ReentParser::Plan_type);
    setState(1688);
    match(ReentParser::LeftParen);
    setState(1689);
    dynamic_cast<Reent_plan_typeContext *>(_localctx)->ident = match(ReentParser::Identifier);
     std::map<std::string,int>::iterator it = reenterables.find((dynamic_cast<Reent_plan_typeContext *>(_localctx)->ident != nullptr ? dynamic_cast<Reent_plan_typeContext *>(_localctx)->ident->getText() : ""));
    	  if (it == reenterables.end() || (it->second & static_flag) == 0)
    		throw FailedPredicateException(this, "Static reenterable procedure's name expected");
    	
    setState(1691);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_plan_item_typeContext ------------------------------------------------------------------

ReentParser::Reent_plan_item_typeContext::Reent_plan_item_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_plan_item_typeContext::Plan_item_type() {
  return getToken(ReentParser::Plan_item_type, 0);
}

tree::TerminalNode* ReentParser::Reent_plan_item_typeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_plan_item_typeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Reent_plan_item_typeContext::Identifier() {
  return getToken(ReentParser::Identifier, 0);
}


size_t ReentParser::Reent_plan_item_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_plan_item_type;
}

void ReentParser::Reent_plan_item_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_plan_item_type(this);
}

void ReentParser::Reent_plan_item_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_plan_item_type(this);
}

ReentParser::Reent_plan_item_typeContext* ReentParser::reent_plan_item_type() {
  Reent_plan_item_typeContext *_localctx = _tracker.createInstance<Reent_plan_item_typeContext>(_ctx, getState());
  enterRule(_localctx, 260, ReentParser::RuleReent_plan_item_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1693);
    match(ReentParser::Plan_item_type);
    setState(1694);
    match(ReentParser::LeftParen);
    setState(1695);
    dynamic_cast<Reent_plan_item_typeContext *>(_localctx)->ident = match(ReentParser::Identifier);
     std::map<std::string,int>::iterator it = reenterables.find((dynamic_cast<Reent_plan_item_typeContext *>(_localctx)->ident != nullptr ? dynamic_cast<Reent_plan_item_typeContext *>(_localctx)->ident->getText() : ""));
    	  if (it == reenterables.end() || (it->second & static_flag) == 0)
    		throw FailedPredicateException(this, "Static reenterable procedure's name expected");
    	
    setState(1697);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageClassSpecifierContext ------------------------------------------------------------------

ReentParser::StorageClassSpecifierContext::StorageClassSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::StorageClassSpecifierContext::Register() {
  return getToken(ReentParser::Register, 0);
}

tree::TerminalNode* ReentParser::StorageClassSpecifierContext::Static() {
  return getToken(ReentParser::Static, 0);
}

tree::TerminalNode* ReentParser::StorageClassSpecifierContext::Thread_local() {
  return getToken(ReentParser::Thread_local, 0);
}

tree::TerminalNode* ReentParser::StorageClassSpecifierContext::Extern() {
  return getToken(ReentParser::Extern, 0);
}

tree::TerminalNode* ReentParser::StorageClassSpecifierContext::Mutable() {
  return getToken(ReentParser::Mutable, 0);
}


size_t ReentParser::StorageClassSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleStorageClassSpecifier;
}

void ReentParser::StorageClassSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageClassSpecifier(this);
}

void ReentParser::StorageClassSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageClassSpecifier(this);
}

ReentParser::StorageClassSpecifierContext* ReentParser::storageClassSpecifier() {
  StorageClassSpecifierContext *_localctx = _tracker.createInstance<StorageClassSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 262, ReentParser::RuleStorageClassSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1699);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Extern || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (ReentParser::Mutable - 79))
      | (1ULL << (ReentParser::Register - 79))
      | (1ULL << (ReentParser::Static - 79))
      | (1ULL << (ReentParser::Thread_local - 79)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionSpecifierContext ------------------------------------------------------------------

ReentParser::FunctionSpecifierContext::FunctionSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::FunctionSpecifierContext::Inline() {
  return getToken(ReentParser::Inline, 0);
}

tree::TerminalNode* ReentParser::FunctionSpecifierContext::Virtual() {
  return getToken(ReentParser::Virtual, 0);
}

tree::TerminalNode* ReentParser::FunctionSpecifierContext::Explicit() {
  return getToken(ReentParser::Explicit, 0);
}


size_t ReentParser::FunctionSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleFunctionSpecifier;
}

void ReentParser::FunctionSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionSpecifier(this);
}

void ReentParser::FunctionSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionSpecifier(this);
}

ReentParser::FunctionSpecifierContext* ReentParser::functionSpecifier() {
  FunctionSpecifierContext *_localctx = _tracker.createInstance<FunctionSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 264, ReentParser::RuleFunctionSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1701);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Explicit

    || _la == ReentParser::Inline || _la == ReentParser::Virtual)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypedefNameContext ------------------------------------------------------------------

ReentParser::TypedefNameContext::TypedefNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::TypedefNameContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::TypedefNameContext::getRuleIndex() const {
  return ReentParser::RuleTypedefName;
}

void ReentParser::TypedefNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypedefName(this);
}

void ReentParser::TypedefNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypedefName(this);
}

ReentParser::TypedefNameContext* ReentParser::typedefName() {
  TypedefNameContext *_localctx = _tracker.createInstance<TypedefNameContext>(_ctx, getState());
  enterRule(_localctx, 266, ReentParser::RuleTypedefName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1703);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSpecifierContext ------------------------------------------------------------------

ReentParser::TypeSpecifierContext::TypeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Reent_special_typeContext* ReentParser::TypeSpecifierContext::reent_special_type() {
  return getRuleContext<ReentParser::Reent_special_typeContext>(0);
}

ReentParser::ClassSpecifierContext* ReentParser::TypeSpecifierContext::classSpecifier() {
  return getRuleContext<ReentParser::ClassSpecifierContext>(0);
}

ReentParser::TrailingTypeSpecifierContext* ReentParser::TypeSpecifierContext::trailingTypeSpecifier() {
  return getRuleContext<ReentParser::TrailingTypeSpecifierContext>(0);
}

ReentParser::EnumSpecifierContext* ReentParser::TypeSpecifierContext::enumSpecifier() {
  return getRuleContext<ReentParser::EnumSpecifierContext>(0);
}


size_t ReentParser::TypeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleTypeSpecifier;
}

void ReentParser::TypeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeSpecifier(this);
}

void ReentParser::TypeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeSpecifier(this);
}

ReentParser::TypeSpecifierContext* ReentParser::typeSpecifier() {
  TypeSpecifierContext *_localctx = _tracker.createInstance<TypeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 268, ReentParser::RuleTypeSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1709);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1705);
      reent_special_type();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1706);
      classSpecifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1707);
      trailingTypeSpecifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1708);
      enumSpecifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrailingTypeSpecifierContext ------------------------------------------------------------------

ReentParser::TrailingTypeSpecifierContext::TrailingTypeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ElaboratedTypeSpecifierContext* ReentParser::TrailingTypeSpecifierContext::elaboratedTypeSpecifier() {
  return getRuleContext<ReentParser::ElaboratedTypeSpecifierContext>(0);
}

ReentParser::TypeNameSpecifierContext* ReentParser::TrailingTypeSpecifierContext::typeNameSpecifier() {
  return getRuleContext<ReentParser::TypeNameSpecifierContext>(0);
}

ReentParser::CvQualifierContext* ReentParser::TrailingTypeSpecifierContext::cvQualifier() {
  return getRuleContext<ReentParser::CvQualifierContext>(0);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::TrailingTypeSpecifierContext::simpleTypeSpecifier() {
  return getRuleContext<ReentParser::SimpleTypeSpecifierContext>(0);
}


size_t ReentParser::TrailingTypeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleTrailingTypeSpecifier;
}

void ReentParser::TrailingTypeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailingTypeSpecifier(this);
}

void ReentParser::TrailingTypeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailingTypeSpecifier(this);
}

ReentParser::TrailingTypeSpecifierContext* ReentParser::trailingTypeSpecifier() {
  TrailingTypeSpecifierContext *_localctx = _tracker.createInstance<TrailingTypeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 270, ReentParser::RuleTrailingTypeSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1715);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Class:
      case ReentParser::Enum:
      case ReentParser::Struct: {
        enterOuterAlt(_localctx, 1);
        setState(1711);
        elaboratedTypeSpecifier();
        break;
      }

      case ReentParser::Typename_: {
        enterOuterAlt(_localctx, 2);
        setState(1712);
        typeNameSpecifier();
        break;
      }

      case ReentParser::Const:
      case ReentParser::Volatile: {
        enterOuterAlt(_localctx, 3);
        setState(1713);
        cvQualifier();
        break;
      }

      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::Double:
      case ReentParser::End:
      case ReentParser::Float:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Unsigned:
      case ReentParser::Vectorized:
      case ReentParser::Void:
      case ReentParser::Wchar:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 4);
        setState(1714);
        simpleTypeSpecifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeSpecifierSeqContext ------------------------------------------------------------------

ReentParser::TypeSpecifierSeqContext::TypeSpecifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::TypeSpecifierContext *> ReentParser::TypeSpecifierSeqContext::typeSpecifier() {
  return getRuleContexts<ReentParser::TypeSpecifierContext>();
}

ReentParser::TypeSpecifierContext* ReentParser::TypeSpecifierSeqContext::typeSpecifier(size_t i) {
  return getRuleContext<ReentParser::TypeSpecifierContext>(i);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::TypeSpecifierSeqContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::TypeSpecifierSeqContext::getRuleIndex() const {
  return ReentParser::RuleTypeSpecifierSeq;
}

void ReentParser::TypeSpecifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeSpecifierSeq(this);
}

void ReentParser::TypeSpecifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeSpecifierSeq(this);
}

ReentParser::TypeSpecifierSeqContext* ReentParser::typeSpecifierSeq() {
  TypeSpecifierSeqContext *_localctx = _tracker.createInstance<TypeSpecifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 272, ReentParser::RuleTypeSpecifierSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1718); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1717);
              typeSpecifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1720); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1723);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      setState(1722);
      attributeSpecifierSeq();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrailingTypeSpecifierSeqContext ------------------------------------------------------------------

ReentParser::TrailingTypeSpecifierSeqContext::TrailingTypeSpecifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::TrailingTypeSpecifierContext *> ReentParser::TrailingTypeSpecifierSeqContext::trailingTypeSpecifier() {
  return getRuleContexts<ReentParser::TrailingTypeSpecifierContext>();
}

ReentParser::TrailingTypeSpecifierContext* ReentParser::TrailingTypeSpecifierSeqContext::trailingTypeSpecifier(size_t i) {
  return getRuleContext<ReentParser::TrailingTypeSpecifierContext>(i);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::TrailingTypeSpecifierSeqContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::TrailingTypeSpecifierSeqContext::getRuleIndex() const {
  return ReentParser::RuleTrailingTypeSpecifierSeq;
}

void ReentParser::TrailingTypeSpecifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailingTypeSpecifierSeq(this);
}

void ReentParser::TrailingTypeSpecifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailingTypeSpecifierSeq(this);
}

ReentParser::TrailingTypeSpecifierSeqContext* ReentParser::trailingTypeSpecifierSeq() {
  TrailingTypeSpecifierSeqContext *_localctx = _tracker.createInstance<TrailingTypeSpecifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 274, ReentParser::RuleTrailingTypeSpecifierSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1726); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1725);
              trailingTypeSpecifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1728); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(1731);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 141, _ctx)) {
    case 1: {
      setState(1730);
      attributeSpecifierSeq();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleTypeLengthModifierContext ------------------------------------------------------------------

ReentParser::SimpleTypeLengthModifierContext::SimpleTypeLengthModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::SimpleTypeLengthModifierContext::Short() {
  return getToken(ReentParser::Short, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeLengthModifierContext::Long() {
  return getToken(ReentParser::Long, 0);
}


size_t ReentParser::SimpleTypeLengthModifierContext::getRuleIndex() const {
  return ReentParser::RuleSimpleTypeLengthModifier;
}

void ReentParser::SimpleTypeLengthModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleTypeLengthModifier(this);
}

void ReentParser::SimpleTypeLengthModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleTypeLengthModifier(this);
}

ReentParser::SimpleTypeLengthModifierContext* ReentParser::simpleTypeLengthModifier() {
  SimpleTypeLengthModifierContext *_localctx = _tracker.createInstance<SimpleTypeLengthModifierContext>(_ctx, getState());
  enterRule(_localctx, 276, ReentParser::RuleSimpleTypeLengthModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1733);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Long

    || _la == ReentParser::Short)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleTypeSignednessModifierContext ------------------------------------------------------------------

ReentParser::SimpleTypeSignednessModifierContext::SimpleTypeSignednessModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::SimpleTypeSignednessModifierContext::Unsigned() {
  return getToken(ReentParser::Unsigned, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSignednessModifierContext::Signed() {
  return getToken(ReentParser::Signed, 0);
}


size_t ReentParser::SimpleTypeSignednessModifierContext::getRuleIndex() const {
  return ReentParser::RuleSimpleTypeSignednessModifier;
}

void ReentParser::SimpleTypeSignednessModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleTypeSignednessModifier(this);
}

void ReentParser::SimpleTypeSignednessModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleTypeSignednessModifier(this);
}

ReentParser::SimpleTypeSignednessModifierContext* ReentParser::simpleTypeSignednessModifier() {
  SimpleTypeSignednessModifierContext *_localctx = _tracker.createInstance<SimpleTypeSignednessModifierContext>(_ctx, getState());
  enterRule(_localctx, 278, ReentParser::RuleSimpleTypeSignednessModifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1735);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Signed

    || _la == ReentParser::Unsigned)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleTypeSpecifierContext ------------------------------------------------------------------

ReentParser::SimpleTypeSpecifierContext::SimpleTypeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TheTypeNameContext* ReentParser::SimpleTypeSpecifierContext::theTypeName() {
  return getRuleContext<ReentParser::TheTypeNameContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::SimpleTypeSpecifierContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Template() {
  return getToken(ReentParser::Template, 0);
}

ReentParser::SimpleTemplateIdContext* ReentParser::SimpleTypeSpecifierContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

ReentParser::SimpleTypeSignednessModifierContext* ReentParser::SimpleTypeSpecifierContext::simpleTypeSignednessModifier() {
  return getRuleContext<ReentParser::SimpleTypeSignednessModifierContext>(0);
}

std::vector<ReentParser::SimpleTypeLengthModifierContext *> ReentParser::SimpleTypeSpecifierContext::simpleTypeLengthModifier() {
  return getRuleContexts<ReentParser::SimpleTypeLengthModifierContext>();
}

ReentParser::SimpleTypeLengthModifierContext* ReentParser::SimpleTypeSpecifierContext::simpleTypeLengthModifier(size_t i) {
  return getRuleContext<ReentParser::SimpleTypeLengthModifierContext>(i);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Char() {
  return getToken(ReentParser::Char, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Char16() {
  return getToken(ReentParser::Char16, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Char32() {
  return getToken(ReentParser::Char32, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Wchar() {
  return getToken(ReentParser::Wchar, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Bool() {
  return getToken(ReentParser::Bool, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Int() {
  return getToken(ReentParser::Int, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Float() {
  return getToken(ReentParser::Float, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Double() {
  return getToken(ReentParser::Double, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Void() {
  return getToken(ReentParser::Void, 0);
}

tree::TerminalNode* ReentParser::SimpleTypeSpecifierContext::Auto() {
  return getToken(ReentParser::Auto, 0);
}

ReentParser::DecltypeSpecifierContext* ReentParser::SimpleTypeSpecifierContext::decltypeSpecifier() {
  return getRuleContext<ReentParser::DecltypeSpecifierContext>(0);
}


size_t ReentParser::SimpleTypeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleSimpleTypeSpecifier;
}

void ReentParser::SimpleTypeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleTypeSpecifier(this);
}

void ReentParser::SimpleTypeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleTypeSpecifier(this);
}

ReentParser::SimpleTypeSpecifierContext* ReentParser::simpleTypeSpecifier() {
  SimpleTypeSpecifierContext *_localctx = _tracker.createInstance<SimpleTypeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 280, ReentParser::RuleSimpleTypeSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(1789);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1738);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
      case 1: {
        setState(1737);
        nestedNameSpecifier(0);
        break;
      }

      default:
        break;
      }
      setState(1740);
      theTypeName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1741);
      nestedNameSpecifier(0);
      setState(1742);
      match(ReentParser::Template);
      setState(1743);
      simpleTemplateId();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1745);
      simpleTypeSignednessModifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1747);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Signed

      || _la == ReentParser::Unsigned) {
        setState(1746);
        simpleTypeSignednessModifier();
      }
      setState(1750); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1749);
                simpleTypeLengthModifier();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1752); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1755);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Signed

      || _la == ReentParser::Unsigned) {
        setState(1754);
        simpleTypeSignednessModifier();
      }
      setState(1757);
      match(ReentParser::Char);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1759);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Signed

      || _la == ReentParser::Unsigned) {
        setState(1758);
        simpleTypeSignednessModifier();
      }
      setState(1761);
      match(ReentParser::Char16);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1763);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Signed

      || _la == ReentParser::Unsigned) {
        setState(1762);
        simpleTypeSignednessModifier();
      }
      setState(1765);
      match(ReentParser::Char32);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1767);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Signed

      || _la == ReentParser::Unsigned) {
        setState(1766);
        simpleTypeSignednessModifier();
      }
      setState(1769);
      match(ReentParser::Wchar);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1770);
      match(ReentParser::Bool);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1772);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Signed

      || _la == ReentParser::Unsigned) {
        setState(1771);
        simpleTypeSignednessModifier();
      }
      setState(1777);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == ReentParser::Long

      || _la == ReentParser::Short) {
        setState(1774);
        simpleTypeLengthModifier();
        setState(1779);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1780);
      match(ReentParser::Int);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1781);
      match(ReentParser::Float);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1783);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Long

      || _la == ReentParser::Short) {
        setState(1782);
        simpleTypeLengthModifier();
      }
      setState(1785);
      match(ReentParser::Double);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1786);
      match(ReentParser::Void);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1787);
      match(ReentParser::Auto);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1788);
      decltypeSpecifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TheTypeNameContext ------------------------------------------------------------------

ReentParser::TheTypeNameContext::TheTypeNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassNameContext* ReentParser::TheTypeNameContext::className() {
  return getRuleContext<ReentParser::ClassNameContext>(0);
}

ReentParser::EnumNameContext* ReentParser::TheTypeNameContext::enumName() {
  return getRuleContext<ReentParser::EnumNameContext>(0);
}

ReentParser::TypedefNameContext* ReentParser::TheTypeNameContext::typedefName() {
  return getRuleContext<ReentParser::TypedefNameContext>(0);
}


size_t ReentParser::TheTypeNameContext::getRuleIndex() const {
  return ReentParser::RuleTheTypeName;
}

void ReentParser::TheTypeNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTheTypeName(this);
}

void ReentParser::TheTypeNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTheTypeName(this);
}

ReentParser::TheTypeNameContext* ReentParser::theTypeName() {
  TheTypeNameContext *_localctx = _tracker.createInstance<TheTypeNameContext>(_ctx, getState());
  enterRule(_localctx, 282, ReentParser::RuleTheTypeName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1794);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 153, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1791);
      className();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1792);
      enumName();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1793);
      typedefName();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DecltypeSpecifierContext ------------------------------------------------------------------

ReentParser::DecltypeSpecifierContext::DecltypeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::DecltypeSpecifierContext::Decltype() {
  return getToken(ReentParser::Decltype, 0);
}

tree::TerminalNode* ReentParser::DecltypeSpecifierContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::DecltypeSpecifierContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::ExpressionContext* ReentParser::DecltypeSpecifierContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::DecltypeSpecifierContext::Auto() {
  return getToken(ReentParser::Auto, 0);
}


size_t ReentParser::DecltypeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleDecltypeSpecifier;
}

void ReentParser::DecltypeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDecltypeSpecifier(this);
}

void ReentParser::DecltypeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDecltypeSpecifier(this);
}

ReentParser::DecltypeSpecifierContext* ReentParser::decltypeSpecifier() {
  DecltypeSpecifierContext *_localctx = _tracker.createInstance<DecltypeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 284, ReentParser::RuleDecltypeSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1796);
    match(ReentParser::Decltype);
    setState(1797);
    match(ReentParser::LeftParen);
    setState(1800);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
    case 1: {
      setState(1798);
      expression();
      break;
    }

    case 2: {
      setState(1799);
      match(ReentParser::Auto);
      break;
    }

    default:
      break;
    }
    setState(1802);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElaboratedTypeSpecifierContext ------------------------------------------------------------------

ReentParser::ElaboratedTypeSpecifierContext::ElaboratedTypeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassKeyContext* ReentParser::ElaboratedTypeSpecifierContext::classKey() {
  return getRuleContext<ReentParser::ClassKeyContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::ElaboratedTypeSpecifierContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::SimpleTemplateIdContext* ReentParser::ElaboratedTypeSpecifierContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::ElaboratedTypeSpecifierContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ElaboratedTypeSpecifierContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

tree::TerminalNode* ReentParser::ElaboratedTypeSpecifierContext::Template() {
  return getToken(ReentParser::Template, 0);
}

tree::TerminalNode* ReentParser::ElaboratedTypeSpecifierContext::Enum() {
  return getToken(ReentParser::Enum, 0);
}


size_t ReentParser::ElaboratedTypeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleElaboratedTypeSpecifier;
}

void ReentParser::ElaboratedTypeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElaboratedTypeSpecifier(this);
}

void ReentParser::ElaboratedTypeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElaboratedTypeSpecifier(this);
}

ReentParser::ElaboratedTypeSpecifierContext* ReentParser::elaboratedTypeSpecifier() {
  ElaboratedTypeSpecifierContext *_localctx = _tracker.createInstance<ElaboratedTypeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 286, ReentParser::RuleElaboratedTypeSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1826);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Class:
      case ReentParser::Struct: {
        enterOuterAlt(_localctx, 1);
        setState(1804);
        classKey();
        setState(1819);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
        case 1: {
          setState(1806);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
            setState(1805);
            attributeSpecifierSeq();
          }
          setState(1809);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
          case 1: {
            setState(1808);
            nestedNameSpecifier(0);
            break;
          }

          default:
            break;
          }
          setState(1811);
          anyIdentifier();
          break;
        }

        case 2: {
          setState(1812);
          simpleTemplateId();
          break;
        }

        case 3: {
          setState(1813);
          nestedNameSpecifier(0);
          setState(1815);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ReentParser::Template) {
            setState(1814);
            match(ReentParser::Template);
          }
          setState(1817);
          simpleTemplateId();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::Enum: {
        enterOuterAlt(_localctx, 2);
        setState(1821);
        match(ReentParser::Enum);
        setState(1823);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
        case 1: {
          setState(1822);
          nestedNameSpecifier(0);
          break;
        }

        default:
          break;
        }
        setState(1825);
        anyIdentifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumNameContext ------------------------------------------------------------------

ReentParser::EnumNameContext::EnumNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::EnumNameContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::EnumNameContext::getRuleIndex() const {
  return ReentParser::RuleEnumName;
}

void ReentParser::EnumNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumName(this);
}

void ReentParser::EnumNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumName(this);
}

ReentParser::EnumNameContext* ReentParser::enumName() {
  EnumNameContext *_localctx = _tracker.createInstance<EnumNameContext>(_ctx, getState());
  enterRule(_localctx, 288, ReentParser::RuleEnumName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1828);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumSpecifierContext ------------------------------------------------------------------

ReentParser::EnumSpecifierContext::EnumSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::EnumHeadContext* ReentParser::EnumSpecifierContext::enumHead() {
  return getRuleContext<ReentParser::EnumHeadContext>(0);
}

tree::TerminalNode* ReentParser::EnumSpecifierContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::EnumSpecifierContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

ReentParser::EnumeratorListContext* ReentParser::EnumSpecifierContext::enumeratorList() {
  return getRuleContext<ReentParser::EnumeratorListContext>(0);
}

tree::TerminalNode* ReentParser::EnumSpecifierContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}


size_t ReentParser::EnumSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleEnumSpecifier;
}

void ReentParser::EnumSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumSpecifier(this);
}

void ReentParser::EnumSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumSpecifier(this);
}

ReentParser::EnumSpecifierContext* ReentParser::enumSpecifier() {
  EnumSpecifierContext *_localctx = _tracker.createInstance<EnumSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 290, ReentParser::RuleEnumSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1830);
    enumHead();
    setState(1831);
    match(ReentParser::LeftBrace);
    setState(1836);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::Begin)
      | (1ULL << ReentParser::Clustered)
      | (1ULL << ReentParser::Common)
      | (1ULL << ReentParser::Depends)
      | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
      | (1ULL << (ReentParser::Gpu - 64))
      | (1ULL << (ReentParser::Id - 64))
      | (1ULL << (ReentParser::In - 64))
      | (1ULL << (ReentParser::Local - 64))
      | (1ULL << (ReentParser::MarkPreCondition - 64))
      | (1ULL << (ReentParser::MarkState - 64))
      | (1ULL << (ReentParser::Out - 64))
      | (1ULL << (ReentParser::Plan - 64))
      | (1ULL << (ReentParser::Reset - 64))
      | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

    || _la == ReentParser::Identifier) {
      setState(1832);
      enumeratorList();
      setState(1834);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Comma) {
        setState(1833);
        match(ReentParser::Comma);
      }
    }
    setState(1838);
    match(ReentParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumHeadContext ------------------------------------------------------------------

ReentParser::EnumHeadContext::EnumHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::EnumkeyContext* ReentParser::EnumHeadContext::enumkey() {
  return getRuleContext<ReentParser::EnumkeyContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::EnumHeadContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::EnumHeadContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::EnumbaseContext* ReentParser::EnumHeadContext::enumbase() {
  return getRuleContext<ReentParser::EnumbaseContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::EnumHeadContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}


size_t ReentParser::EnumHeadContext::getRuleIndex() const {
  return ReentParser::RuleEnumHead;
}

void ReentParser::EnumHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumHead(this);
}

void ReentParser::EnumHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumHead(this);
}

ReentParser::EnumHeadContext* ReentParser::enumHead() {
  EnumHeadContext *_localctx = _tracker.createInstance<EnumHeadContext>(_ctx, getState());
  enterRule(_localctx, 292, ReentParser::RuleEnumHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1840);
    enumkey();
    setState(1842);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(1841);
      attributeSpecifierSeq();
    }
    setState(1848);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::Begin)
      | (1ULL << ReentParser::Clustered)
      | (1ULL << ReentParser::Common)
      | (1ULL << ReentParser::Decltype)
      | (1ULL << ReentParser::Depends)
      | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
      | (1ULL << (ReentParser::Gpu - 64))
      | (1ULL << (ReentParser::Id - 64))
      | (1ULL << (ReentParser::In - 64))
      | (1ULL << (ReentParser::Local - 64))
      | (1ULL << (ReentParser::MarkPreCondition - 64))
      | (1ULL << (ReentParser::MarkState - 64))
      | (1ULL << (ReentParser::Out - 64))
      | (1ULL << (ReentParser::Plan - 64))
      | (1ULL << (ReentParser::Reset - 64))
      | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
      | (1ULL << (ReentParser::Doublecolon - 146))
      | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
      setState(1845);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
      case 1: {
        setState(1844);
        nestedNameSpecifier(0);
        break;
      }

      default:
        break;
      }
      setState(1847);
      anyIdentifier();
    }
    setState(1851);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Colon) {
      setState(1850);
      enumbase();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OpaqueEnumDeclarationContext ------------------------------------------------------------------

ReentParser::OpaqueEnumDeclarationContext::OpaqueEnumDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::EnumkeyContext* ReentParser::OpaqueEnumDeclarationContext::enumkey() {
  return getRuleContext<ReentParser::EnumkeyContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::OpaqueEnumDeclarationContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::OpaqueEnumDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::OpaqueEnumDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::EnumbaseContext* ReentParser::OpaqueEnumDeclarationContext::enumbase() {
  return getRuleContext<ReentParser::EnumbaseContext>(0);
}


size_t ReentParser::OpaqueEnumDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleOpaqueEnumDeclaration;
}

void ReentParser::OpaqueEnumDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOpaqueEnumDeclaration(this);
}

void ReentParser::OpaqueEnumDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOpaqueEnumDeclaration(this);
}

ReentParser::OpaqueEnumDeclarationContext* ReentParser::opaqueEnumDeclaration() {
  OpaqueEnumDeclarationContext *_localctx = _tracker.createInstance<OpaqueEnumDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 294, ReentParser::RuleOpaqueEnumDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1853);
    enumkey();
    setState(1855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(1854);
      attributeSpecifierSeq();
    }
    setState(1857);
    anyIdentifier();
    setState(1859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Colon) {
      setState(1858);
      enumbase();
    }
    setState(1861);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumkeyContext ------------------------------------------------------------------

ReentParser::EnumkeyContext::EnumkeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::EnumkeyContext::Enum() {
  return getToken(ReentParser::Enum, 0);
}

tree::TerminalNode* ReentParser::EnumkeyContext::Class() {
  return getToken(ReentParser::Class, 0);
}

tree::TerminalNode* ReentParser::EnumkeyContext::Struct() {
  return getToken(ReentParser::Struct, 0);
}


size_t ReentParser::EnumkeyContext::getRuleIndex() const {
  return ReentParser::RuleEnumkey;
}

void ReentParser::EnumkeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumkey(this);
}

void ReentParser::EnumkeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumkey(this);
}

ReentParser::EnumkeyContext* ReentParser::enumkey() {
  EnumkeyContext *_localctx = _tracker.createInstance<EnumkeyContext>(_ctx, getState());
  enterRule(_localctx, 296, ReentParser::RuleEnumkey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1863);
    match(ReentParser::Enum);
    setState(1865);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Class || _la == ReentParser::Struct) {
      setState(1864);
      _la = _input->LA(1);
      if (!(_la == ReentParser::Class || _la == ReentParser::Struct)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumbaseContext ------------------------------------------------------------------

ReentParser::EnumbaseContext::EnumbaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::EnumbaseContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::TypeSpecifierSeqContext* ReentParser::EnumbaseContext::typeSpecifierSeq() {
  return getRuleContext<ReentParser::TypeSpecifierSeqContext>(0);
}


size_t ReentParser::EnumbaseContext::getRuleIndex() const {
  return ReentParser::RuleEnumbase;
}

void ReentParser::EnumbaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumbase(this);
}

void ReentParser::EnumbaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumbase(this);
}

ReentParser::EnumbaseContext* ReentParser::enumbase() {
  EnumbaseContext *_localctx = _tracker.createInstance<EnumbaseContext>(_ctx, getState());
  enterRule(_localctx, 298, ReentParser::RuleEnumbase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1867);
    match(ReentParser::Colon);
    setState(1868);
    typeSpecifierSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorListContext ------------------------------------------------------------------

ReentParser::EnumeratorListContext::EnumeratorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::EnumeratorDefinitionContext *> ReentParser::EnumeratorListContext::enumeratorDefinition() {
  return getRuleContexts<ReentParser::EnumeratorDefinitionContext>();
}

ReentParser::EnumeratorDefinitionContext* ReentParser::EnumeratorListContext::enumeratorDefinition(size_t i) {
  return getRuleContext<ReentParser::EnumeratorDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::EnumeratorListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::EnumeratorListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::EnumeratorListContext::getRuleIndex() const {
  return ReentParser::RuleEnumeratorList;
}

void ReentParser::EnumeratorListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratorList(this);
}

void ReentParser::EnumeratorListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratorList(this);
}

ReentParser::EnumeratorListContext* ReentParser::enumeratorList() {
  EnumeratorListContext *_localctx = _tracker.createInstance<EnumeratorListContext>(_ctx, getState());
  enterRule(_localctx, 300, ReentParser::RuleEnumeratorList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1870);
    enumeratorDefinition();
    setState(1875);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1871);
        match(ReentParser::Comma);
        setState(1872);
        enumeratorDefinition(); 
      }
      setState(1877);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorDefinitionContext ------------------------------------------------------------------

ReentParser::EnumeratorDefinitionContext::EnumeratorDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::EnumeratorContext* ReentParser::EnumeratorDefinitionContext::enumerator() {
  return getRuleContext<ReentParser::EnumeratorContext>(0);
}

tree::TerminalNode* ReentParser::EnumeratorDefinitionContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::EnumeratorDefinitionContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}


size_t ReentParser::EnumeratorDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleEnumeratorDefinition;
}

void ReentParser::EnumeratorDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratorDefinition(this);
}

void ReentParser::EnumeratorDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratorDefinition(this);
}

ReentParser::EnumeratorDefinitionContext* ReentParser::enumeratorDefinition() {
  EnumeratorDefinitionContext *_localctx = _tracker.createInstance<EnumeratorDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 302, ReentParser::RuleEnumeratorDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1878);
    enumerator();
    setState(1881);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Assign) {
      setState(1879);
      match(ReentParser::Assign);
      setState(1880);
      constantExpression();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratorContext ------------------------------------------------------------------

ReentParser::EnumeratorContext::EnumeratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::EnumeratorContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::EnumeratorContext::getRuleIndex() const {
  return ReentParser::RuleEnumerator;
}

void ReentParser::EnumeratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumerator(this);
}

void ReentParser::EnumeratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumerator(this);
}

ReentParser::EnumeratorContext* ReentParser::enumerator() {
  EnumeratorContext *_localctx = _tracker.createInstance<EnumeratorContext>(_ctx, getState());
  enterRule(_localctx, 304, ReentParser::RuleEnumerator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1883);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceNameContext ------------------------------------------------------------------

ReentParser::NamespaceNameContext::NamespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::OriginalNamespaceNameContext* ReentParser::NamespaceNameContext::originalNamespaceName() {
  return getRuleContext<ReentParser::OriginalNamespaceNameContext>(0);
}

ReentParser::NamespaceAliasContext* ReentParser::NamespaceNameContext::namespaceAlias() {
  return getRuleContext<ReentParser::NamespaceAliasContext>(0);
}


size_t ReentParser::NamespaceNameContext::getRuleIndex() const {
  return ReentParser::RuleNamespaceName;
}

void ReentParser::NamespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceName(this);
}

void ReentParser::NamespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceName(this);
}

ReentParser::NamespaceNameContext* ReentParser::namespaceName() {
  NamespaceNameContext *_localctx = _tracker.createInstance<NamespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 306, ReentParser::RuleNamespaceName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1887);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1885);
      originalNamespaceName();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1886);
      namespaceAlias();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OriginalNamespaceNameContext ------------------------------------------------------------------

ReentParser::OriginalNamespaceNameContext::OriginalNamespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::OriginalNamespaceNameContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::OriginalNamespaceNameContext::getRuleIndex() const {
  return ReentParser::RuleOriginalNamespaceName;
}

void ReentParser::OriginalNamespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOriginalNamespaceName(this);
}

void ReentParser::OriginalNamespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOriginalNamespaceName(this);
}

ReentParser::OriginalNamespaceNameContext* ReentParser::originalNamespaceName() {
  OriginalNamespaceNameContext *_localctx = _tracker.createInstance<OriginalNamespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 308, ReentParser::RuleOriginalNamespaceName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1889);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceDefinitionContext ------------------------------------------------------------------

ReentParser::NamespaceDefinitionContext::NamespaceDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NamespaceDefinitionContext::Namespace() {
  return getToken(ReentParser::Namespace, 0);
}

tree::TerminalNode* ReentParser::NamespaceDefinitionContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::NamespaceDefinitionContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

tree::TerminalNode* ReentParser::NamespaceDefinitionContext::Inline() {
  return getToken(ReentParser::Inline, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::NamespaceDefinitionContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::OriginalNamespaceNameContext* ReentParser::NamespaceDefinitionContext::originalNamespaceName() {
  return getRuleContext<ReentParser::OriginalNamespaceNameContext>(0);
}

ReentParser::DeclarationseqContext* ReentParser::NamespaceDefinitionContext::declarationseq() {
  return getRuleContext<ReentParser::DeclarationseqContext>(0);
}


size_t ReentParser::NamespaceDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleNamespaceDefinition;
}

void ReentParser::NamespaceDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceDefinition(this);
}

void ReentParser::NamespaceDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceDefinition(this);
}

ReentParser::NamespaceDefinitionContext* ReentParser::namespaceDefinition() {
  NamespaceDefinitionContext *_localctx = _tracker.createInstance<NamespaceDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 310, ReentParser::RuleNamespaceDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1892);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Inline) {
      setState(1891);
      match(ReentParser::Inline);
    }
    setState(1894);
    match(ReentParser::Namespace);
    setState(1897);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
    case 1: {
      setState(1895);
      anyIdentifier();
      break;
    }

    case 2: {
      setState(1896);
      originalNamespaceName();
      break;
    }

    default:
      break;
    }
    setState(1899);
    match(ReentParser::LeftBrace);
    setState(1901);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 8) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 8)) & ((1ULL << (ReentParser::PlanPragma - 8))
      | (1ULL << (ReentParser::Alignas - 8))
      | (1ULL << (ReentParser::Asm - 8))
      | (1ULL << (ReentParser::Auto - 8))
      | (1ULL << (ReentParser::Begin - 8))
      | (1ULL << (ReentParser::Bool - 8))
      | (1ULL << (ReentParser::Cfunnel - 8))
      | (1ULL << (ReentParser::Chain - 8))
      | (1ULL << (ReentParser::Char - 8))
      | (1ULL << (ReentParser::Char16 - 8))
      | (1ULL << (ReentParser::Char32 - 8))
      | (1ULL << (ReentParser::Class - 8))
      | (1ULL << (ReentParser::Clustered - 8))
      | (1ULL << (ReentParser::Common - 8))
      | (1ULL << (ReentParser::Const - 8))
      | (1ULL << (ReentParser::Constexpr - 8))
      | (1ULL << (ReentParser::Csem - 8))
      | (1ULL << (ReentParser::Cvar - 8))
      | (1ULL << (ReentParser::Decltype - 8))
      | (1ULL << (ReentParser::Depends - 8))
      | (1ULL << (ReentParser::Double - 8))
      | (1ULL << (ReentParser::End - 8))
      | (1ULL << (ReentParser::Enum - 8))
      | (1ULL << (ReentParser::Explicit - 8))
      | (1ULL << (ReentParser::Extern - 8))
      | (1ULL << (ReentParser::Float - 8))
      | (1ULL << (ReentParser::Friend - 8))
      | (1ULL << (ReentParser::Funnel - 8))
      | (1ULL << (ReentParser::Global - 8))
      | (1ULL << (ReentParser::Gpu - 8))
      | (1ULL << (ReentParser::Id - 8))
      | (1ULL << (ReentParser::In - 8)))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & ((1ULL << (ReentParser::Inline - 72))
      | (1ULL << (ReentParser::Int - 72))
      | (1ULL << (ReentParser::Local - 72))
      | (1ULL << (ReentParser::Long - 72))
      | (1ULL << (ReentParser::MarkPreCondition - 72))
      | (1ULL << (ReentParser::MarkState - 72))
      | (1ULL << (ReentParser::Markupdef - 72))
      | (1ULL << (ReentParser::Mutable - 72))
      | (1ULL << (ReentParser::Namespace - 72))
      | (1ULL << (ReentParser::Operator - 72))
      | (1ULL << (ReentParser::Out - 72))
      | (1ULL << (ReentParser::Plan - 72))
      | (1ULL << (ReentParser::Plan_item_type - 72))
      | (1ULL << (ReentParser::Plan_type - 72))
      | (1ULL << (ReentParser::Reenterable - 72))
      | (1ULL << (ReentParser::Register - 72))
      | (1ULL << (ReentParser::Reset - 72))
      | (1ULL << (ReentParser::Set - 72))
      | (1ULL << (ReentParser::Short - 72))
      | (1ULL << (ReentParser::Signed - 72))
      | (1ULL << (ReentParser::Soft_transact_array - 72))
      | (1ULL << (ReentParser::Soft_transact_in - 72))
      | (1ULL << (ReentParser::Soft_transact_out - 72))
      | (1ULL << (ReentParser::Soft_transact_var - 72))
      | (1ULL << (ReentParser::Static - 72))
      | (1ULL << (ReentParser::Static_assert - 72))
      | (1ULL << (ReentParser::Struct - 72))
      | (1ULL << (ReentParser::Template - 72))
      | (1ULL << (ReentParser::Thread_local - 72)))) != 0) || ((((_la - 140) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 140)) & ((1ULL << (ReentParser::Typedef - 140))
      | (1ULL << (ReentParser::Typename_ - 140))
      | (1ULL << (ReentParser::Union - 140))
      | (1ULL << (ReentParser::Unsigned - 140))
      | (1ULL << (ReentParser::Using - 140))
      | (1ULL << (ReentParser::Vectorized - 140))
      | (1ULL << (ReentParser::Virtual - 140))
      | (1ULL << (ReentParser::Void - 140))
      | (1ULL << (ReentParser::Volatile - 140))
      | (1ULL << (ReentParser::Wchar - 140))
      | (1ULL << (ReentParser::LeftParen - 140))
      | (1ULL << (ReentParser::LeftBracket - 140))
      | (1ULL << (ReentParser::Star - 140))
      | (1ULL << (ReentParser::And - 140))
      | (1ULL << (ReentParser::Tilde - 140))
      | (1ULL << (ReentParser::AndAnd - 140))
      | (1ULL << (ReentParser::Doublecolon - 140))
      | (1ULL << (ReentParser::Semi - 140))
      | (1ULL << (ReentParser::Ellipsis - 140))
      | (1ULL << (ReentParser::Identifier - 140)))) != 0)) {
      setState(1900);
      dynamic_cast<NamespaceDefinitionContext *>(_localctx)->namespaceBody = declarationseq();
    }
    setState(1903);
    match(ReentParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceAliasContext ------------------------------------------------------------------

ReentParser::NamespaceAliasContext::NamespaceAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::NamespaceAliasContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::NamespaceAliasContext::getRuleIndex() const {
  return ReentParser::RuleNamespaceAlias;
}

void ReentParser::NamespaceAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceAlias(this);
}

void ReentParser::NamespaceAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceAlias(this);
}

ReentParser::NamespaceAliasContext* ReentParser::namespaceAlias() {
  NamespaceAliasContext *_localctx = _tracker.createInstance<NamespaceAliasContext>(_ctx, getState());
  enterRule(_localctx, 312, ReentParser::RuleNamespaceAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1905);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamespaceAliasDefinitionContext ------------------------------------------------------------------

ReentParser::NamespaceAliasDefinitionContext::NamespaceAliasDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NamespaceAliasDefinitionContext::Namespace() {
  return getToken(ReentParser::Namespace, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::NamespaceAliasDefinitionContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::NamespaceAliasDefinitionContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::QualifiednamespacespecifierContext* ReentParser::NamespaceAliasDefinitionContext::qualifiednamespacespecifier() {
  return getRuleContext<ReentParser::QualifiednamespacespecifierContext>(0);
}

tree::TerminalNode* ReentParser::NamespaceAliasDefinitionContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::NamespaceAliasDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleNamespaceAliasDefinition;
}

void ReentParser::NamespaceAliasDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamespaceAliasDefinition(this);
}

void ReentParser::NamespaceAliasDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamespaceAliasDefinition(this);
}

ReentParser::NamespaceAliasDefinitionContext* ReentParser::namespaceAliasDefinition() {
  NamespaceAliasDefinitionContext *_localctx = _tracker.createInstance<NamespaceAliasDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 314, ReentParser::RuleNamespaceAliasDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1907);
    match(ReentParser::Namespace);
    setState(1908);
    anyIdentifier();
    setState(1909);
    match(ReentParser::Assign);
    setState(1910);
    qualifiednamespacespecifier();
    setState(1911);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiednamespacespecifierContext ------------------------------------------------------------------

ReentParser::QualifiednamespacespecifierContext::QualifiednamespacespecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::NamespaceNameContext* ReentParser::QualifiednamespacespecifierContext::namespaceName() {
  return getRuleContext<ReentParser::NamespaceNameContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::QualifiednamespacespecifierContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}


size_t ReentParser::QualifiednamespacespecifierContext::getRuleIndex() const {
  return ReentParser::RuleQualifiednamespacespecifier;
}

void ReentParser::QualifiednamespacespecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiednamespacespecifier(this);
}

void ReentParser::QualifiednamespacespecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiednamespacespecifier(this);
}

ReentParser::QualifiednamespacespecifierContext* ReentParser::qualifiednamespacespecifier() {
  QualifiednamespacespecifierContext *_localctx = _tracker.createInstance<QualifiednamespacespecifierContext>(_ctx, getState());
  enterRule(_localctx, 316, ReentParser::RuleQualifiednamespacespecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1914);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
    case 1: {
      setState(1913);
      nestedNameSpecifier(0);
      break;
    }

    default:
      break;
    }
    setState(1916);
    namespaceName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsingDeclarationContext ------------------------------------------------------------------

ReentParser::UsingDeclarationContext::UsingDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::UsingDeclarationContext::Using() {
  return getToken(ReentParser::Using, 0);
}

ReentParser::UnqualifiedIdContext* ReentParser::UsingDeclarationContext::unqualifiedId() {
  return getRuleContext<ReentParser::UnqualifiedIdContext>(0);
}

tree::TerminalNode* ReentParser::UsingDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::UsingDeclarationContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::UsingDeclarationContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::UsingDeclarationContext::Typename_() {
  return getToken(ReentParser::Typename_, 0);
}


size_t ReentParser::UsingDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleUsingDeclaration;
}

void ReentParser::UsingDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsingDeclaration(this);
}

void ReentParser::UsingDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsingDeclaration(this);
}

ReentParser::UsingDeclarationContext* ReentParser::usingDeclaration() {
  UsingDeclarationContext *_localctx = _tracker.createInstance<UsingDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 318, ReentParser::RuleUsingDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1918);
    match(ReentParser::Using);
    setState(1924);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
    case 1: {
      setState(1920);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Typename_) {
        setState(1919);
        match(ReentParser::Typename_);
      }
      setState(1922);
      nestedNameSpecifier(0);
      break;
    }

    case 2: {
      setState(1923);
      match(ReentParser::Doublecolon);
      break;
    }

    default:
      break;
    }
    setState(1926);
    unqualifiedId();
    setState(1927);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsingDirectiveContext ------------------------------------------------------------------

ReentParser::UsingDirectiveContext::UsingDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::UsingDirectiveContext::Using() {
  return getToken(ReentParser::Using, 0);
}

tree::TerminalNode* ReentParser::UsingDirectiveContext::Namespace() {
  return getToken(ReentParser::Namespace, 0);
}

ReentParser::NamespaceNameContext* ReentParser::UsingDirectiveContext::namespaceName() {
  return getRuleContext<ReentParser::NamespaceNameContext>(0);
}

tree::TerminalNode* ReentParser::UsingDirectiveContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::UsingDirectiveContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::UsingDirectiveContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}


size_t ReentParser::UsingDirectiveContext::getRuleIndex() const {
  return ReentParser::RuleUsingDirective;
}

void ReentParser::UsingDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsingDirective(this);
}

void ReentParser::UsingDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsingDirective(this);
}

ReentParser::UsingDirectiveContext* ReentParser::usingDirective() {
  UsingDirectiveContext *_localctx = _tracker.createInstance<UsingDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 320, ReentParser::RuleUsingDirective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1930);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(1929);
      attributeSpecifierSeq();
    }
    setState(1932);
    match(ReentParser::Using);
    setState(1933);
    match(ReentParser::Namespace);
    setState(1935);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
    case 1: {
      setState(1934);
      nestedNameSpecifier(0);
      break;
    }

    default:
      break;
    }
    setState(1937);
    namespaceName();
    setState(1938);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsmDefinitionContext ------------------------------------------------------------------

ReentParser::AsmDefinitionContext::AsmDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AsmDefinitionContext::Asm() {
  return getToken(ReentParser::Asm, 0);
}

tree::TerminalNode* ReentParser::AsmDefinitionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::AsmDefinitionContext::StringLiteral() {
  return getToken(ReentParser::StringLiteral, 0);
}

tree::TerminalNode* ReentParser::AsmDefinitionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::AsmDefinitionContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::AsmDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleAsmDefinition;
}

void ReentParser::AsmDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsmDefinition(this);
}

void ReentParser::AsmDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsmDefinition(this);
}

ReentParser::AsmDefinitionContext* ReentParser::asmDefinition() {
  AsmDefinitionContext *_localctx = _tracker.createInstance<AsmDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 322, ReentParser::RuleAsmDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1940);
    match(ReentParser::Asm);
    setState(1941);
    match(ReentParser::LeftParen);
    setState(1942);
    match(ReentParser::StringLiteral);
    setState(1943);
    match(ReentParser::RightParen);
    setState(1944);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LinkageSpecificationContext ------------------------------------------------------------------

ReentParser::LinkageSpecificationContext::LinkageSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::LinkageSpecificationContext::Extern() {
  return getToken(ReentParser::Extern, 0);
}

tree::TerminalNode* ReentParser::LinkageSpecificationContext::StringLiteral() {
  return getToken(ReentParser::StringLiteral, 0);
}

tree::TerminalNode* ReentParser::LinkageSpecificationContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::LinkageSpecificationContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

ReentParser::DeclarationContext* ReentParser::LinkageSpecificationContext::declaration() {
  return getRuleContext<ReentParser::DeclarationContext>(0);
}

ReentParser::DeclarationseqContext* ReentParser::LinkageSpecificationContext::declarationseq() {
  return getRuleContext<ReentParser::DeclarationseqContext>(0);
}


size_t ReentParser::LinkageSpecificationContext::getRuleIndex() const {
  return ReentParser::RuleLinkageSpecification;
}

void ReentParser::LinkageSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLinkageSpecification(this);
}

void ReentParser::LinkageSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLinkageSpecification(this);
}

ReentParser::LinkageSpecificationContext* ReentParser::linkageSpecification() {
  LinkageSpecificationContext *_localctx = _tracker.createInstance<LinkageSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 324, ReentParser::RuleLinkageSpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1946);
    match(ReentParser::Extern);
    setState(1947);
    match(ReentParser::StringLiteral);
    setState(1954);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftBrace: {
        setState(1948);
        match(ReentParser::LeftBrace);
        setState(1950);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 8) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 8)) & ((1ULL << (ReentParser::PlanPragma - 8))
          | (1ULL << (ReentParser::Alignas - 8))
          | (1ULL << (ReentParser::Asm - 8))
          | (1ULL << (ReentParser::Auto - 8))
          | (1ULL << (ReentParser::Begin - 8))
          | (1ULL << (ReentParser::Bool - 8))
          | (1ULL << (ReentParser::Cfunnel - 8))
          | (1ULL << (ReentParser::Chain - 8))
          | (1ULL << (ReentParser::Char - 8))
          | (1ULL << (ReentParser::Char16 - 8))
          | (1ULL << (ReentParser::Char32 - 8))
          | (1ULL << (ReentParser::Class - 8))
          | (1ULL << (ReentParser::Clustered - 8))
          | (1ULL << (ReentParser::Common - 8))
          | (1ULL << (ReentParser::Const - 8))
          | (1ULL << (ReentParser::Constexpr - 8))
          | (1ULL << (ReentParser::Csem - 8))
          | (1ULL << (ReentParser::Cvar - 8))
          | (1ULL << (ReentParser::Decltype - 8))
          | (1ULL << (ReentParser::Depends - 8))
          | (1ULL << (ReentParser::Double - 8))
          | (1ULL << (ReentParser::End - 8))
          | (1ULL << (ReentParser::Enum - 8))
          | (1ULL << (ReentParser::Explicit - 8))
          | (1ULL << (ReentParser::Extern - 8))
          | (1ULL << (ReentParser::Float - 8))
          | (1ULL << (ReentParser::Friend - 8))
          | (1ULL << (ReentParser::Funnel - 8))
          | (1ULL << (ReentParser::Global - 8))
          | (1ULL << (ReentParser::Gpu - 8))
          | (1ULL << (ReentParser::Id - 8))
          | (1ULL << (ReentParser::In - 8)))) != 0) || ((((_la - 72) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 72)) & ((1ULL << (ReentParser::Inline - 72))
          | (1ULL << (ReentParser::Int - 72))
          | (1ULL << (ReentParser::Local - 72))
          | (1ULL << (ReentParser::Long - 72))
          | (1ULL << (ReentParser::MarkPreCondition - 72))
          | (1ULL << (ReentParser::MarkState - 72))
          | (1ULL << (ReentParser::Markupdef - 72))
          | (1ULL << (ReentParser::Mutable - 72))
          | (1ULL << (ReentParser::Namespace - 72))
          | (1ULL << (ReentParser::Operator - 72))
          | (1ULL << (ReentParser::Out - 72))
          | (1ULL << (ReentParser::Plan - 72))
          | (1ULL << (ReentParser::Plan_item_type - 72))
          | (1ULL << (ReentParser::Plan_type - 72))
          | (1ULL << (ReentParser::Reenterable - 72))
          | (1ULL << (ReentParser::Register - 72))
          | (1ULL << (ReentParser::Reset - 72))
          | (1ULL << (ReentParser::Set - 72))
          | (1ULL << (ReentParser::Short - 72))
          | (1ULL << (ReentParser::Signed - 72))
          | (1ULL << (ReentParser::Soft_transact_array - 72))
          | (1ULL << (ReentParser::Soft_transact_in - 72))
          | (1ULL << (ReentParser::Soft_transact_out - 72))
          | (1ULL << (ReentParser::Soft_transact_var - 72))
          | (1ULL << (ReentParser::Static - 72))
          | (1ULL << (ReentParser::Static_assert - 72))
          | (1ULL << (ReentParser::Struct - 72))
          | (1ULL << (ReentParser::Template - 72))
          | (1ULL << (ReentParser::Thread_local - 72)))) != 0) || ((((_la - 140) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 140)) & ((1ULL << (ReentParser::Typedef - 140))
          | (1ULL << (ReentParser::Typename_ - 140))
          | (1ULL << (ReentParser::Union - 140))
          | (1ULL << (ReentParser::Unsigned - 140))
          | (1ULL << (ReentParser::Using - 140))
          | (1ULL << (ReentParser::Vectorized - 140))
          | (1ULL << (ReentParser::Virtual - 140))
          | (1ULL << (ReentParser::Void - 140))
          | (1ULL << (ReentParser::Volatile - 140))
          | (1ULL << (ReentParser::Wchar - 140))
          | (1ULL << (ReentParser::LeftParen - 140))
          | (1ULL << (ReentParser::LeftBracket - 140))
          | (1ULL << (ReentParser::Star - 140))
          | (1ULL << (ReentParser::And - 140))
          | (1ULL << (ReentParser::Tilde - 140))
          | (1ULL << (ReentParser::AndAnd - 140))
          | (1ULL << (ReentParser::Doublecolon - 140))
          | (1ULL << (ReentParser::Semi - 140))
          | (1ULL << (ReentParser::Ellipsis - 140))
          | (1ULL << (ReentParser::Identifier - 140)))) != 0)) {
          setState(1949);
          declarationseq();
        }
        setState(1952);
        match(ReentParser::RightBrace);
        break;
      }

      case ReentParser::PlanPragma:
      case ReentParser::Alignas:
      case ReentParser::Asm:
      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Cfunnel:
      case ReentParser::Chain:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Class:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Const:
      case ReentParser::Constexpr:
      case ReentParser::Csem:
      case ReentParser::Cvar:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::Double:
      case ReentParser::End:
      case ReentParser::Enum:
      case ReentParser::Explicit:
      case ReentParser::Extern:
      case ReentParser::Float:
      case ReentParser::Friend:
      case ReentParser::Funnel:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Inline:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Markupdef:
      case ReentParser::Mutable:
      case ReentParser::Namespace:
      case ReentParser::Operator:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Plan_item_type:
      case ReentParser::Plan_type:
      case ReentParser::Reenterable:
      case ReentParser::Register:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Soft_transact_array:
      case ReentParser::Soft_transact_in:
      case ReentParser::Soft_transact_out:
      case ReentParser::Soft_transact_var:
      case ReentParser::Static:
      case ReentParser::Static_assert:
      case ReentParser::Struct:
      case ReentParser::Template:
      case ReentParser::Thread_local:
      case ReentParser::Typedef:
      case ReentParser::Typename_:
      case ReentParser::Union:
      case ReentParser::Unsigned:
      case ReentParser::Using:
      case ReentParser::Vectorized:
      case ReentParser::Virtual:
      case ReentParser::Void:
      case ReentParser::Volatile:
      case ReentParser::Wchar:
      case ReentParser::LeftParen:
      case ReentParser::LeftBracket:
      case ReentParser::Star:
      case ReentParser::And:
      case ReentParser::Tilde:
      case ReentParser::AndAnd:
      case ReentParser::Doublecolon:
      case ReentParser::Semi:
      case ReentParser::Ellipsis:
      case ReentParser::Identifier: {
        setState(1953);
        declaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierSeqContext ------------------------------------------------------------------

ReentParser::AttributeSpecifierSeqContext::AttributeSpecifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AttributeSpecifierContext *> ReentParser::AttributeSpecifierSeqContext::attributeSpecifier() {
  return getRuleContexts<ReentParser::AttributeSpecifierContext>();
}

ReentParser::AttributeSpecifierContext* ReentParser::AttributeSpecifierSeqContext::attributeSpecifier(size_t i) {
  return getRuleContext<ReentParser::AttributeSpecifierContext>(i);
}


size_t ReentParser::AttributeSpecifierSeqContext::getRuleIndex() const {
  return ReentParser::RuleAttributeSpecifierSeq;
}

void ReentParser::AttributeSpecifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifierSeq(this);
}

void ReentParser::AttributeSpecifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifierSeq(this);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::attributeSpecifierSeq() {
  AttributeSpecifierSeqContext *_localctx = _tracker.createInstance<AttributeSpecifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 326, ReentParser::RuleAttributeSpecifierSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1957); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1956);
              attributeSpecifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1959); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 183, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeSpecifierContext ------------------------------------------------------------------

ReentParser::AttributeSpecifierContext::AttributeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ReentParser::AttributeSpecifierContext::LeftBracket() {
  return getTokens(ReentParser::LeftBracket);
}

tree::TerminalNode* ReentParser::AttributeSpecifierContext::LeftBracket(size_t i) {
  return getToken(ReentParser::LeftBracket, i);
}

std::vector<tree::TerminalNode *> ReentParser::AttributeSpecifierContext::RightBracket() {
  return getTokens(ReentParser::RightBracket);
}

tree::TerminalNode* ReentParser::AttributeSpecifierContext::RightBracket(size_t i) {
  return getToken(ReentParser::RightBracket, i);
}

ReentParser::AttributeListContext* ReentParser::AttributeSpecifierContext::attributeList() {
  return getRuleContext<ReentParser::AttributeListContext>(0);
}

ReentParser::AlignmentspecifierContext* ReentParser::AttributeSpecifierContext::alignmentspecifier() {
  return getRuleContext<ReentParser::AlignmentspecifierContext>(0);
}


size_t ReentParser::AttributeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleAttributeSpecifier;
}

void ReentParser::AttributeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeSpecifier(this);
}

void ReentParser::AttributeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeSpecifier(this);
}

ReentParser::AttributeSpecifierContext* ReentParser::attributeSpecifier() {
  AttributeSpecifierContext *_localctx = _tracker.createInstance<AttributeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 328, ReentParser::RuleAttributeSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1969);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftBracket: {
        enterOuterAlt(_localctx, 1);
        setState(1961);
        match(ReentParser::LeftBracket);
        setState(1962);
        match(ReentParser::LeftBracket);
        setState(1964);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ReentParser::Begin)
          | (1ULL << ReentParser::Clustered)
          | (1ULL << ReentParser::Common)
          | (1ULL << ReentParser::Depends)
          | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
          | (1ULL << (ReentParser::Gpu - 64))
          | (1ULL << (ReentParser::Id - 64))
          | (1ULL << (ReentParser::In - 64))
          | (1ULL << (ReentParser::Local - 64))
          | (1ULL << (ReentParser::MarkPreCondition - 64))
          | (1ULL << (ReentParser::MarkState - 64))
          | (1ULL << (ReentParser::Out - 64))
          | (1ULL << (ReentParser::Plan - 64))
          | (1ULL << (ReentParser::Reset - 64))
          | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

        || _la == ReentParser::Identifier) {
          setState(1963);
          attributeList();
        }
        setState(1966);
        match(ReentParser::RightBracket);
        setState(1967);
        match(ReentParser::RightBracket);
        break;
      }

      case ReentParser::Alignas: {
        enterOuterAlt(_localctx, 2);
        setState(1968);
        alignmentspecifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlignmentspecifierContext ------------------------------------------------------------------

ReentParser::AlignmentspecifierContext::AlignmentspecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AlignmentspecifierContext::Alignas() {
  return getToken(ReentParser::Alignas, 0);
}

tree::TerminalNode* ReentParser::AlignmentspecifierContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::AlignmentspecifierContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::TheTypeIdContext* ReentParser::AlignmentspecifierContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

ReentParser::ConstantExpressionContext* ReentParser::AlignmentspecifierContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::AlignmentspecifierContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}


size_t ReentParser::AlignmentspecifierContext::getRuleIndex() const {
  return ReentParser::RuleAlignmentspecifier;
}

void ReentParser::AlignmentspecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlignmentspecifier(this);
}

void ReentParser::AlignmentspecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlignmentspecifier(this);
}

ReentParser::AlignmentspecifierContext* ReentParser::alignmentspecifier() {
  AlignmentspecifierContext *_localctx = _tracker.createInstance<AlignmentspecifierContext>(_ctx, getState());
  enterRule(_localctx, 330, ReentParser::RuleAlignmentspecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1971);
    match(ReentParser::Alignas);
    setState(1972);
    match(ReentParser::LeftParen);
    setState(1975);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
    case 1: {
      setState(1973);
      theTypeId();
      break;
    }

    case 2: {
      setState(1974);
      constantExpression();
      break;
    }

    default:
      break;
    }
    setState(1978);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(1977);
      match(ReentParser::Ellipsis);
    }
    setState(1980);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeListContext ------------------------------------------------------------------

ReentParser::AttributeListContext::AttributeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AttributeContext *> ReentParser::AttributeListContext::attribute() {
  return getRuleContexts<ReentParser::AttributeContext>();
}

ReentParser::AttributeContext* ReentParser::AttributeListContext::attribute(size_t i) {
  return getRuleContext<ReentParser::AttributeContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::AttributeListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::AttributeListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}

tree::TerminalNode* ReentParser::AttributeListContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}


size_t ReentParser::AttributeListContext::getRuleIndex() const {
  return ReentParser::RuleAttributeList;
}

void ReentParser::AttributeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeList(this);
}

void ReentParser::AttributeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeList(this);
}

ReentParser::AttributeListContext* ReentParser::attributeList() {
  AttributeListContext *_localctx = _tracker.createInstance<AttributeListContext>(_ctx, getState());
  enterRule(_localctx, 332, ReentParser::RuleAttributeList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1982);
    attribute();
    setState(1987);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(1983);
      match(ReentParser::Comma);
      setState(1984);
      attribute();
      setState(1989);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1991);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(1990);
      match(ReentParser::Ellipsis);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

ReentParser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::AttributeContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::AttributeNamespaceContext* ReentParser::AttributeContext::attributeNamespace() {
  return getRuleContext<ReentParser::AttributeNamespaceContext>(0);
}

tree::TerminalNode* ReentParser::AttributeContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

ReentParser::AttributeArgumentClauseContext* ReentParser::AttributeContext::attributeArgumentClause() {
  return getRuleContext<ReentParser::AttributeArgumentClauseContext>(0);
}


size_t ReentParser::AttributeContext::getRuleIndex() const {
  return ReentParser::RuleAttribute;
}

void ReentParser::AttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute(this);
}

void ReentParser::AttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute(this);
}

ReentParser::AttributeContext* ReentParser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 334, ReentParser::RuleAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1996);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
    case 1: {
      setState(1993);
      attributeNamespace();
      setState(1994);
      match(ReentParser::Doublecolon);
      break;
    }

    default:
      break;
    }
    setState(1998);
    anyIdentifier();
    setState(2000);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::LeftParen) {
      setState(1999);
      attributeArgumentClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeNamespaceContext ------------------------------------------------------------------

ReentParser::AttributeNamespaceContext::AttributeNamespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::AttributeNamespaceContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::AttributeNamespaceContext::getRuleIndex() const {
  return ReentParser::RuleAttributeNamespace;
}

void ReentParser::AttributeNamespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeNamespace(this);
}

void ReentParser::AttributeNamespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeNamespace(this);
}

ReentParser::AttributeNamespaceContext* ReentParser::attributeNamespace() {
  AttributeNamespaceContext *_localctx = _tracker.createInstance<AttributeNamespaceContext>(_ctx, getState());
  enterRule(_localctx, 336, ReentParser::RuleAttributeNamespace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2002);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeArgumentClauseContext ------------------------------------------------------------------

ReentParser::AttributeArgumentClauseContext::AttributeArgumentClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AttributeArgumentClauseContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::AttributeArgumentClauseContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::BalancedTokenSeqContext* ReentParser::AttributeArgumentClauseContext::balancedTokenSeq() {
  return getRuleContext<ReentParser::BalancedTokenSeqContext>(0);
}


size_t ReentParser::AttributeArgumentClauseContext::getRuleIndex() const {
  return ReentParser::RuleAttributeArgumentClause;
}

void ReentParser::AttributeArgumentClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttributeArgumentClause(this);
}

void ReentParser::AttributeArgumentClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttributeArgumentClause(this);
}

ReentParser::AttributeArgumentClauseContext* ReentParser::attributeArgumentClause() {
  AttributeArgumentClauseContext *_localctx = _tracker.createInstance<AttributeArgumentClauseContext>(_ctx, getState());
  enterRule(_localctx, 338, ReentParser::RuleAttributeArgumentClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2004);
    match(ReentParser::LeftParen);
    setState(2006);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::IntegerLiteral)
      | (1ULL << ReentParser::CharacterLiteral)
      | (1ULL << ReentParser::FloatingLiteral)
      | (1ULL << ReentParser::StringLiteral)
      | (1ULL << ReentParser::BooleanLiteral)
      | (1ULL << ReentParser::PointerLiteral)
      | (1ULL << ReentParser::UserDefinedLiteral)
      | (1ULL << ReentParser::PlanPragma)
      | (1ULL << ReentParser::DoNotCheck)
      | (1ULL << ReentParser::BlockComment)
      | (1ULL << ReentParser::OtherPragma)
      | (1ULL << ReentParser::Line)
      | (1ULL << ReentParser::MultiLineMacro)
      | (1ULL << ReentParser::Directive)
      | (1ULL << ReentParser::Alignas)
      | (1ULL << ReentParser::Alignof)
      | (1ULL << ReentParser::Asm)
      | (1ULL << ReentParser::Auto)
      | (1ULL << ReentParser::Begin)
      | (1ULL << ReentParser::Bool)
      | (1ULL << ReentParser::Break)
      | (1ULL << ReentParser::Case)
      | (1ULL << ReentParser::Catch)
      | (1ULL << ReentParser::Cfunnel)
      | (1ULL << ReentParser::Chain)
      | (1ULL << ReentParser::Char)
      | (1ULL << ReentParser::Char16)
      | (1ULL << ReentParser::Char32)
      | (1ULL << ReentParser::Cilk_for)
      | (1ULL << ReentParser::Cilk_for_)
      | (1ULL << ReentParser::Cilk_spawn)
      | (1ULL << ReentParser::Cilk_spawn_)
      | (1ULL << ReentParser::Cilk_sync)
      | (1ULL << ReentParser::Cilk_sync_)
      | (1ULL << ReentParser::Class)
      | (1ULL << ReentParser::Clear_plan)
      | (1ULL << ReentParser::Clustered)
      | (1ULL << ReentParser::Common)
      | (1ULL << ReentParser::Const)
      | (1ULL << ReentParser::Constexpr)
      | (1ULL << ReentParser::Const_cast)
      | (1ULL << ReentParser::Continue)
      | (1ULL << ReentParser::Csem)
      | (1ULL << ReentParser::Cvar)
      | (1ULL << ReentParser::Decltype)
      | (1ULL << ReentParser::Default)
      | (1ULL << ReentParser::Delete)
      | (1ULL << ReentParser::Depends)
      | (1ULL << ReentParser::Do)
      | (1ULL << ReentParser::Double)
      | (1ULL << ReentParser::Dynamic_cast)
      | (1ULL << ReentParser::Else)
      | (1ULL << ReentParser::End)
      | (1ULL << ReentParser::Enum)
      | (1ULL << ReentParser::Explicit)
      | (1ULL << ReentParser::Export)
      | (1ULL << ReentParser::Extern)
      | (1ULL << ReentParser::False_)
      | (1ULL << ReentParser::Final)
      | (1ULL << ReentParser::Float)
      | (1ULL << ReentParser::For)
      | (1ULL << ReentParser::Friend)
      | (1ULL << ReentParser::Funnel))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
      | (1ULL << (ReentParser::Gpu - 64))
      | (1ULL << (ReentParser::Goto - 64))
      | (1ULL << (ReentParser::GpuGlobal - 64))
      | (1ULL << (ReentParser::GpuLocal - 64))
      | (1ULL << (ReentParser::Id - 64))
      | (1ULL << (ReentParser::If - 64))
      | (1ULL << (ReentParser::In - 64))
      | (1ULL << (ReentParser::Inline - 64))
      | (1ULL << (ReentParser::Int - 64))
      | (1ULL << (ReentParser::Local - 64))
      | (1ULL << (ReentParser::Long - 64))
      | (1ULL << (ReentParser::MarkPreCondition - 64))
      | (1ULL << (ReentParser::MarkState - 64))
      | (1ULL << (ReentParser::Markupdef - 64))
      | (1ULL << (ReentParser::Mutable - 64))
      | (1ULL << (ReentParser::Namespace - 64))
      | (1ULL << (ReentParser::New - 64))
      | (1ULL << (ReentParser::Noexcept - 64))
      | (1ULL << (ReentParser::Nullptr - 64))
      | (1ULL << (ReentParser::Operator - 64))
      | (1ULL << (ReentParser::Out - 64))
      | (1ULL << (ReentParser::Override - 64))
      | (1ULL << (ReentParser::Plan - 64))
      | (1ULL << (ReentParser::Plan_atomize - 64))
      | (1ULL << (ReentParser::Plan_chain - 64))
      | (1ULL << (ReentParser::Plan_critical - 64))
      | (1ULL << (ReentParser::Plan_first - 64))
      | (1ULL << (ReentParser::Plan_get_first - 64))
      | (1ULL << (ReentParser::Plan_get_last - 64))
      | (1ULL << (ReentParser::Plan_group_atomize - 64))
      | (1ULL << (ReentParser::Plan_group_first - 64))
      | (1ULL << (ReentParser::Plan_group_last - 64))
      | (1ULL << (ReentParser::Plan_group_parallelize - 64))
      | (1ULL << (ReentParser::Plan_group_soft_atomize - 64))
      | (1ULL << (ReentParser::Plan_group_vectorize - 64))
      | (1ULL << (ReentParser::Plan_item_type - 64))
      | (1ULL << (ReentParser::Plan_last - 64))
      | (1ULL << (ReentParser::Plan_parallel_chain - 64))
      | (1ULL << (ReentParser::Plan_parallel_reverse - 64))
      | (1ULL << (ReentParser::Plan_register - 64))
      | (1ULL << (ReentParser::Plan_registered_barrier - 64))
      | (1ULL << (ReentParser::Plan_stop - 64))
      | (1ULL << (ReentParser::Plan_topology - 64))
      | (1ULL << (ReentParser::Plan_type - 64))
      | (1ULL << (ReentParser::Private - 64))
      | (1ULL << (ReentParser::Protected - 64))
      | (1ULL << (ReentParser::Public - 64))
      | (1ULL << (ReentParser::Reduction - 64))
      | (1ULL << (ReentParser::Reenterable - 64))
      | (1ULL << (ReentParser::Register - 64))
      | (1ULL << (ReentParser::Reinterpret_cast - 64))
      | (1ULL << (ReentParser::Reset - 64))
      | (1ULL << (ReentParser::Return - 64))
      | (1ULL << (ReentParser::Set - 64))
      | (1ULL << (ReentParser::Short - 64))
      | (1ULL << (ReentParser::Signed - 64))
      | (1ULL << (ReentParser::Sizeof - 64))
      | (1ULL << (ReentParser::Soft_transact_array - 64))
      | (1ULL << (ReentParser::Soft_transact_in - 64))
      | (1ULL << (ReentParser::Soft_transact_out - 64))
      | (1ULL << (ReentParser::Soft_transact_var - 64))
      | (1ULL << (ReentParser::Static - 64))
      | (1ULL << (ReentParser::Static_assert - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (ReentParser::Static_cast - 128))
      | (1ULL << (ReentParser::Struct - 128))
      | (1ULL << (ReentParser::Switch - 128))
      | (1ULL << (ReentParser::Template - 128))
      | (1ULL << (ReentParser::This - 128))
      | (1ULL << (ReentParser::Thread_local - 128))
      | (1ULL << (ReentParser::Throw - 128))
      | (1ULL << (ReentParser::Throw_first - 128))
      | (1ULL << (ReentParser::Throw_last - 128))
      | (1ULL << (ReentParser::Transaction_atomic - 128))
      | (1ULL << (ReentParser::True_ - 128))
      | (1ULL << (ReentParser::Try - 128))
      | (1ULL << (ReentParser::Typedef - 128))
      | (1ULL << (ReentParser::Typeid_ - 128))
      | (1ULL << (ReentParser::Typename_ - 128))
      | (1ULL << (ReentParser::Union - 128))
      | (1ULL << (ReentParser::Unsigned - 128))
      | (1ULL << (ReentParser::Using - 128))
      | (1ULL << (ReentParser::Vectorized - 128))
      | (1ULL << (ReentParser::Virtual - 128))
      | (1ULL << (ReentParser::Void - 128))
      | (1ULL << (ReentParser::Volatile - 128))
      | (1ULL << (ReentParser::Wchar - 128))
      | (1ULL << (ReentParser::While - 128))
      | (1ULL << (ReentParser::At - 128))
      | (1ULL << (ReentParser::Dollar - 128))
      | (1ULL << (ReentParser::Is - 128))
      | (1ULL << (ReentParser::LeftParen - 128))
      | (1ULL << (ReentParser::LeftBracket - 128))
      | (1ULL << (ReentParser::LeftBrace - 128))
      | (1ULL << (ReentParser::Underscore - 128))
      | (1ULL << (ReentParser::Plus - 128))
      | (1ULL << (ReentParser::Minus - 128))
      | (1ULL << (ReentParser::Star - 128))
      | (1ULL << (ReentParser::Div - 128))
      | (1ULL << (ReentParser::Mod - 128))
      | (1ULL << (ReentParser::Caret - 128))
      | (1ULL << (ReentParser::And - 128))
      | (1ULL << (ReentParser::Or - 128))
      | (1ULL << (ReentParser::Tilde - 128))
      | (1ULL << (ReentParser::Not - 128))
      | (1ULL << (ReentParser::Assign - 128))
      | (1ULL << (ReentParser::Less - 128))
      | (1ULL << (ReentParser::Greater - 128))
      | (1ULL << (ReentParser::PlusAssign - 128))
      | (1ULL << (ReentParser::MinusAssign - 128))
      | (1ULL << (ReentParser::StarAssign - 128))
      | (1ULL << (ReentParser::DivAssign - 128))
      | (1ULL << (ReentParser::ModAssign - 128))
      | (1ULL << (ReentParser::XorAssign - 128))
      | (1ULL << (ReentParser::AndAssign - 128))
      | (1ULL << (ReentParser::OrAssign - 128))
      | (1ULL << (ReentParser::LeftShiftAssign - 128))
      | (1ULL << (ReentParser::RightShiftAssign - 128))
      | (1ULL << (ReentParser::Equal - 128))
      | (1ULL << (ReentParser::NotEqual - 128))
      | (1ULL << (ReentParser::LessEqual - 128))
      | (1ULL << (ReentParser::GreaterEqual - 128))
      | (1ULL << (ReentParser::AndAnd - 128))
      | (1ULL << (ReentParser::OrOr - 128))
      | (1ULL << (ReentParser::PlusPlus - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (ReentParser::MinusMinus - 192))
      | (1ULL << (ReentParser::Comma - 192))
      | (1ULL << (ReentParser::ArrowStar - 192))
      | (1ULL << (ReentParser::Arrow - 192))
      | (1ULL << (ReentParser::Question - 192))
      | (1ULL << (ReentParser::Colon - 192))
      | (1ULL << (ReentParser::Doublecolon - 192))
      | (1ULL << (ReentParser::Semi - 192))
      | (1ULL << (ReentParser::Dot - 192))
      | (1ULL << (ReentParser::DotStar - 192))
      | (1ULL << (ReentParser::Ellipsis - 192))
      | (1ULL << (ReentParser::Identifier - 192))
      | (1ULL << (ReentParser::DecimalLiteral - 192))
      | (1ULL << (ReentParser::OctalLiteral - 192))
      | (1ULL << (ReentParser::HexadecimalLiteral - 192))
      | (1ULL << (ReentParser::BinaryLiteral - 192))
      | (1ULL << (ReentParser::Integersuffix - 192))
      | (1ULL << (ReentParser::UserDefinedIntegerLiteral - 192))
      | (1ULL << (ReentParser::UserDefinedFloatingLiteral - 192))
      | (1ULL << (ReentParser::UserDefinedStringLiteral - 192))
      | (1ULL << (ReentParser::UserDefinedCharacterLiteral - 192))
      | (1ULL << (ReentParser::Whitespace - 192))
      | (1ULL << (ReentParser::Newline - 192))
      | (1ULL << (ReentParser::LineComment - 192)))) != 0)) {
      setState(2005);
      balancedTokenSeq();
    }
    setState(2008);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BalancedTokenSeqContext ------------------------------------------------------------------

ReentParser::BalancedTokenSeqContext::BalancedTokenSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::BalancedtokenContext *> ReentParser::BalancedTokenSeqContext::balancedtoken() {
  return getRuleContexts<ReentParser::BalancedtokenContext>();
}

ReentParser::BalancedtokenContext* ReentParser::BalancedTokenSeqContext::balancedtoken(size_t i) {
  return getRuleContext<ReentParser::BalancedtokenContext>(i);
}


size_t ReentParser::BalancedTokenSeqContext::getRuleIndex() const {
  return ReentParser::RuleBalancedTokenSeq;
}

void ReentParser::BalancedTokenSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBalancedTokenSeq(this);
}

void ReentParser::BalancedTokenSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBalancedTokenSeq(this);
}

ReentParser::BalancedTokenSeqContext* ReentParser::balancedTokenSeq() {
  BalancedTokenSeqContext *_localctx = _tracker.createInstance<BalancedTokenSeqContext>(_ctx, getState());
  enterRule(_localctx, 340, ReentParser::RuleBalancedTokenSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2011); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2010);
      balancedtoken();
      setState(2013); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::IntegerLiteral)
      | (1ULL << ReentParser::CharacterLiteral)
      | (1ULL << ReentParser::FloatingLiteral)
      | (1ULL << ReentParser::StringLiteral)
      | (1ULL << ReentParser::BooleanLiteral)
      | (1ULL << ReentParser::PointerLiteral)
      | (1ULL << ReentParser::UserDefinedLiteral)
      | (1ULL << ReentParser::PlanPragma)
      | (1ULL << ReentParser::DoNotCheck)
      | (1ULL << ReentParser::BlockComment)
      | (1ULL << ReentParser::OtherPragma)
      | (1ULL << ReentParser::Line)
      | (1ULL << ReentParser::MultiLineMacro)
      | (1ULL << ReentParser::Directive)
      | (1ULL << ReentParser::Alignas)
      | (1ULL << ReentParser::Alignof)
      | (1ULL << ReentParser::Asm)
      | (1ULL << ReentParser::Auto)
      | (1ULL << ReentParser::Begin)
      | (1ULL << ReentParser::Bool)
      | (1ULL << ReentParser::Break)
      | (1ULL << ReentParser::Case)
      | (1ULL << ReentParser::Catch)
      | (1ULL << ReentParser::Cfunnel)
      | (1ULL << ReentParser::Chain)
      | (1ULL << ReentParser::Char)
      | (1ULL << ReentParser::Char16)
      | (1ULL << ReentParser::Char32)
      | (1ULL << ReentParser::Cilk_for)
      | (1ULL << ReentParser::Cilk_for_)
      | (1ULL << ReentParser::Cilk_spawn)
      | (1ULL << ReentParser::Cilk_spawn_)
      | (1ULL << ReentParser::Cilk_sync)
      | (1ULL << ReentParser::Cilk_sync_)
      | (1ULL << ReentParser::Class)
      | (1ULL << ReentParser::Clear_plan)
      | (1ULL << ReentParser::Clustered)
      | (1ULL << ReentParser::Common)
      | (1ULL << ReentParser::Const)
      | (1ULL << ReentParser::Constexpr)
      | (1ULL << ReentParser::Const_cast)
      | (1ULL << ReentParser::Continue)
      | (1ULL << ReentParser::Csem)
      | (1ULL << ReentParser::Cvar)
      | (1ULL << ReentParser::Decltype)
      | (1ULL << ReentParser::Default)
      | (1ULL << ReentParser::Delete)
      | (1ULL << ReentParser::Depends)
      | (1ULL << ReentParser::Do)
      | (1ULL << ReentParser::Double)
      | (1ULL << ReentParser::Dynamic_cast)
      | (1ULL << ReentParser::Else)
      | (1ULL << ReentParser::End)
      | (1ULL << ReentParser::Enum)
      | (1ULL << ReentParser::Explicit)
      | (1ULL << ReentParser::Export)
      | (1ULL << ReentParser::Extern)
      | (1ULL << ReentParser::False_)
      | (1ULL << ReentParser::Final)
      | (1ULL << ReentParser::Float)
      | (1ULL << ReentParser::For)
      | (1ULL << ReentParser::Friend)
      | (1ULL << ReentParser::Funnel))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
      | (1ULL << (ReentParser::Gpu - 64))
      | (1ULL << (ReentParser::Goto - 64))
      | (1ULL << (ReentParser::GpuGlobal - 64))
      | (1ULL << (ReentParser::GpuLocal - 64))
      | (1ULL << (ReentParser::Id - 64))
      | (1ULL << (ReentParser::If - 64))
      | (1ULL << (ReentParser::In - 64))
      | (1ULL << (ReentParser::Inline - 64))
      | (1ULL << (ReentParser::Int - 64))
      | (1ULL << (ReentParser::Local - 64))
      | (1ULL << (ReentParser::Long - 64))
      | (1ULL << (ReentParser::MarkPreCondition - 64))
      | (1ULL << (ReentParser::MarkState - 64))
      | (1ULL << (ReentParser::Markupdef - 64))
      | (1ULL << (ReentParser::Mutable - 64))
      | (1ULL << (ReentParser::Namespace - 64))
      | (1ULL << (ReentParser::New - 64))
      | (1ULL << (ReentParser::Noexcept - 64))
      | (1ULL << (ReentParser::Nullptr - 64))
      | (1ULL << (ReentParser::Operator - 64))
      | (1ULL << (ReentParser::Out - 64))
      | (1ULL << (ReentParser::Override - 64))
      | (1ULL << (ReentParser::Plan - 64))
      | (1ULL << (ReentParser::Plan_atomize - 64))
      | (1ULL << (ReentParser::Plan_chain - 64))
      | (1ULL << (ReentParser::Plan_critical - 64))
      | (1ULL << (ReentParser::Plan_first - 64))
      | (1ULL << (ReentParser::Plan_get_first - 64))
      | (1ULL << (ReentParser::Plan_get_last - 64))
      | (1ULL << (ReentParser::Plan_group_atomize - 64))
      | (1ULL << (ReentParser::Plan_group_first - 64))
      | (1ULL << (ReentParser::Plan_group_last - 64))
      | (1ULL << (ReentParser::Plan_group_parallelize - 64))
      | (1ULL << (ReentParser::Plan_group_soft_atomize - 64))
      | (1ULL << (ReentParser::Plan_group_vectorize - 64))
      | (1ULL << (ReentParser::Plan_item_type - 64))
      | (1ULL << (ReentParser::Plan_last - 64))
      | (1ULL << (ReentParser::Plan_parallel_chain - 64))
      | (1ULL << (ReentParser::Plan_parallel_reverse - 64))
      | (1ULL << (ReentParser::Plan_register - 64))
      | (1ULL << (ReentParser::Plan_registered_barrier - 64))
      | (1ULL << (ReentParser::Plan_stop - 64))
      | (1ULL << (ReentParser::Plan_topology - 64))
      | (1ULL << (ReentParser::Plan_type - 64))
      | (1ULL << (ReentParser::Private - 64))
      | (1ULL << (ReentParser::Protected - 64))
      | (1ULL << (ReentParser::Public - 64))
      | (1ULL << (ReentParser::Reduction - 64))
      | (1ULL << (ReentParser::Reenterable - 64))
      | (1ULL << (ReentParser::Register - 64))
      | (1ULL << (ReentParser::Reinterpret_cast - 64))
      | (1ULL << (ReentParser::Reset - 64))
      | (1ULL << (ReentParser::Return - 64))
      | (1ULL << (ReentParser::Set - 64))
      | (1ULL << (ReentParser::Short - 64))
      | (1ULL << (ReentParser::Signed - 64))
      | (1ULL << (ReentParser::Sizeof - 64))
      | (1ULL << (ReentParser::Soft_transact_array - 64))
      | (1ULL << (ReentParser::Soft_transact_in - 64))
      | (1ULL << (ReentParser::Soft_transact_out - 64))
      | (1ULL << (ReentParser::Soft_transact_var - 64))
      | (1ULL << (ReentParser::Static - 64))
      | (1ULL << (ReentParser::Static_assert - 64)))) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & ((1ULL << (ReentParser::Static_cast - 128))
      | (1ULL << (ReentParser::Struct - 128))
      | (1ULL << (ReentParser::Switch - 128))
      | (1ULL << (ReentParser::Template - 128))
      | (1ULL << (ReentParser::This - 128))
      | (1ULL << (ReentParser::Thread_local - 128))
      | (1ULL << (ReentParser::Throw - 128))
      | (1ULL << (ReentParser::Throw_first - 128))
      | (1ULL << (ReentParser::Throw_last - 128))
      | (1ULL << (ReentParser::Transaction_atomic - 128))
      | (1ULL << (ReentParser::True_ - 128))
      | (1ULL << (ReentParser::Try - 128))
      | (1ULL << (ReentParser::Typedef - 128))
      | (1ULL << (ReentParser::Typeid_ - 128))
      | (1ULL << (ReentParser::Typename_ - 128))
      | (1ULL << (ReentParser::Union - 128))
      | (1ULL << (ReentParser::Unsigned - 128))
      | (1ULL << (ReentParser::Using - 128))
      | (1ULL << (ReentParser::Vectorized - 128))
      | (1ULL << (ReentParser::Virtual - 128))
      | (1ULL << (ReentParser::Void - 128))
      | (1ULL << (ReentParser::Volatile - 128))
      | (1ULL << (ReentParser::Wchar - 128))
      | (1ULL << (ReentParser::While - 128))
      | (1ULL << (ReentParser::At - 128))
      | (1ULL << (ReentParser::Dollar - 128))
      | (1ULL << (ReentParser::Is - 128))
      | (1ULL << (ReentParser::LeftParen - 128))
      | (1ULL << (ReentParser::LeftBracket - 128))
      | (1ULL << (ReentParser::LeftBrace - 128))
      | (1ULL << (ReentParser::Underscore - 128))
      | (1ULL << (ReentParser::Plus - 128))
      | (1ULL << (ReentParser::Minus - 128))
      | (1ULL << (ReentParser::Star - 128))
      | (1ULL << (ReentParser::Div - 128))
      | (1ULL << (ReentParser::Mod - 128))
      | (1ULL << (ReentParser::Caret - 128))
      | (1ULL << (ReentParser::And - 128))
      | (1ULL << (ReentParser::Or - 128))
      | (1ULL << (ReentParser::Tilde - 128))
      | (1ULL << (ReentParser::Not - 128))
      | (1ULL << (ReentParser::Assign - 128))
      | (1ULL << (ReentParser::Less - 128))
      | (1ULL << (ReentParser::Greater - 128))
      | (1ULL << (ReentParser::PlusAssign - 128))
      | (1ULL << (ReentParser::MinusAssign - 128))
      | (1ULL << (ReentParser::StarAssign - 128))
      | (1ULL << (ReentParser::DivAssign - 128))
      | (1ULL << (ReentParser::ModAssign - 128))
      | (1ULL << (ReentParser::XorAssign - 128))
      | (1ULL << (ReentParser::AndAssign - 128))
      | (1ULL << (ReentParser::OrAssign - 128))
      | (1ULL << (ReentParser::LeftShiftAssign - 128))
      | (1ULL << (ReentParser::RightShiftAssign - 128))
      | (1ULL << (ReentParser::Equal - 128))
      | (1ULL << (ReentParser::NotEqual - 128))
      | (1ULL << (ReentParser::LessEqual - 128))
      | (1ULL << (ReentParser::GreaterEqual - 128))
      | (1ULL << (ReentParser::AndAnd - 128))
      | (1ULL << (ReentParser::OrOr - 128))
      | (1ULL << (ReentParser::PlusPlus - 128)))) != 0) || ((((_la - 192) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 192)) & ((1ULL << (ReentParser::MinusMinus - 192))
      | (1ULL << (ReentParser::Comma - 192))
      | (1ULL << (ReentParser::ArrowStar - 192))
      | (1ULL << (ReentParser::Arrow - 192))
      | (1ULL << (ReentParser::Question - 192))
      | (1ULL << (ReentParser::Colon - 192))
      | (1ULL << (ReentParser::Doublecolon - 192))
      | (1ULL << (ReentParser::Semi - 192))
      | (1ULL << (ReentParser::Dot - 192))
      | (1ULL << (ReentParser::DotStar - 192))
      | (1ULL << (ReentParser::Ellipsis - 192))
      | (1ULL << (ReentParser::Identifier - 192))
      | (1ULL << (ReentParser::DecimalLiteral - 192))
      | (1ULL << (ReentParser::OctalLiteral - 192))
      | (1ULL << (ReentParser::HexadecimalLiteral - 192))
      | (1ULL << (ReentParser::BinaryLiteral - 192))
      | (1ULL << (ReentParser::Integersuffix - 192))
      | (1ULL << (ReentParser::UserDefinedIntegerLiteral - 192))
      | (1ULL << (ReentParser::UserDefinedFloatingLiteral - 192))
      | (1ULL << (ReentParser::UserDefinedStringLiteral - 192))
      | (1ULL << (ReentParser::UserDefinedCharacterLiteral - 192))
      | (1ULL << (ReentParser::Whitespace - 192))
      | (1ULL << (ReentParser::Newline - 192))
      | (1ULL << (ReentParser::LineComment - 192)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BalancedtokenContext ------------------------------------------------------------------

ReentParser::BalancedtokenContext::BalancedtokenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> ReentParser::BalancedtokenContext::LeftParen() {
  return getTokens(ReentParser::LeftParen);
}

tree::TerminalNode* ReentParser::BalancedtokenContext::LeftParen(size_t i) {
  return getToken(ReentParser::LeftParen, i);
}

ReentParser::BalancedTokenSeqContext* ReentParser::BalancedtokenContext::balancedTokenSeq() {
  return getRuleContext<ReentParser::BalancedTokenSeqContext>(0);
}

std::vector<tree::TerminalNode *> ReentParser::BalancedtokenContext::RightParen() {
  return getTokens(ReentParser::RightParen);
}

tree::TerminalNode* ReentParser::BalancedtokenContext::RightParen(size_t i) {
  return getToken(ReentParser::RightParen, i);
}

std::vector<tree::TerminalNode *> ReentParser::BalancedtokenContext::LeftBracket() {
  return getTokens(ReentParser::LeftBracket);
}

tree::TerminalNode* ReentParser::BalancedtokenContext::LeftBracket(size_t i) {
  return getToken(ReentParser::LeftBracket, i);
}

std::vector<tree::TerminalNode *> ReentParser::BalancedtokenContext::RightBracket() {
  return getTokens(ReentParser::RightBracket);
}

tree::TerminalNode* ReentParser::BalancedtokenContext::RightBracket(size_t i) {
  return getToken(ReentParser::RightBracket, i);
}

std::vector<tree::TerminalNode *> ReentParser::BalancedtokenContext::LeftBrace() {
  return getTokens(ReentParser::LeftBrace);
}

tree::TerminalNode* ReentParser::BalancedtokenContext::LeftBrace(size_t i) {
  return getToken(ReentParser::LeftBrace, i);
}

std::vector<tree::TerminalNode *> ReentParser::BalancedtokenContext::RightBrace() {
  return getTokens(ReentParser::RightBrace);
}

tree::TerminalNode* ReentParser::BalancedtokenContext::RightBrace(size_t i) {
  return getToken(ReentParser::RightBrace, i);
}


size_t ReentParser::BalancedtokenContext::getRuleIndex() const {
  return ReentParser::RuleBalancedtoken;
}

void ReentParser::BalancedtokenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBalancedtoken(this);
}

void ReentParser::BalancedtokenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBalancedtoken(this);
}

ReentParser::BalancedtokenContext* ReentParser::balancedtoken() {
  BalancedtokenContext *_localctx = _tracker.createInstance<BalancedtokenContext>(_ctx, getState());
  enterRule(_localctx, 342, ReentParser::RuleBalancedtoken);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2032);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftParen: {
        enterOuterAlt(_localctx, 1);
        setState(2015);
        match(ReentParser::LeftParen);
        setState(2016);
        balancedTokenSeq();
        setState(2017);
        match(ReentParser::RightParen);
        break;
      }

      case ReentParser::LeftBracket: {
        enterOuterAlt(_localctx, 2);
        setState(2019);
        match(ReentParser::LeftBracket);
        setState(2020);
        balancedTokenSeq();
        setState(2021);
        match(ReentParser::RightBracket);
        break;
      }

      case ReentParser::LeftBrace: {
        enterOuterAlt(_localctx, 3);
        setState(2023);
        match(ReentParser::LeftBrace);
        setState(2024);
        balancedTokenSeq();
        setState(2025);
        match(ReentParser::RightBrace);
        break;
      }

      case ReentParser::IntegerLiteral:
      case ReentParser::CharacterLiteral:
      case ReentParser::FloatingLiteral:
      case ReentParser::StringLiteral:
      case ReentParser::BooleanLiteral:
      case ReentParser::PointerLiteral:
      case ReentParser::UserDefinedLiteral:
      case ReentParser::PlanPragma:
      case ReentParser::DoNotCheck:
      case ReentParser::BlockComment:
      case ReentParser::OtherPragma:
      case ReentParser::Line:
      case ReentParser::MultiLineMacro:
      case ReentParser::Directive:
      case ReentParser::Alignas:
      case ReentParser::Alignof:
      case ReentParser::Asm:
      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Break:
      case ReentParser::Case:
      case ReentParser::Catch:
      case ReentParser::Cfunnel:
      case ReentParser::Chain:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Cilk_for:
      case ReentParser::Cilk_for_:
      case ReentParser::Cilk_spawn:
      case ReentParser::Cilk_spawn_:
      case ReentParser::Cilk_sync:
      case ReentParser::Cilk_sync_:
      case ReentParser::Class:
      case ReentParser::Clear_plan:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Const:
      case ReentParser::Constexpr:
      case ReentParser::Const_cast:
      case ReentParser::Continue:
      case ReentParser::Csem:
      case ReentParser::Cvar:
      case ReentParser::Decltype:
      case ReentParser::Default:
      case ReentParser::Delete:
      case ReentParser::Depends:
      case ReentParser::Do:
      case ReentParser::Double:
      case ReentParser::Dynamic_cast:
      case ReentParser::Else:
      case ReentParser::End:
      case ReentParser::Enum:
      case ReentParser::Explicit:
      case ReentParser::Export:
      case ReentParser::Extern:
      case ReentParser::False_:
      case ReentParser::Final:
      case ReentParser::Float:
      case ReentParser::For:
      case ReentParser::Friend:
      case ReentParser::Funnel:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Goto:
      case ReentParser::GpuGlobal:
      case ReentParser::GpuLocal:
      case ReentParser::Id:
      case ReentParser::If:
      case ReentParser::In:
      case ReentParser::Inline:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Markupdef:
      case ReentParser::Mutable:
      case ReentParser::Namespace:
      case ReentParser::New:
      case ReentParser::Noexcept:
      case ReentParser::Nullptr:
      case ReentParser::Operator:
      case ReentParser::Out:
      case ReentParser::Override:
      case ReentParser::Plan:
      case ReentParser::Plan_atomize:
      case ReentParser::Plan_chain:
      case ReentParser::Plan_critical:
      case ReentParser::Plan_first:
      case ReentParser::Plan_get_first:
      case ReentParser::Plan_get_last:
      case ReentParser::Plan_group_atomize:
      case ReentParser::Plan_group_first:
      case ReentParser::Plan_group_last:
      case ReentParser::Plan_group_parallelize:
      case ReentParser::Plan_group_soft_atomize:
      case ReentParser::Plan_group_vectorize:
      case ReentParser::Plan_item_type:
      case ReentParser::Plan_last:
      case ReentParser::Plan_parallel_chain:
      case ReentParser::Plan_parallel_reverse:
      case ReentParser::Plan_register:
      case ReentParser::Plan_registered_barrier:
      case ReentParser::Plan_stop:
      case ReentParser::Plan_topology:
      case ReentParser::Plan_type:
      case ReentParser::Private:
      case ReentParser::Protected:
      case ReentParser::Public:
      case ReentParser::Reduction:
      case ReentParser::Reenterable:
      case ReentParser::Register:
      case ReentParser::Reinterpret_cast:
      case ReentParser::Reset:
      case ReentParser::Return:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Sizeof:
      case ReentParser::Soft_transact_array:
      case ReentParser::Soft_transact_in:
      case ReentParser::Soft_transact_out:
      case ReentParser::Soft_transact_var:
      case ReentParser::Static:
      case ReentParser::Static_assert:
      case ReentParser::Static_cast:
      case ReentParser::Struct:
      case ReentParser::Switch:
      case ReentParser::Template:
      case ReentParser::This:
      case ReentParser::Thread_local:
      case ReentParser::Throw:
      case ReentParser::Throw_first:
      case ReentParser::Throw_last:
      case ReentParser::Transaction_atomic:
      case ReentParser::True_:
      case ReentParser::Try:
      case ReentParser::Typedef:
      case ReentParser::Typeid_:
      case ReentParser::Typename_:
      case ReentParser::Union:
      case ReentParser::Unsigned:
      case ReentParser::Using:
      case ReentParser::Vectorized:
      case ReentParser::Virtual:
      case ReentParser::Void:
      case ReentParser::Volatile:
      case ReentParser::Wchar:
      case ReentParser::While:
      case ReentParser::At:
      case ReentParser::Dollar:
      case ReentParser::Is:
      case ReentParser::Underscore:
      case ReentParser::Plus:
      case ReentParser::Minus:
      case ReentParser::Star:
      case ReentParser::Div:
      case ReentParser::Mod:
      case ReentParser::Caret:
      case ReentParser::And:
      case ReentParser::Or:
      case ReentParser::Tilde:
      case ReentParser::Not:
      case ReentParser::Assign:
      case ReentParser::Less:
      case ReentParser::Greater:
      case ReentParser::PlusAssign:
      case ReentParser::MinusAssign:
      case ReentParser::StarAssign:
      case ReentParser::DivAssign:
      case ReentParser::ModAssign:
      case ReentParser::XorAssign:
      case ReentParser::AndAssign:
      case ReentParser::OrAssign:
      case ReentParser::LeftShiftAssign:
      case ReentParser::RightShiftAssign:
      case ReentParser::Equal:
      case ReentParser::NotEqual:
      case ReentParser::LessEqual:
      case ReentParser::GreaterEqual:
      case ReentParser::AndAnd:
      case ReentParser::OrOr:
      case ReentParser::PlusPlus:
      case ReentParser::MinusMinus:
      case ReentParser::Comma:
      case ReentParser::ArrowStar:
      case ReentParser::Arrow:
      case ReentParser::Question:
      case ReentParser::Colon:
      case ReentParser::Doublecolon:
      case ReentParser::Semi:
      case ReentParser::Dot:
      case ReentParser::DotStar:
      case ReentParser::Ellipsis:
      case ReentParser::Identifier:
      case ReentParser::DecimalLiteral:
      case ReentParser::OctalLiteral:
      case ReentParser::HexadecimalLiteral:
      case ReentParser::BinaryLiteral:
      case ReentParser::Integersuffix:
      case ReentParser::UserDefinedIntegerLiteral:
      case ReentParser::UserDefinedFloatingLiteral:
      case ReentParser::UserDefinedStringLiteral:
      case ReentParser::UserDefinedCharacterLiteral:
      case ReentParser::Whitespace:
      case ReentParser::Newline:
      case ReentParser::LineComment: {
        enterOuterAlt(_localctx, 4);
        setState(2028); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2027);
                  _la = _input->LA(1);
                  if (_la == 0 || _la == Token::EOF || (((((_la - 155) & ~ 0x3fULL) == 0) &&
                    ((1ULL << (_la - 155)) & ((1ULL << (ReentParser::LeftParen - 155))
                    | (1ULL << (ReentParser::RightParen - 155))
                    | (1ULL << (ReentParser::LeftBracket - 155))
                    | (1ULL << (ReentParser::RightBracket - 155))
                    | (1ULL << (ReentParser::LeftBrace - 155))
                    | (1ULL << (ReentParser::RightBrace - 155)))) != 0))) {
                  _errHandler->recoverInline(this);
                  }
                  else {
                    _errHandler->reportMatch(this);
                    consume();
                  }
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2030); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitDeclaratorListContext ------------------------------------------------------------------

ReentParser::InitDeclaratorListContext::InitDeclaratorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::InitDeclaratorContext *> ReentParser::InitDeclaratorListContext::initDeclarator() {
  return getRuleContexts<ReentParser::InitDeclaratorContext>();
}

ReentParser::InitDeclaratorContext* ReentParser::InitDeclaratorListContext::initDeclarator(size_t i) {
  return getRuleContext<ReentParser::InitDeclaratorContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::InitDeclaratorListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::InitDeclaratorListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::InitDeclaratorListContext::getRuleIndex() const {
  return ReentParser::RuleInitDeclaratorList;
}

void ReentParser::InitDeclaratorListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitDeclaratorList(this);
}

void ReentParser::InitDeclaratorListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitDeclaratorList(this);
}

ReentParser::InitDeclaratorListContext* ReentParser::initDeclaratorList() {
  InitDeclaratorListContext *_localctx = _tracker.createInstance<InitDeclaratorListContext>(_ctx, getState());
  enterRule(_localctx, 344, ReentParser::RuleInitDeclaratorList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2034);
    initDeclarator();
    setState(2039);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2035);
      match(ReentParser::Comma);
      setState(2036);
      initDeclarator();
      setState(2041);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitDeclaratorContext ------------------------------------------------------------------

ReentParser::InitDeclaratorContext::InitDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclaratorContext* ReentParser::InitDeclaratorContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

ReentParser::InitializerContext* ReentParser::InitDeclaratorContext::initializer() {
  return getRuleContext<ReentParser::InitializerContext>(0);
}


size_t ReentParser::InitDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleInitDeclarator;
}

void ReentParser::InitDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitDeclarator(this);
}

void ReentParser::InitDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitDeclarator(this);
}

ReentParser::InitDeclaratorContext* ReentParser::initDeclarator() {
  InitDeclaratorContext *_localctx = _tracker.createInstance<InitDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 346, ReentParser::RuleInitDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2042);
    declarator();
    setState(2044);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 155) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 155)) & ((1ULL << (ReentParser::LeftParen - 155))
      | (1ULL << (ReentParser::LeftBrace - 155))
      | (1ULL << (ReentParser::Assign - 155)))) != 0)) {
      setState(2043);
      initializer();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclaratorContext ------------------------------------------------------------------

ReentParser::DeclaratorContext::DeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::PointerDeclaratorContext* ReentParser::DeclaratorContext::pointerDeclarator() {
  return getRuleContext<ReentParser::PointerDeclaratorContext>(0);
}

ReentParser::NoPointerDeclaratorContext* ReentParser::DeclaratorContext::noPointerDeclarator() {
  return getRuleContext<ReentParser::NoPointerDeclaratorContext>(0);
}

ReentParser::ParametersAndQualifiersContext* ReentParser::DeclaratorContext::parametersAndQualifiers() {
  return getRuleContext<ReentParser::ParametersAndQualifiersContext>(0);
}

ReentParser::TrailingReturnTypeContext* ReentParser::DeclaratorContext::trailingReturnType() {
  return getRuleContext<ReentParser::TrailingReturnTypeContext>(0);
}


size_t ReentParser::DeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleDeclarator;
}

void ReentParser::DeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclarator(this);
}

void ReentParser::DeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclarator(this);
}

ReentParser::DeclaratorContext* ReentParser::declarator() {
  DeclaratorContext *_localctx = _tracker.createInstance<DeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 348, ReentParser::RuleDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2051);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2046);
      pointerDeclarator();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2047);
      noPointerDeclarator(0);
      setState(2048);
      parametersAndQualifiers();
      setState(2049);
      trailingReturnType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerDeclaratorContext ------------------------------------------------------------------

ReentParser::PointerDeclaratorContext::PointerDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::NoPointerDeclaratorContext* ReentParser::PointerDeclaratorContext::noPointerDeclarator() {
  return getRuleContext<ReentParser::NoPointerDeclaratorContext>(0);
}

std::vector<ReentParser::PointerOperatorContext *> ReentParser::PointerDeclaratorContext::pointerOperator() {
  return getRuleContexts<ReentParser::PointerOperatorContext>();
}

ReentParser::PointerOperatorContext* ReentParser::PointerDeclaratorContext::pointerOperator(size_t i) {
  return getRuleContext<ReentParser::PointerOperatorContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::PointerDeclaratorContext::Const() {
  return getTokens(ReentParser::Const);
}

tree::TerminalNode* ReentParser::PointerDeclaratorContext::Const(size_t i) {
  return getToken(ReentParser::Const, i);
}


size_t ReentParser::PointerDeclaratorContext::getRuleIndex() const {
  return ReentParser::RulePointerDeclarator;
}

void ReentParser::PointerDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointerDeclarator(this);
}

void ReentParser::PointerDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointerDeclarator(this);
}

ReentParser::PointerDeclaratorContext* ReentParser::pointerDeclarator() {
  PointerDeclaratorContext *_localctx = _tracker.createInstance<PointerDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 350, ReentParser::RulePointerDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2059);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2053);
        pointerOperator();
        setState(2055);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Const) {
          setState(2054);
          match(ReentParser::Const);
        } 
      }
      setState(2061);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx);
    }
    setState(2062);
    noPointerDeclarator(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoPointerDeclaratorContext ------------------------------------------------------------------

ReentParser::NoPointerDeclaratorContext::NoPointerDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclaratoridContext* ReentParser::NoPointerDeclaratorContext::declaratorid() {
  return getRuleContext<ReentParser::DeclaratoridContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::NoPointerDeclaratorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

tree::TerminalNode* ReentParser::NoPointerDeclaratorContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::PointerDeclaratorContext* ReentParser::NoPointerDeclaratorContext::pointerDeclarator() {
  return getRuleContext<ReentParser::PointerDeclaratorContext>(0);
}

tree::TerminalNode* ReentParser::NoPointerDeclaratorContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::NoPointerDeclaratorContext* ReentParser::NoPointerDeclaratorContext::noPointerDeclarator() {
  return getRuleContext<ReentParser::NoPointerDeclaratorContext>(0);
}

ReentParser::ParametersAndQualifiersContext* ReentParser::NoPointerDeclaratorContext::parametersAndQualifiers() {
  return getRuleContext<ReentParser::ParametersAndQualifiersContext>(0);
}

tree::TerminalNode* ReentParser::NoPointerDeclaratorContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::NoPointerDeclaratorContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::NoPointerDeclaratorContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}


size_t ReentParser::NoPointerDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleNoPointerDeclarator;
}

void ReentParser::NoPointerDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoPointerDeclarator(this);
}

void ReentParser::NoPointerDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoPointerDeclarator(this);
}


ReentParser::NoPointerDeclaratorContext* ReentParser::noPointerDeclarator() {
   return noPointerDeclarator(0);
}

ReentParser::NoPointerDeclaratorContext* ReentParser::noPointerDeclarator(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ReentParser::NoPointerDeclaratorContext *_localctx = _tracker.createInstance<NoPointerDeclaratorContext>(_ctx, parentState);
  ReentParser::NoPointerDeclaratorContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 352;
  enterRecursionRule(_localctx, 352, ReentParser::RuleNoPointerDeclarator, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2073);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Operator:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Tilde:
      case ReentParser::Doublecolon:
      case ReentParser::Ellipsis:
      case ReentParser::Identifier: {
        setState(2065);
        declaratorid();
        setState(2067);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
        case 1: {
          setState(2066);
          attributeSpecifierSeq();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::LeftParen: {
        setState(2069);
        match(ReentParser::LeftParen);
        setState(2070);
        pointerDeclarator();
        setState(2071);
        match(ReentParser::RightParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(2089);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<NoPointerDeclaratorContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleNoPointerDeclarator);
        setState(2075);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2085);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case ReentParser::LeftParen: {
            setState(2076);
            parametersAndQualifiers();
            break;
          }

          case ReentParser::LeftBracket: {
            setState(2077);
            match(ReentParser::LeftBracket);
            setState(2079);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
            case 1: {
              setState(2078);
              constantExpression();
              break;
            }

            default:
              break;
            }
            setState(2081);
            match(ReentParser::RightBracket);
            setState(2083);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
            case 1: {
              setState(2082);
              attributeSpecifierSeq();
              break;
            }

            default:
              break;
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(2091);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ParametersAndQualifiersContext ------------------------------------------------------------------

ReentParser::ParametersAndQualifiersContext::ParametersAndQualifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ParametersAndQualifiersContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::ParametersAndQualifiersContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::ParameterDeclarationClauseContext* ReentParser::ParametersAndQualifiersContext::parameterDeclarationClause() {
  return getRuleContext<ReentParser::ParameterDeclarationClauseContext>(0);
}

ReentParser::CvqualifierseqContext* ReentParser::ParametersAndQualifiersContext::cvqualifierseq() {
  return getRuleContext<ReentParser::CvqualifierseqContext>(0);
}

ReentParser::RefqualifierContext* ReentParser::ParametersAndQualifiersContext::refqualifier() {
  return getRuleContext<ReentParser::RefqualifierContext>(0);
}

ReentParser::ExceptionSpecificationContext* ReentParser::ParametersAndQualifiersContext::exceptionSpecification() {
  return getRuleContext<ReentParser::ExceptionSpecificationContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ParametersAndQualifiersContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::ParametersAndQualifiersContext::getRuleIndex() const {
  return ReentParser::RuleParametersAndQualifiers;
}

void ReentParser::ParametersAndQualifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParametersAndQualifiers(this);
}

void ReentParser::ParametersAndQualifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParametersAndQualifiers(this);
}

ReentParser::ParametersAndQualifiersContext* ReentParser::parametersAndQualifiers() {
  ParametersAndQualifiersContext *_localctx = _tracker.createInstance<ParametersAndQualifiersContext>(_ctx, getState());
  enterRule(_localctx, 354, ReentParser::RuleParametersAndQualifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2092);
    match(ReentParser::LeftParen);
    setState(2094);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 15) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 15)) & ((1ULL << (ReentParser::Alignas - 15))
      | (1ULL << (ReentParser::Auto - 15))
      | (1ULL << (ReentParser::Begin - 15))
      | (1ULL << (ReentParser::Bool - 15))
      | (1ULL << (ReentParser::Cfunnel - 15))
      | (1ULL << (ReentParser::Char - 15))
      | (1ULL << (ReentParser::Char16 - 15))
      | (1ULL << (ReentParser::Char32 - 15))
      | (1ULL << (ReentParser::Class - 15))
      | (1ULL << (ReentParser::Clustered - 15))
      | (1ULL << (ReentParser::Common - 15))
      | (1ULL << (ReentParser::Const - 15))
      | (1ULL << (ReentParser::Constexpr - 15))
      | (1ULL << (ReentParser::Csem - 15))
      | (1ULL << (ReentParser::Cvar - 15))
      | (1ULL << (ReentParser::Decltype - 15))
      | (1ULL << (ReentParser::Depends - 15))
      | (1ULL << (ReentParser::Double - 15))
      | (1ULL << (ReentParser::End - 15))
      | (1ULL << (ReentParser::Enum - 15))
      | (1ULL << (ReentParser::Explicit - 15))
      | (1ULL << (ReentParser::Extern - 15))
      | (1ULL << (ReentParser::Float - 15))
      | (1ULL << (ReentParser::Friend - 15))
      | (1ULL << (ReentParser::Funnel - 15))
      | (1ULL << (ReentParser::Global - 15))
      | (1ULL << (ReentParser::Gpu - 15))
      | (1ULL << (ReentParser::Id - 15))
      | (1ULL << (ReentParser::In - 15))
      | (1ULL << (ReentParser::Inline - 15))
      | (1ULL << (ReentParser::Int - 15))
      | (1ULL << (ReentParser::Local - 15))
      | (1ULL << (ReentParser::Long - 15))
      | (1ULL << (ReentParser::MarkPreCondition - 15))
      | (1ULL << (ReentParser::MarkState - 15))
      | (1ULL << (ReentParser::Markupdef - 15)))) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (ReentParser::Mutable - 79))
      | (1ULL << (ReentParser::Out - 79))
      | (1ULL << (ReentParser::Plan - 79))
      | (1ULL << (ReentParser::Plan_item_type - 79))
      | (1ULL << (ReentParser::Plan_type - 79))
      | (1ULL << (ReentParser::Register - 79))
      | (1ULL << (ReentParser::Reset - 79))
      | (1ULL << (ReentParser::Set - 79))
      | (1ULL << (ReentParser::Short - 79))
      | (1ULL << (ReentParser::Signed - 79))
      | (1ULL << (ReentParser::Soft_transact_array - 79))
      | (1ULL << (ReentParser::Soft_transact_in - 79))
      | (1ULL << (ReentParser::Soft_transact_out - 79))
      | (1ULL << (ReentParser::Soft_transact_var - 79))
      | (1ULL << (ReentParser::Static - 79))
      | (1ULL << (ReentParser::Struct - 79))
      | (1ULL << (ReentParser::Thread_local - 79))
      | (1ULL << (ReentParser::Typedef - 79))
      | (1ULL << (ReentParser::Typename_ - 79)))) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & ((1ULL << (ReentParser::Union - 143))
      | (1ULL << (ReentParser::Unsigned - 143))
      | (1ULL << (ReentParser::Vectorized - 143))
      | (1ULL << (ReentParser::Virtual - 143))
      | (1ULL << (ReentParser::Void - 143))
      | (1ULL << (ReentParser::Volatile - 143))
      | (1ULL << (ReentParser::Wchar - 143))
      | (1ULL << (ReentParser::LeftBracket - 143))
      | (1ULL << (ReentParser::Doublecolon - 143))
      | (1ULL << (ReentParser::Identifier - 143)))) != 0)) {
      setState(2093);
      parameterDeclarationClause();
    }
    setState(2096);
    match(ReentParser::RightParen);
    setState(2098);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 208, _ctx)) {
    case 1: {
      setState(2097);
      cvqualifierseq();
      break;
    }

    default:
      break;
    }
    setState(2101);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
    case 1: {
      setState(2100);
      refqualifier();
      break;
    }

    default:
      break;
    }
    setState(2104);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx)) {
    case 1: {
      setState(2103);
      exceptionSpecification();
      break;
    }

    default:
      break;
    }
    setState(2107);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
    case 1: {
      setState(2106);
      attributeSpecifierSeq();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrailingReturnTypeContext ------------------------------------------------------------------

ReentParser::TrailingReturnTypeContext::TrailingReturnTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TrailingReturnTypeContext::Arrow() {
  return getToken(ReentParser::Arrow, 0);
}

ReentParser::TrailingTypeSpecifierSeqContext* ReentParser::TrailingReturnTypeContext::trailingTypeSpecifierSeq() {
  return getRuleContext<ReentParser::TrailingTypeSpecifierSeqContext>(0);
}

ReentParser::AbstractDeclaratorContext* ReentParser::TrailingReturnTypeContext::abstractDeclarator() {
  return getRuleContext<ReentParser::AbstractDeclaratorContext>(0);
}


size_t ReentParser::TrailingReturnTypeContext::getRuleIndex() const {
  return ReentParser::RuleTrailingReturnType;
}

void ReentParser::TrailingReturnTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrailingReturnType(this);
}

void ReentParser::TrailingReturnTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrailingReturnType(this);
}

ReentParser::TrailingReturnTypeContext* ReentParser::trailingReturnType() {
  TrailingReturnTypeContext *_localctx = _tracker.createInstance<TrailingReturnTypeContext>(_ctx, getState());
  enterRule(_localctx, 356, ReentParser::RuleTrailingReturnType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2109);
    match(ReentParser::Arrow);
    setState(2110);
    trailingTypeSpecifierSeq();
    setState(2112);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 212, _ctx)) {
    case 1: {
      setState(2111);
      abstractDeclarator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerOperatorContext ------------------------------------------------------------------

ReentParser::PointerOperatorContext::PointerOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::PointerOperatorContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::PointerOperatorContext::AndAnd() {
  return getToken(ReentParser::AndAnd, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::PointerOperatorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

tree::TerminalNode* ReentParser::PointerOperatorContext::Star() {
  return getToken(ReentParser::Star, 0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::PointerOperatorContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

ReentParser::CvqualifierseqContext* ReentParser::PointerOperatorContext::cvqualifierseq() {
  return getRuleContext<ReentParser::CvqualifierseqContext>(0);
}


size_t ReentParser::PointerOperatorContext::getRuleIndex() const {
  return ReentParser::RulePointerOperator;
}

void ReentParser::PointerOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointerOperator(this);
}

void ReentParser::PointerOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointerOperator(this);
}

ReentParser::PointerOperatorContext* ReentParser::pointerOperator() {
  PointerOperatorContext *_localctx = _tracker.createInstance<PointerOperatorContext>(_ctx, getState());
  enterRule(_localctx, 358, ReentParser::RulePointerOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2128);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::And:
      case ReentParser::AndAnd: {
        enterOuterAlt(_localctx, 1);
        setState(2114);
        _la = _input->LA(1);
        if (!(_la == ReentParser::And

        || _la == ReentParser::AndAnd)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2116);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
        case 1: {
          setState(2115);
          attributeSpecifierSeq();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Star:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(2119);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ReentParser::Begin)
          | (1ULL << ReentParser::Clustered)
          | (1ULL << ReentParser::Common)
          | (1ULL << ReentParser::Decltype)
          | (1ULL << ReentParser::Depends)
          | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
          | (1ULL << (ReentParser::Gpu - 64))
          | (1ULL << (ReentParser::Id - 64))
          | (1ULL << (ReentParser::In - 64))
          | (1ULL << (ReentParser::Local - 64))
          | (1ULL << (ReentParser::MarkPreCondition - 64))
          | (1ULL << (ReentParser::MarkState - 64))
          | (1ULL << (ReentParser::Out - 64))
          | (1ULL << (ReentParser::Plan - 64))
          | (1ULL << (ReentParser::Reset - 64))
          | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
          | (1ULL << (ReentParser::Doublecolon - 146))
          | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
          setState(2118);
          nestedNameSpecifier(0);
        }
        setState(2121);
        match(ReentParser::Star);
        setState(2123);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
        case 1: {
          setState(2122);
          attributeSpecifierSeq();
          break;
        }

        default:
          break;
        }
        setState(2126);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 216, _ctx)) {
        case 1: {
          setState(2125);
          cvqualifierseq();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CvqualifierseqContext ------------------------------------------------------------------

ReentParser::CvqualifierseqContext::CvqualifierseqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::CvQualifierContext *> ReentParser::CvqualifierseqContext::cvQualifier() {
  return getRuleContexts<ReentParser::CvQualifierContext>();
}

ReentParser::CvQualifierContext* ReentParser::CvqualifierseqContext::cvQualifier(size_t i) {
  return getRuleContext<ReentParser::CvQualifierContext>(i);
}


size_t ReentParser::CvqualifierseqContext::getRuleIndex() const {
  return ReentParser::RuleCvqualifierseq;
}

void ReentParser::CvqualifierseqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCvqualifierseq(this);
}

void ReentParser::CvqualifierseqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCvqualifierseq(this);
}

ReentParser::CvqualifierseqContext* ReentParser::cvqualifierseq() {
  CvqualifierseqContext *_localctx = _tracker.createInstance<CvqualifierseqContext>(_ctx, getState());
  enterRule(_localctx, 360, ReentParser::RuleCvqualifierseq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2131); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2130);
              cvQualifier();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2133); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CvQualifierContext ------------------------------------------------------------------

ReentParser::CvQualifierContext::CvQualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::CvQualifierContext::Const() {
  return getToken(ReentParser::Const, 0);
}

tree::TerminalNode* ReentParser::CvQualifierContext::Volatile() {
  return getToken(ReentParser::Volatile, 0);
}


size_t ReentParser::CvQualifierContext::getRuleIndex() const {
  return ReentParser::RuleCvQualifier;
}

void ReentParser::CvQualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCvQualifier(this);
}

void ReentParser::CvQualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCvQualifier(this);
}

ReentParser::CvQualifierContext* ReentParser::cvQualifier() {
  CvQualifierContext *_localctx = _tracker.createInstance<CvQualifierContext>(_ctx, getState());
  enterRule(_localctx, 362, ReentParser::RuleCvQualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2135);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Const || _la == ReentParser::Volatile)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RefqualifierContext ------------------------------------------------------------------

ReentParser::RefqualifierContext::RefqualifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::RefqualifierContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::RefqualifierContext::AndAnd() {
  return getToken(ReentParser::AndAnd, 0);
}


size_t ReentParser::RefqualifierContext::getRuleIndex() const {
  return ReentParser::RuleRefqualifier;
}

void ReentParser::RefqualifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRefqualifier(this);
}

void ReentParser::RefqualifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRefqualifier(this);
}

ReentParser::RefqualifierContext* ReentParser::refqualifier() {
  RefqualifierContext *_localctx = _tracker.createInstance<RefqualifierContext>(_ctx, getState());
  enterRule(_localctx, 364, ReentParser::RuleRefqualifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2137);
    _la = _input->LA(1);
    if (!(_la == ReentParser::And

    || _la == ReentParser::AndAnd)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclaratoridContext ------------------------------------------------------------------

ReentParser::DeclaratoridContext::DeclaratoridContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::IdExpressionContext* ReentParser::DeclaratoridContext::idExpression() {
  return getRuleContext<ReentParser::IdExpressionContext>(0);
}

tree::TerminalNode* ReentParser::DeclaratoridContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}


size_t ReentParser::DeclaratoridContext::getRuleIndex() const {
  return ReentParser::RuleDeclaratorid;
}

void ReentParser::DeclaratoridContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaratorid(this);
}

void ReentParser::DeclaratoridContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaratorid(this);
}

ReentParser::DeclaratoridContext* ReentParser::declaratorid() {
  DeclaratoridContext *_localctx = _tracker.createInstance<DeclaratoridContext>(_ctx, getState());
  enterRule(_localctx, 366, ReentParser::RuleDeclaratorid);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2140);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(2139);
      match(ReentParser::Ellipsis);
    }
    setState(2142);
    dynamic_cast<DeclaratoridContext *>(_localctx)->ident = idExpression();
     last_declarator_id = (dynamic_cast<DeclaratoridContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<DeclaratoridContext *>(_localctx)->ident->start, dynamic_cast<DeclaratoridContext *>(_localctx)->ident->stop) : nullptr); 
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TheTypeIdContext ------------------------------------------------------------------

ReentParser::TheTypeIdContext::TheTypeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TypeSpecifierSeqContext* ReentParser::TheTypeIdContext::typeSpecifierSeq() {
  return getRuleContext<ReentParser::TypeSpecifierSeqContext>(0);
}

ReentParser::AbstractDeclaratorContext* ReentParser::TheTypeIdContext::abstractDeclarator() {
  return getRuleContext<ReentParser::AbstractDeclaratorContext>(0);
}


size_t ReentParser::TheTypeIdContext::getRuleIndex() const {
  return ReentParser::RuleTheTypeId;
}

void ReentParser::TheTypeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTheTypeId(this);
}

void ReentParser::TheTypeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTheTypeId(this);
}

ReentParser::TheTypeIdContext* ReentParser::theTypeId() {
  TheTypeIdContext *_localctx = _tracker.createInstance<TheTypeIdContext>(_ctx, getState());
  enterRule(_localctx, 368, ReentParser::RuleTheTypeId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2145);
    typeSpecifierSeq();
    setState(2147);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
    case 1: {
      setState(2146);
      abstractDeclarator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AbstractDeclaratorContext ------------------------------------------------------------------

ReentParser::AbstractDeclaratorContext::AbstractDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::PointerAbstractDeclaratorContext* ReentParser::AbstractDeclaratorContext::pointerAbstractDeclarator() {
  return getRuleContext<ReentParser::PointerAbstractDeclaratorContext>(0);
}

ReentParser::ParametersAndQualifiersContext* ReentParser::AbstractDeclaratorContext::parametersAndQualifiers() {
  return getRuleContext<ReentParser::ParametersAndQualifiersContext>(0);
}

ReentParser::TrailingReturnTypeContext* ReentParser::AbstractDeclaratorContext::trailingReturnType() {
  return getRuleContext<ReentParser::TrailingReturnTypeContext>(0);
}

ReentParser::NoPointerAbstractDeclaratorContext* ReentParser::AbstractDeclaratorContext::noPointerAbstractDeclarator() {
  return getRuleContext<ReentParser::NoPointerAbstractDeclaratorContext>(0);
}

ReentParser::AbstractPackDeclaratorContext* ReentParser::AbstractDeclaratorContext::abstractPackDeclarator() {
  return getRuleContext<ReentParser::AbstractPackDeclaratorContext>(0);
}


size_t ReentParser::AbstractDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleAbstractDeclarator;
}

void ReentParser::AbstractDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractDeclarator(this);
}

void ReentParser::AbstractDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractDeclarator(this);
}

ReentParser::AbstractDeclaratorContext* ReentParser::abstractDeclarator() {
  AbstractDeclaratorContext *_localctx = _tracker.createInstance<AbstractDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 370, ReentParser::RuleAbstractDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2157);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2149);
      pointerAbstractDeclarator();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2151);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        setState(2150);
        noPointerAbstractDeclarator(0);
        break;
      }

      default:
        break;
      }
      setState(2153);
      parametersAndQualifiers();
      setState(2154);
      trailingReturnType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2156);
      abstractPackDeclarator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PointerAbstractDeclaratorContext ------------------------------------------------------------------

ReentParser::PointerAbstractDeclaratorContext::PointerAbstractDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::NoPointerAbstractDeclaratorContext* ReentParser::PointerAbstractDeclaratorContext::noPointerAbstractDeclarator() {
  return getRuleContext<ReentParser::NoPointerAbstractDeclaratorContext>(0);
}

std::vector<ReentParser::PointerOperatorContext *> ReentParser::PointerAbstractDeclaratorContext::pointerOperator() {
  return getRuleContexts<ReentParser::PointerOperatorContext>();
}

ReentParser::PointerOperatorContext* ReentParser::PointerAbstractDeclaratorContext::pointerOperator(size_t i) {
  return getRuleContext<ReentParser::PointerOperatorContext>(i);
}


size_t ReentParser::PointerAbstractDeclaratorContext::getRuleIndex() const {
  return ReentParser::RulePointerAbstractDeclarator;
}

void ReentParser::PointerAbstractDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPointerAbstractDeclarator(this);
}

void ReentParser::PointerAbstractDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPointerAbstractDeclarator(this);
}

ReentParser::PointerAbstractDeclaratorContext* ReentParser::pointerAbstractDeclarator() {
  PointerAbstractDeclaratorContext *_localctx = _tracker.createInstance<PointerAbstractDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 372, ReentParser::RulePointerAbstractDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(2168);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftParen:
      case ReentParser::LeftBracket: {
        enterOuterAlt(_localctx, 1);
        setState(2159);
        noPointerAbstractDeclarator(0);
        break;
      }

      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Star:
      case ReentParser::And:
      case ReentParser::AndAnd:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 2);
        setState(2161); 
        _errHandler->sync(this);
        alt = 1;
        do {
          switch (alt) {
            case 1: {
                  setState(2160);
                  pointerOperator();
                  break;
                }

          default:
            throw NoViableAltException(this);
          }
          setState(2163); 
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx);
        } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
        setState(2166);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
        case 1: {
          setState(2165);
          noPointerAbstractDeclarator(0);
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoPointerAbstractDeclaratorContext ------------------------------------------------------------------

ReentParser::NoPointerAbstractDeclaratorContext::NoPointerAbstractDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ParametersAndQualifiersContext* ReentParser::NoPointerAbstractDeclaratorContext::parametersAndQualifiers() {
  return getRuleContext<ReentParser::ParametersAndQualifiersContext>(0);
}

std::vector<tree::TerminalNode *> ReentParser::NoPointerAbstractDeclaratorContext::LeftBracket() {
  return getTokens(ReentParser::LeftBracket);
}

tree::TerminalNode* ReentParser::NoPointerAbstractDeclaratorContext::LeftBracket(size_t i) {
  return getToken(ReentParser::LeftBracket, i);
}

std::vector<tree::TerminalNode *> ReentParser::NoPointerAbstractDeclaratorContext::RightBracket() {
  return getTokens(ReentParser::RightBracket);
}

tree::TerminalNode* ReentParser::NoPointerAbstractDeclaratorContext::RightBracket(size_t i) {
  return getToken(ReentParser::RightBracket, i);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::NoPointerAbstractDeclaratorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

std::vector<ReentParser::ConstantExpressionContext *> ReentParser::NoPointerAbstractDeclaratorContext::constantExpression() {
  return getRuleContexts<ReentParser::ConstantExpressionContext>();
}

ReentParser::ConstantExpressionContext* ReentParser::NoPointerAbstractDeclaratorContext::constantExpression(size_t i) {
  return getRuleContext<ReentParser::ConstantExpressionContext>(i);
}

tree::TerminalNode* ReentParser::NoPointerAbstractDeclaratorContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::PointerAbstractDeclaratorContext* ReentParser::NoPointerAbstractDeclaratorContext::pointerAbstractDeclarator() {
  return getRuleContext<ReentParser::PointerAbstractDeclaratorContext>(0);
}

tree::TerminalNode* ReentParser::NoPointerAbstractDeclaratorContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

std::vector<ReentParser::NoPointerAbstractDeclaratorContext *> ReentParser::NoPointerAbstractDeclaratorContext::noPointerAbstractDeclarator() {
  return getRuleContexts<ReentParser::NoPointerAbstractDeclaratorContext>();
}

ReentParser::NoPointerAbstractDeclaratorContext* ReentParser::NoPointerAbstractDeclaratorContext::noPointerAbstractDeclarator(size_t i) {
  return getRuleContext<ReentParser::NoPointerAbstractDeclaratorContext>(i);
}


size_t ReentParser::NoPointerAbstractDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleNoPointerAbstractDeclarator;
}

void ReentParser::NoPointerAbstractDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoPointerAbstractDeclarator(this);
}

void ReentParser::NoPointerAbstractDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoPointerAbstractDeclarator(this);
}


ReentParser::NoPointerAbstractDeclaratorContext* ReentParser::noPointerAbstractDeclarator() {
   return noPointerAbstractDeclarator(0);
}

ReentParser::NoPointerAbstractDeclaratorContext* ReentParser::noPointerAbstractDeclarator(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ReentParser::NoPointerAbstractDeclaratorContext *_localctx = _tracker.createInstance<NoPointerAbstractDeclaratorContext>(_ctx, parentState);
  ReentParser::NoPointerAbstractDeclaratorContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 374;
  enterRecursionRule(_localctx, 374, ReentParser::RuleNoPointerAbstractDeclarator, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2188);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
    case 1: {
      setState(2171);
      parametersAndQualifiers();
      break;
    }

    case 2: {
      setState(2177); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(2172);
                match(ReentParser::LeftBracket);
                setState(2174);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 226, _ctx)) {
                case 1: {
                  setState(2173);
                  constantExpression();
                  break;
                }

                default:
                  break;
                }
                setState(2176);
                match(ReentParser::RightBracket);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(2179); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(2182);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
      case 1: {
        setState(2181);
        attributeSpecifierSeq();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      setState(2184);
      match(ReentParser::LeftParen);
      setState(2185);
      pointerAbstractDeclarator();
      setState(2186);
      match(ReentParser::RightParen);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(2209);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<NoPointerAbstractDeclaratorContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleNoPointerAbstractDeclarator);
        setState(2190);

        if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
        setState(2205);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 233, _ctx)) {
        case 1: {
          setState(2191);
          parametersAndQualifiers();
          break;
        }

        case 2: {
          setState(2192);
          noPointerAbstractDeclarator(0);
          setState(2198); 
          _errHandler->sync(this);
          alt = 1;
          do {
            switch (alt) {
              case 1: {
                    setState(2193);
                    match(ReentParser::LeftBracket);
                    setState(2195);
                    _errHandler->sync(this);

                    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
                    case 1: {
                      setState(2194);
                      constantExpression();
                      break;
                    }

                    default:
                      break;
                    }
                    setState(2197);
                    match(ReentParser::RightBracket);
                    break;
                  }

            default:
              throw NoViableAltException(this);
            }
            setState(2200); 
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx);
          } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
          setState(2203);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
          case 1: {
            setState(2202);
            attributeSpecifierSeq();
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(2211);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- AbstractPackDeclaratorContext ------------------------------------------------------------------

ReentParser::AbstractPackDeclaratorContext::AbstractPackDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::NoPointerAbstractPackDeclaratorContext* ReentParser::AbstractPackDeclaratorContext::noPointerAbstractPackDeclarator() {
  return getRuleContext<ReentParser::NoPointerAbstractPackDeclaratorContext>(0);
}

std::vector<ReentParser::PointerOperatorContext *> ReentParser::AbstractPackDeclaratorContext::pointerOperator() {
  return getRuleContexts<ReentParser::PointerOperatorContext>();
}

ReentParser::PointerOperatorContext* ReentParser::AbstractPackDeclaratorContext::pointerOperator(size_t i) {
  return getRuleContext<ReentParser::PointerOperatorContext>(i);
}


size_t ReentParser::AbstractPackDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleAbstractPackDeclarator;
}

void ReentParser::AbstractPackDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAbstractPackDeclarator(this);
}

void ReentParser::AbstractPackDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAbstractPackDeclarator(this);
}

ReentParser::AbstractPackDeclaratorContext* ReentParser::abstractPackDeclarator() {
  AbstractPackDeclaratorContext *_localctx = _tracker.createInstance<AbstractPackDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 376, ReentParser::RuleAbstractPackDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2215);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::Begin)
      | (1ULL << ReentParser::Clustered)
      | (1ULL << ReentParser::Common)
      | (1ULL << ReentParser::Decltype)
      | (1ULL << ReentParser::Depends)
      | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
      | (1ULL << (ReentParser::Gpu - 64))
      | (1ULL << (ReentParser::Id - 64))
      | (1ULL << (ReentParser::In - 64))
      | (1ULL << (ReentParser::Local - 64))
      | (1ULL << (ReentParser::MarkPreCondition - 64))
      | (1ULL << (ReentParser::MarkState - 64))
      | (1ULL << (ReentParser::Out - 64))
      | (1ULL << (ReentParser::Plan - 64))
      | (1ULL << (ReentParser::Reset - 64))
      | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
      | (1ULL << (ReentParser::Star - 146))
      | (1ULL << (ReentParser::And - 146))
      | (1ULL << (ReentParser::AndAnd - 146))
      | (1ULL << (ReentParser::Doublecolon - 146))
      | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
      setState(2212);
      pointerOperator();
      setState(2217);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2218);
    noPointerAbstractPackDeclarator(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoPointerAbstractPackDeclaratorContext ------------------------------------------------------------------

ReentParser::NoPointerAbstractPackDeclaratorContext::NoPointerAbstractPackDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NoPointerAbstractPackDeclaratorContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}

ReentParser::NoPointerAbstractPackDeclaratorContext* ReentParser::NoPointerAbstractPackDeclaratorContext::noPointerAbstractPackDeclarator() {
  return getRuleContext<ReentParser::NoPointerAbstractPackDeclaratorContext>(0);
}

ReentParser::ParametersAndQualifiersContext* ReentParser::NoPointerAbstractPackDeclaratorContext::parametersAndQualifiers() {
  return getRuleContext<ReentParser::ParametersAndQualifiersContext>(0);
}

tree::TerminalNode* ReentParser::NoPointerAbstractPackDeclaratorContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::NoPointerAbstractPackDeclaratorContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::NoPointerAbstractPackDeclaratorContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::NoPointerAbstractPackDeclaratorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::NoPointerAbstractPackDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleNoPointerAbstractPackDeclarator;
}

void ReentParser::NoPointerAbstractPackDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoPointerAbstractPackDeclarator(this);
}

void ReentParser::NoPointerAbstractPackDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoPointerAbstractPackDeclarator(this);
}


ReentParser::NoPointerAbstractPackDeclaratorContext* ReentParser::noPointerAbstractPackDeclarator() {
   return noPointerAbstractPackDeclarator(0);
}

ReentParser::NoPointerAbstractPackDeclaratorContext* ReentParser::noPointerAbstractPackDeclarator(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  ReentParser::NoPointerAbstractPackDeclaratorContext *_localctx = _tracker.createInstance<NoPointerAbstractPackDeclaratorContext>(_ctx, parentState);
  ReentParser::NoPointerAbstractPackDeclaratorContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 378;
  enterRecursionRule(_localctx, 378, ReentParser::RuleNoPointerAbstractPackDeclarator, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2221);
    match(ReentParser::Ellipsis);
    _ctx->stop = _input->LT(-1);
    setState(2237);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<NoPointerAbstractPackDeclaratorContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleNoPointerAbstractPackDeclarator);
        setState(2223);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2233);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case ReentParser::LeftParen: {
            setState(2224);
            parametersAndQualifiers();
            break;
          }

          case ReentParser::LeftBracket: {
            setState(2225);
            match(ReentParser::LeftBracket);
            setState(2227);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
            case 1: {
              setState(2226);
              constantExpression();
              break;
            }

            default:
              break;
            }
            setState(2229);
            match(ReentParser::RightBracket);
            setState(2231);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
            case 1: {
              setState(2230);
              attributeSpecifierSeq();
              break;
            }

            default:
              break;
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(2239);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ParameterDeclarationClauseContext ------------------------------------------------------------------

ReentParser::ParameterDeclarationClauseContext::ParameterDeclarationClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ParameterDeclarationListContext* ReentParser::ParameterDeclarationClauseContext::parameterDeclarationList() {
  return getRuleContext<ReentParser::ParameterDeclarationListContext>(0);
}

tree::TerminalNode* ReentParser::ParameterDeclarationClauseContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}

tree::TerminalNode* ReentParser::ParameterDeclarationClauseContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}


size_t ReentParser::ParameterDeclarationClauseContext::getRuleIndex() const {
  return ReentParser::RuleParameterDeclarationClause;
}

void ReentParser::ParameterDeclarationClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterDeclarationClause(this);
}

void ReentParser::ParameterDeclarationClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterDeclarationClause(this);
}

ReentParser::ParameterDeclarationClauseContext* ReentParser::parameterDeclarationClause() {
  ParameterDeclarationClauseContext *_localctx = _tracker.createInstance<ParameterDeclarationClauseContext>(_ctx, getState());
  enterRule(_localctx, 380, ReentParser::RuleParameterDeclarationClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2240);
    parameterDeclarationList();
    setState(2245);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Comma

    || _la == ReentParser::Ellipsis) {
      setState(2242);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Comma) {
        setState(2241);
        match(ReentParser::Comma);
      }
      setState(2244);
      match(ReentParser::Ellipsis);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterDeclarationListContext ------------------------------------------------------------------

ReentParser::ParameterDeclarationListContext::ParameterDeclarationListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::ParameterDeclarationContext *> ReentParser::ParameterDeclarationListContext::parameterDeclaration() {
  return getRuleContexts<ReentParser::ParameterDeclarationContext>();
}

ReentParser::ParameterDeclarationContext* ReentParser::ParameterDeclarationListContext::parameterDeclaration(size_t i) {
  return getRuleContext<ReentParser::ParameterDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::ParameterDeclarationListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::ParameterDeclarationListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::ParameterDeclarationListContext::getRuleIndex() const {
  return ReentParser::RuleParameterDeclarationList;
}

void ReentParser::ParameterDeclarationListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterDeclarationList(this);
}

void ReentParser::ParameterDeclarationListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterDeclarationList(this);
}

ReentParser::ParameterDeclarationListContext* ReentParser::parameterDeclarationList() {
  ParameterDeclarationListContext *_localctx = _tracker.createInstance<ParameterDeclarationListContext>(_ctx, getState());
  enterRule(_localctx, 382, ReentParser::RuleParameterDeclarationList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2247);
    parameterDeclaration();
    setState(2252);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2248);
        match(ReentParser::Comma);
        setState(2249);
        parameterDeclaration(); 
      }
      setState(2254);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterDeclarationContext ------------------------------------------------------------------

ReentParser::ParameterDeclarationContext::ParameterDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclSpecifierSeqContext* ReentParser::ParameterDeclarationContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ParameterDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::DeclaratorContext* ReentParser::ParameterDeclarationContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

tree::TerminalNode* ReentParser::ParameterDeclarationContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::InitializerClauseContext* ReentParser::ParameterDeclarationContext::initializerClause() {
  return getRuleContext<ReentParser::InitializerClauseContext>(0);
}

ReentParser::AbstractDeclaratorContext* ReentParser::ParameterDeclarationContext::abstractDeclarator() {
  return getRuleContext<ReentParser::AbstractDeclaratorContext>(0);
}


size_t ReentParser::ParameterDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleParameterDeclaration;
}

void ReentParser::ParameterDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterDeclaration(this);
}

void ReentParser::ParameterDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterDeclaration(this);
}

ReentParser::ParameterDeclarationContext* ReentParser::parameterDeclaration() {
  ParameterDeclarationContext *_localctx = _tracker.createInstance<ParameterDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 384, ReentParser::RuleParameterDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2256);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(2255);
      attributeSpecifierSeq();
    }
    setState(2258);
    declSpecifierSeq();

    setState(2263);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx)) {
    case 1: {
      setState(2259);
      declarator();
      break;
    }

    case 2: {
      setState(2261);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
      case 1: {
        setState(2260);
        abstractDeclarator();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(2267);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Assign) {
      setState(2265);
      match(ReentParser::Assign);
      setState(2266);
      initializerClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReenterableDefinitionContext ------------------------------------------------------------------

ReentParser::ReenterableDefinitionContext::ReenterableDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ReenterableHeadContext* ReentParser::ReenterableDefinitionContext::reenterableHead() {
  return getRuleContext<ReentParser::ReenterableHeadContext>(0);
}

ReentParser::CompoundStatementContext* ReentParser::ReenterableDefinitionContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}


size_t ReentParser::ReenterableDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleReenterableDefinition;
}

void ReentParser::ReenterableDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReenterableDefinition(this);
}

void ReentParser::ReenterableDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReenterableDefinition(this);
}

ReentParser::ReenterableDefinitionContext* ReentParser::reenterableDefinition() {
  ReenterableDefinitionContext *_localctx = _tracker.createInstance<ReenterableDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 386, ReentParser::RuleReenterableDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2269);
    reenterableHead();
     reenterables[last_reent_chain_declarator] =
    		(reent_static ? static_flag : 0); 
    setState(2271);
    compoundStatement();
     in_reenterable = false; 
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReenterableDeclarationContext ------------------------------------------------------------------

ReentParser::ReenterableDeclarationContext::ReenterableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ReenterableHeadContext* ReentParser::ReenterableDeclarationContext::reenterableHead() {
  return getRuleContext<ReentParser::ReenterableHeadContext>(0);
}

tree::TerminalNode* ReentParser::ReenterableDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::ReenterableDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleReenterableDeclaration;
}

void ReentParser::ReenterableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReenterableDeclaration(this);
}

void ReentParser::ReenterableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReenterableDeclaration(this);
}

ReentParser::ReenterableDeclarationContext* ReentParser::reenterableDeclaration() {
  ReenterableDeclarationContext *_localctx = _tracker.createInstance<ReenterableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 388, ReentParser::RuleReenterableDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2274);
    reenterableHead();
     in_reenterable = false; reenterables[last_reent_chain_declarator] =
    		(reent_static ? static_flag : 0); 
    setState(2276);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReenterableHeadContext ------------------------------------------------------------------

ReentParser::ReenterableHeadContext::ReenterableHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ReenterableHeadContext::Reenterable() {
  return getToken(ReentParser::Reenterable, 0);
}

ReentParser::Reent_chain_headerContext* ReentParser::ReenterableHeadContext::reent_chain_header() {
  return getRuleContext<ReentParser::Reent_chain_headerContext>(0);
}

tree::TerminalNode* ReentParser::ReenterableHeadContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::ReenterableHeadContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::ReenterableHeadContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

tree::TerminalNode* ReentParser::ReenterableHeadContext::Static() {
  return getToken(ReentParser::Static, 0);
}

std::vector<ReentParser::Reent_chain_predicateContext *> ReentParser::ReenterableHeadContext::reent_chain_predicate() {
  return getRuleContexts<ReentParser::Reent_chain_predicateContext>();
}

ReentParser::Reent_chain_predicateContext* ReentParser::ReenterableHeadContext::reent_chain_predicate(size_t i) {
  return getRuleContext<ReentParser::Reent_chain_predicateContext>(i);
}

tree::TerminalNode* ReentParser::ReenterableHeadContext::Local() {
  return getToken(ReentParser::Local, 0);
}

tree::TerminalNode* ReentParser::ReenterableHeadContext::Global() {
  return getToken(ReentParser::Global, 0);
}


size_t ReentParser::ReenterableHeadContext::getRuleIndex() const {
  return ReentParser::RuleReenterableHead;
}

void ReentParser::ReenterableHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReenterableHead(this);
}

void ReentParser::ReenterableHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReenterableHead(this);
}

ReentParser::ReenterableHeadContext* ReentParser::reenterableHead() {
  ReenterableHeadContext *_localctx = _tracker.createInstance<ReenterableHeadContext>(_ctx, getState());
  enterRule(_localctx, 390, ReentParser::RuleReenterableHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2278);
    match(ReentParser::Reenterable);
    setState(2283);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::LeftBracket) {
      setState(2279);
      match(ReentParser::LeftBracket);
      setState(2280);
      constantExpression();
      setState(2281);
      match(ReentParser::RightBracket);
    }
     in_reenterable = true; reent_static = _input->LT(1)->getText() == "static"; 
    setState(2290);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
    case 1: {
      setState(2286);
      match(ReentParser::Static);
      setState(2288);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
      case 1: {
        setState(2287);
        _la = _input->LA(1);
        if (!(_la == ReentParser::Global

        || _la == ReentParser::Local)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
    setState(2292);
    reent_chain_header();
    setState(2296);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Depends || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (ReentParser::If - 70))
      | (1ULL << (ReentParser::Reset - 70))
      | (1ULL << (ReentParser::Set - 70)))) != 0)) {
      setState(2293);
      reent_chain_predicate();
      setState(2298);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_chain_headerContext ------------------------------------------------------------------

ReentParser::Reent_chain_headerContext::Reent_chain_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclaratoridContext* ReentParser::Reent_chain_headerContext::declaratorid() {
  return getRuleContext<ReentParser::DeclaratoridContext>(0);
}

tree::TerminalNode* ReentParser::Reent_chain_headerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_chain_headerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::Reent_chain_headerContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::Reent_chain_paramsContext* ReentParser::Reent_chain_headerContext::reent_chain_params() {
  return getRuleContext<ReentParser::Reent_chain_paramsContext>(0);
}


size_t ReentParser::Reent_chain_headerContext::getRuleIndex() const {
  return ReentParser::RuleReent_chain_header;
}

void ReentParser::Reent_chain_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_chain_header(this);
}

void ReentParser::Reent_chain_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_chain_header(this);
}

ReentParser::Reent_chain_headerContext* ReentParser::reent_chain_header() {
  Reent_chain_headerContext *_localctx = _tracker.createInstance<Reent_chain_headerContext>(_ctx, getState());
  enterRule(_localctx, 392, ReentParser::RuleReent_chain_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2300);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
    case 1: {
      setState(2299);
      declSpecifierSeq();
      break;
    }

    default:
      break;
    }
    setState(2302);
    declaratorid();

    		last_reent_chain_declarator = last_declarator_id;
    		_reent_chain_params.clear();
    		_reent_planned_refs.clear();
    	
    setState(2304);
    match(ReentParser::LeftParen);
    setState(2306);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 18) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 18)) & ((1ULL << (ReentParser::Auto - 18))
      | (1ULL << (ReentParser::Begin - 18))
      | (1ULL << (ReentParser::Bool - 18))
      | (1ULL << (ReentParser::Cfunnel - 18))
      | (1ULL << (ReentParser::Char - 18))
      | (1ULL << (ReentParser::Char16 - 18))
      | (1ULL << (ReentParser::Char32 - 18))
      | (1ULL << (ReentParser::Class - 18))
      | (1ULL << (ReentParser::Clustered - 18))
      | (1ULL << (ReentParser::Common - 18))
      | (1ULL << (ReentParser::Const - 18))
      | (1ULL << (ReentParser::Constexpr - 18))
      | (1ULL << (ReentParser::Csem - 18))
      | (1ULL << (ReentParser::Cvar - 18))
      | (1ULL << (ReentParser::Decltype - 18))
      | (1ULL << (ReentParser::Depends - 18))
      | (1ULL << (ReentParser::Double - 18))
      | (1ULL << (ReentParser::End - 18))
      | (1ULL << (ReentParser::Enum - 18))
      | (1ULL << (ReentParser::Explicit - 18))
      | (1ULL << (ReentParser::Extern - 18))
      | (1ULL << (ReentParser::Float - 18))
      | (1ULL << (ReentParser::Friend - 18))
      | (1ULL << (ReentParser::Funnel - 18))
      | (1ULL << (ReentParser::Global - 18))
      | (1ULL << (ReentParser::Gpu - 18))
      | (1ULL << (ReentParser::GpuGlobal - 18))
      | (1ULL << (ReentParser::GpuLocal - 18))
      | (1ULL << (ReentParser::Id - 18))
      | (1ULL << (ReentParser::In - 18))
      | (1ULL << (ReentParser::Inline - 18))
      | (1ULL << (ReentParser::Int - 18))
      | (1ULL << (ReentParser::Local - 18))
      | (1ULL << (ReentParser::Long - 18))
      | (1ULL << (ReentParser::MarkPreCondition - 18))
      | (1ULL << (ReentParser::MarkState - 18))
      | (1ULL << (ReentParser::Markupdef - 18))
      | (1ULL << (ReentParser::Mutable - 18)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (ReentParser::Operator - 84))
      | (1ULL << (ReentParser::Out - 84))
      | (1ULL << (ReentParser::Plan - 84))
      | (1ULL << (ReentParser::Plan_item_type - 84))
      | (1ULL << (ReentParser::Plan_type - 84))
      | (1ULL << (ReentParser::Reduction - 84))
      | (1ULL << (ReentParser::Register - 84))
      | (1ULL << (ReentParser::Reset - 84))
      | (1ULL << (ReentParser::Set - 84))
      | (1ULL << (ReentParser::Short - 84))
      | (1ULL << (ReentParser::Signed - 84))
      | (1ULL << (ReentParser::Soft_transact_array - 84))
      | (1ULL << (ReentParser::Soft_transact_in - 84))
      | (1ULL << (ReentParser::Soft_transact_out - 84))
      | (1ULL << (ReentParser::Soft_transact_var - 84))
      | (1ULL << (ReentParser::Static - 84))
      | (1ULL << (ReentParser::Struct - 84))
      | (1ULL << (ReentParser::Thread_local - 84))
      | (1ULL << (ReentParser::Typedef - 84))
      | (1ULL << (ReentParser::Typename_ - 84))
      | (1ULL << (ReentParser::Union - 84))
      | (1ULL << (ReentParser::Unsigned - 84))
      | (1ULL << (ReentParser::Vectorized - 84))
      | (1ULL << (ReentParser::Virtual - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (ReentParser::Void - 148))
      | (1ULL << (ReentParser::Volatile - 148))
      | (1ULL << (ReentParser::Wchar - 148))
      | (1ULL << (ReentParser::LeftParen - 148))
      | (1ULL << (ReentParser::Star - 148))
      | (1ULL << (ReentParser::And - 148))
      | (1ULL << (ReentParser::Tilde - 148))
      | (1ULL << (ReentParser::AndAnd - 148))
      | (1ULL << (ReentParser::Doublecolon - 148))
      | (1ULL << (ReentParser::Ellipsis - 148))
      | (1ULL << (ReentParser::Identifier - 148)))) != 0)) {
      setState(2305);
      reent_chain_params();
    }
    setState(2308);
    match(ReentParser::RightParen);

    		for (const std::string & id : _reent_planned_refs)
    			if (_reent_chain_params.find(id) == _reent_chain_params.end())
    				throw FailedPredicateException(this,
    					std::string("__planned__[.|->]")+id+
    					std::string(" : there is no parameter ")+id+
    					std::string(" in current Chain/Reenterable header"));
    	
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_chain_paramsContext ------------------------------------------------------------------

ReentParser::Reent_chain_paramsContext::Reent_chain_paramsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::Reent_chain_paramContext *> ReentParser::Reent_chain_paramsContext::reent_chain_param() {
  return getRuleContexts<ReentParser::Reent_chain_paramContext>();
}

ReentParser::Reent_chain_paramContext* ReentParser::Reent_chain_paramsContext::reent_chain_param(size_t i) {
  return getRuleContext<ReentParser::Reent_chain_paramContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::Reent_chain_paramsContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::Reent_chain_paramsContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::Reent_chain_paramsContext::getRuleIndex() const {
  return ReentParser::RuleReent_chain_params;
}

void ReentParser::Reent_chain_paramsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_chain_params(this);
}

void ReentParser::Reent_chain_paramsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_chain_params(this);
}

ReentParser::Reent_chain_paramsContext* ReentParser::reent_chain_params() {
  Reent_chain_paramsContext *_localctx = _tracker.createInstance<Reent_chain_paramsContext>(_ctx, getState());
  enterRule(_localctx, 394, ReentParser::RuleReent_chain_params);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2311);
    reent_chain_param();
    setState(2316);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2312);
      match(ReentParser::Comma);
      setState(2313);
      reent_chain_param();
      setState(2318);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_chain_paramContext ------------------------------------------------------------------

ReentParser::Reent_chain_paramContext::Reent_chain_paramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclaratorContext* ReentParser::Reent_chain_paramContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

ReentParser::Reent_recursive_typeContext* ReentParser::Reent_chain_paramContext::reent_recursive_type() {
  return getRuleContext<ReentParser::Reent_recursive_typeContext>(0);
}

ReentParser::Reent_reductionContext* ReentParser::Reent_chain_paramContext::reent_reduction() {
  return getRuleContext<ReentParser::Reent_reductionContext>(0);
}

ReentParser::Reent_gpu_globalContext* ReentParser::Reent_chain_paramContext::reent_gpu_global() {
  return getRuleContext<ReentParser::Reent_gpu_globalContext>(0);
}

ReentParser::Reent_gpu_localContext* ReentParser::Reent_chain_paramContext::reent_gpu_local() {
  return getRuleContext<ReentParser::Reent_gpu_localContext>(0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::Reent_chain_paramContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}


size_t ReentParser::Reent_chain_paramContext::getRuleIndex() const {
  return ReentParser::RuleReent_chain_param;
}

void ReentParser::Reent_chain_paramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_chain_param(this);
}

void ReentParser::Reent_chain_paramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_chain_param(this);
}

ReentParser::Reent_chain_paramContext* ReentParser::reent_chain_param() {
  Reent_chain_paramContext *_localctx = _tracker.createInstance<Reent_chain_paramContext>(_ctx, getState());
  enterRule(_localctx, 396, ReentParser::RuleReent_chain_param);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2323);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      setState(2319);
      reent_recursive_type();
      break;
    }

    case 2: {
      setState(2320);
      reent_reduction();
      break;
    }

    case 3: {
      setState(2321);
      reent_gpu_global();
      break;
    }

    case 4: {
      setState(2322);
      reent_gpu_local();
      break;
    }

    default:
      break;
    }
    setState(2326);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
    case 1: {
      setState(2325);
      declSpecifierSeq();
      break;
    }

    default:
      break;
    }
    setState(2328);
    declarator();

    		_reent_chain_params.insert(last_declarator_id);
    	
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_recursive_typeContext ------------------------------------------------------------------

ReentParser::Reent_recursive_typeContext::Reent_recursive_typeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_recursive_typeContext::Id() {
  return getToken(ReentParser::Id, 0);
}

tree::TerminalNode* ReentParser::Reent_recursive_typeContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::Reent_recursive_typeContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_recursive_typeContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_recursive_typeContext::getRuleIndex() const {
  return ReentParser::RuleReent_recursive_type;
}

void ReentParser::Reent_recursive_typeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_recursive_type(this);
}

void ReentParser::Reent_recursive_typeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_recursive_type(this);
}

ReentParser::Reent_recursive_typeContext* ReentParser::reent_recursive_type() {
  Reent_recursive_typeContext *_localctx = _tracker.createInstance<Reent_recursive_typeContext>(_ctx, getState());
  enterRule(_localctx, 398, ReentParser::RuleReent_recursive_type);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2331);
    match(ReentParser::Id);
    setState(2332);
    match(ReentParser::LeftParen);
    setState(2333);
    constantExpression();
    setState(2334);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_reductionContext ------------------------------------------------------------------

ReentParser::Reent_reductionContext::Reent_reductionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_reductionContext::Reduction() {
  return getToken(ReentParser::Reduction, 0);
}

tree::TerminalNode* ReentParser::Reent_reductionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Reent_reductionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::Reduction_symbolContext* ReentParser::Reent_reductionContext::reduction_symbol() {
  return getRuleContext<ReentParser::Reduction_symbolContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::Reent_reductionContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::Reent_reductionContext::getRuleIndex() const {
  return ReentParser::RuleReent_reduction;
}

void ReentParser::Reent_reductionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_reduction(this);
}

void ReentParser::Reent_reductionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_reduction(this);
}

ReentParser::Reent_reductionContext* ReentParser::reent_reduction() {
  Reent_reductionContext *_localctx = _tracker.createInstance<Reent_reductionContext>(_ctx, getState());
  enterRule(_localctx, 400, ReentParser::RuleReent_reduction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2336);
    match(ReentParser::Reduction);
    setState(2337);
    match(ReentParser::LeftParen);
    setState(2340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Plus:
      case ReentParser::Minus:
      case ReentParser::Star:
      case ReentParser::Caret:
      case ReentParser::And:
      case ReentParser::Or:
      case ReentParser::AndAnd:
      case ReentParser::OrOr: {
        setState(2338);
        reduction_symbol();
        break;
      }

      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Identifier: {
        setState(2339);
        anyIdentifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2342);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_gpu_globalContext ------------------------------------------------------------------

ReentParser::Reent_gpu_globalContext::Reent_gpu_globalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_gpu_globalContext::GpuGlobal() {
  return getToken(ReentParser::GpuGlobal, 0);
}

tree::TerminalNode* ReentParser::Reent_gpu_globalContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::Reent_gpu_globalContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_gpu_globalContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_gpu_globalContext::getRuleIndex() const {
  return ReentParser::RuleReent_gpu_global;
}

void ReentParser::Reent_gpu_globalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_gpu_global(this);
}

void ReentParser::Reent_gpu_globalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_gpu_global(this);
}

ReentParser::Reent_gpu_globalContext* ReentParser::reent_gpu_global() {
  Reent_gpu_globalContext *_localctx = _tracker.createInstance<Reent_gpu_globalContext>(_ctx, getState());
  enterRule(_localctx, 402, ReentParser::RuleReent_gpu_global);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2344);
    match(ReentParser::GpuGlobal);

    		if (!allow_vectorized)
    			throw FailedPredicateException(this, "'_global(N)' without '#pragma plan vectorized'");
    	
    setState(2346);
    match(ReentParser::LeftParen);
    setState(2347);
    assignmentExpression();
    setState(2348);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_gpu_localContext ------------------------------------------------------------------

ReentParser::Reent_gpu_localContext::Reent_gpu_localContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_gpu_localContext::GpuLocal() {
  return getToken(ReentParser::GpuLocal, 0);
}

tree::TerminalNode* ReentParser::Reent_gpu_localContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::Reent_gpu_localContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_gpu_localContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_gpu_localContext::getRuleIndex() const {
  return ReentParser::RuleReent_gpu_local;
}

void ReentParser::Reent_gpu_localContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_gpu_local(this);
}

void ReentParser::Reent_gpu_localContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_gpu_local(this);
}

ReentParser::Reent_gpu_localContext* ReentParser::reent_gpu_local() {
  Reent_gpu_localContext *_localctx = _tracker.createInstance<Reent_gpu_localContext>(_ctx, getState());
  enterRule(_localctx, 404, ReentParser::RuleReent_gpu_local);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2350);
    match(ReentParser::GpuLocal);

    		if (!allow_vectorized)
    			throw FailedPredicateException(this, "'_local(N)' without '#pragma plan vectorized'");
    		_in_gpu_local = true;
    	
    setState(2352);
    match(ReentParser::LeftParen);
    setState(2353);
    assignmentExpression();
    setState(2354);
    match(ReentParser::RightParen);

    		_in_gpu_local = false;
    	
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reduction_symbolContext ------------------------------------------------------------------

ReentParser::Reduction_symbolContext::Reduction_symbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::Plus() {
  return getToken(ReentParser::Plus, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::Minus() {
  return getToken(ReentParser::Minus, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::Star() {
  return getToken(ReentParser::Star, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::Caret() {
  return getToken(ReentParser::Caret, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::AndAnd() {
  return getToken(ReentParser::AndAnd, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::OrOr() {
  return getToken(ReentParser::OrOr, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::Reduction_symbolContext::Or() {
  return getToken(ReentParser::Or, 0);
}


size_t ReentParser::Reduction_symbolContext::getRuleIndex() const {
  return ReentParser::RuleReduction_symbol;
}

void ReentParser::Reduction_symbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReduction_symbol(this);
}

void ReentParser::Reduction_symbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReduction_symbol(this);
}

ReentParser::Reduction_symbolContext* ReentParser::reduction_symbol() {
  Reduction_symbolContext *_localctx = _tracker.createInstance<Reduction_symbolContext>(_ctx, getState());
  enterRule(_localctx, 406, ReentParser::RuleReduction_symbol);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2357);
    _la = _input->LA(1);
    if (!(((((_la - 162) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 162)) & ((1ULL << (ReentParser::Plus - 162))
      | (1ULL << (ReentParser::Minus - 162))
      | (1ULL << (ReentParser::Star - 162))
      | (1ULL << (ReentParser::Caret - 162))
      | (1ULL << (ReentParser::And - 162))
      | (1ULL << (ReentParser::Or - 162))
      | (1ULL << (ReentParser::AndAnd - 162))
      | (1ULL << (ReentParser::OrOr - 162)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_chain_predicateContext ------------------------------------------------------------------

ReentParser::Reent_chain_predicateContext::Reent_chain_predicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Reent_predicate_setContext* ReentParser::Reent_chain_predicateContext::reent_predicate_set() {
  return getRuleContext<ReentParser::Reent_predicate_setContext>(0);
}

ReentParser::Reent_predicate_resetContext* ReentParser::Reent_chain_predicateContext::reent_predicate_reset() {
  return getRuleContext<ReentParser::Reent_predicate_resetContext>(0);
}

ReentParser::Reent_predicate_dependsContext* ReentParser::Reent_chain_predicateContext::reent_predicate_depends() {
  return getRuleContext<ReentParser::Reent_predicate_dependsContext>(0);
}

ReentParser::Reent_predicate_ifContext* ReentParser::Reent_chain_predicateContext::reent_predicate_if() {
  return getRuleContext<ReentParser::Reent_predicate_ifContext>(0);
}


size_t ReentParser::Reent_chain_predicateContext::getRuleIndex() const {
  return ReentParser::RuleReent_chain_predicate;
}

void ReentParser::Reent_chain_predicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_chain_predicate(this);
}

void ReentParser::Reent_chain_predicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_chain_predicate(this);
}

ReentParser::Reent_chain_predicateContext* ReentParser::reent_chain_predicate() {
  Reent_chain_predicateContext *_localctx = _tracker.createInstance<Reent_chain_predicateContext>(_ctx, getState());
  enterRule(_localctx, 408, ReentParser::RuleReent_chain_predicate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2363);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Set: {
        enterOuterAlt(_localctx, 1);
        setState(2359);
        reent_predicate_set();
        break;
      }

      case ReentParser::Reset: {
        enterOuterAlt(_localctx, 2);
        setState(2360);
        reent_predicate_reset();
        break;
      }

      case ReentParser::Depends: {
        enterOuterAlt(_localctx, 3);
        setState(2361);
        reent_predicate_depends();
        break;
      }

      case ReentParser::If: {
        enterOuterAlt(_localctx, 4);
        setState(2362);
        reent_predicate_if();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_predicate_setContext ------------------------------------------------------------------

ReentParser::Reent_predicate_setContext::Reent_predicate_setContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_predicate_setContext::Set() {
  return getToken(ReentParser::Set, 0);
}

tree::TerminalNode* ReentParser::Reent_predicate_setContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::Reent_predicate_setContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_predicate_setContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_predicate_setContext::getRuleIndex() const {
  return ReentParser::RuleReent_predicate_set;
}

void ReentParser::Reent_predicate_setContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_predicate_set(this);
}

void ReentParser::Reent_predicate_setContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_predicate_set(this);
}

ReentParser::Reent_predicate_setContext* ReentParser::reent_predicate_set() {
  Reent_predicate_setContext *_localctx = _tracker.createInstance<Reent_predicate_setContext>(_ctx, getState());
  enterRule(_localctx, 410, ReentParser::RuleReent_predicate_set);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2365);
    match(ReentParser::Set);
    setState(2366);
    match(ReentParser::LeftParen);
    setState(2367);
    expression();
    setState(2368);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_predicate_resetContext ------------------------------------------------------------------

ReentParser::Reent_predicate_resetContext::Reent_predicate_resetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_predicate_resetContext::Reset() {
  return getToken(ReentParser::Reset, 0);
}

tree::TerminalNode* ReentParser::Reent_predicate_resetContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::Reent_predicate_resetContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_predicate_resetContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_predicate_resetContext::getRuleIndex() const {
  return ReentParser::RuleReent_predicate_reset;
}

void ReentParser::Reent_predicate_resetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_predicate_reset(this);
}

void ReentParser::Reent_predicate_resetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_predicate_reset(this);
}

ReentParser::Reent_predicate_resetContext* ReentParser::reent_predicate_reset() {
  Reent_predicate_resetContext *_localctx = _tracker.createInstance<Reent_predicate_resetContext>(_ctx, getState());
  enterRule(_localctx, 412, ReentParser::RuleReent_predicate_reset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2370);
    match(ReentParser::Reset);
    setState(2371);
    match(ReentParser::LeftParen);
    setState(2372);
    expression();
    setState(2373);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_predicate_dependsContext ------------------------------------------------------------------

ReentParser::Reent_predicate_dependsContext::Reent_predicate_dependsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_predicate_dependsContext::Depends() {
  return getToken(ReentParser::Depends, 0);
}

tree::TerminalNode* ReentParser::Reent_predicate_dependsContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::Reent_dependentsContext* ReentParser::Reent_predicate_dependsContext::reent_dependents() {
  return getRuleContext<ReentParser::Reent_dependentsContext>(0);
}

tree::TerminalNode* ReentParser::Reent_predicate_dependsContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::Reent_predicate_dependsContext::getRuleIndex() const {
  return ReentParser::RuleReent_predicate_depends;
}

void ReentParser::Reent_predicate_dependsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_predicate_depends(this);
}

void ReentParser::Reent_predicate_dependsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_predicate_depends(this);
}

ReentParser::Reent_predicate_dependsContext* ReentParser::reent_predicate_depends() {
  Reent_predicate_dependsContext *_localctx = _tracker.createInstance<Reent_predicate_dependsContext>(_ctx, getState());
  enterRule(_localctx, 414, ReentParser::RuleReent_predicate_depends);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2375);
    match(ReentParser::Depends);
    setState(2376);
    match(ReentParser::LeftParen);
    setState(2377);
    reent_dependents();
    setState(2378);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_predicate_ifContext ------------------------------------------------------------------

ReentParser::Reent_predicate_ifContext::Reent_predicate_ifContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_predicate_ifContext::If() {
  return getToken(ReentParser::If, 0);
}

tree::TerminalNode* ReentParser::Reent_predicate_ifContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionContext* ReentParser::Reent_predicate_ifContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_predicate_ifContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::Reent_enumeratorContext* ReentParser::Reent_predicate_ifContext::reent_enumerator() {
  return getRuleContext<ReentParser::Reent_enumeratorContext>(0);
}


size_t ReentParser::Reent_predicate_ifContext::getRuleIndex() const {
  return ReentParser::RuleReent_predicate_if;
}

void ReentParser::Reent_predicate_ifContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_predicate_if(this);
}

void ReentParser::Reent_predicate_ifContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_predicate_if(this);
}

ReentParser::Reent_predicate_ifContext* ReentParser::reent_predicate_if() {
  Reent_predicate_ifContext *_localctx = _tracker.createInstance<Reent_predicate_ifContext>(_ctx, getState());
  enterRule(_localctx, 416, ReentParser::RuleReent_predicate_if);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2380);
    match(ReentParser::If);
    setState(2381);
    match(ReentParser::LeftParen);
    setState(2383);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
    case 1: {
      setState(2382);
      reent_enumerator();
      break;
    }

    default:
      break;
    }
    setState(2385);
    expression();
    setState(2386);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_dependentsContext ------------------------------------------------------------------

ReentParser::Reent_dependentsContext::Reent_dependentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Reent_enumeratorContext* ReentParser::Reent_dependentsContext::reent_enumerator() {
  return getRuleContext<ReentParser::Reent_enumeratorContext>(0);
}

std::vector<ReentParser::Reent_single_dependentContext *> ReentParser::Reent_dependentsContext::reent_single_dependent() {
  return getRuleContexts<ReentParser::Reent_single_dependentContext>();
}

ReentParser::Reent_single_dependentContext* ReentParser::Reent_dependentsContext::reent_single_dependent(size_t i) {
  return getRuleContext<ReentParser::Reent_single_dependentContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::Reent_dependentsContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::Reent_dependentsContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::Reent_dependentsContext::getRuleIndex() const {
  return ReentParser::RuleReent_dependents;
}

void ReentParser::Reent_dependentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_dependents(this);
}

void ReentParser::Reent_dependentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_dependents(this);
}

ReentParser::Reent_dependentsContext* ReentParser::reent_dependents() {
  Reent_dependentsContext *_localctx = _tracker.createInstance<Reent_dependentsContext>(_ctx, getState());
  enterRule(_localctx, 418, ReentParser::RuleReent_dependents);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2399);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftBracket: {
        enterOuterAlt(_localctx, 1);
        setState(2388);
        reent_enumerator();
        setState(2389);
        reent_single_dependent();
        break;
      }

      case ReentParser::Id: {
        enterOuterAlt(_localctx, 2);
        setState(2391);
        reent_single_dependent();
        setState(2396);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == ReentParser::Comma) {
          setState(2392);
          match(ReentParser::Comma);
          setState(2393);
          reent_single_dependent();
          setState(2398);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_enumeratorContext ------------------------------------------------------------------

ReentParser::Reent_enumeratorContext::Reent_enumeratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_enumeratorContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

ReentParser::Loop_statement_headerContext* ReentParser::Reent_enumeratorContext::loop_statement_header() {
  return getRuleContext<ReentParser::Loop_statement_headerContext>(0);
}

tree::TerminalNode* ReentParser::Reent_enumeratorContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}


size_t ReentParser::Reent_enumeratorContext::getRuleIndex() const {
  return ReentParser::RuleReent_enumerator;
}

void ReentParser::Reent_enumeratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_enumerator(this);
}

void ReentParser::Reent_enumeratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_enumerator(this);
}

ReentParser::Reent_enumeratorContext* ReentParser::reent_enumerator() {
  Reent_enumeratorContext *_localctx = _tracker.createInstance<Reent_enumeratorContext>(_ctx, getState());
  enterRule(_localctx, 420, ReentParser::RuleReent_enumerator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2401);
    match(ReentParser::LeftBracket);
    setState(2402);
    loop_statement_header();
    setState(2403);
    match(ReentParser::RightBracket);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Loop_statement_headerContext ------------------------------------------------------------------

ReentParser::Loop_statement_headerContext::Loop_statement_headerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::While() {
  return getToken(ReentParser::While, 0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ConditionContext* ReentParser::Loop_statement_headerContext::condition() {
  return getRuleContext<ReentParser::ConditionContext>(0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::For() {
  return getToken(ReentParser::For, 0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::Cilk_for() {
  return getToken(ReentParser::Cilk_for, 0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::Cilk_for_() {
  return getToken(ReentParser::Cilk_for_, 0);
}

ReentParser::ForInitStatementContext* ReentParser::Loop_statement_headerContext::forInitStatement() {
  return getRuleContext<ReentParser::ForInitStatementContext>(0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::ForRangeDeclarationContext* ReentParser::Loop_statement_headerContext::forRangeDeclaration() {
  return getRuleContext<ReentParser::ForRangeDeclarationContext>(0);
}

tree::TerminalNode* ReentParser::Loop_statement_headerContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::ForRangeInitializerContext* ReentParser::Loop_statement_headerContext::forRangeInitializer() {
  return getRuleContext<ReentParser::ForRangeInitializerContext>(0);
}

ReentParser::ExpressionContext* ReentParser::Loop_statement_headerContext::expression() {
  return getRuleContext<ReentParser::ExpressionContext>(0);
}


size_t ReentParser::Loop_statement_headerContext::getRuleIndex() const {
  return ReentParser::RuleLoop_statement_header;
}

void ReentParser::Loop_statement_headerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoop_statement_header(this);
}

void ReentParser::Loop_statement_headerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoop_statement_header(this);
}

ReentParser::Loop_statement_headerContext* ReentParser::loop_statement_header() {
  Loop_statement_headerContext *_localctx = _tracker.createInstance<Loop_statement_headerContext>(_ctx, getState());
  enterRule(_localctx, 422, ReentParser::RuleLoop_statement_header);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2428);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::While: {
        enterOuterAlt(_localctx, 1);
        setState(2405);
        match(ReentParser::While);
        setState(2406);
        match(ReentParser::LeftParen);
        setState(2407);
        condition();
        setState(2408);
        match(ReentParser::RightParen);
        break;
      }

      case ReentParser::Cilk_for:
      case ReentParser::Cilk_for_:
      case ReentParser::For: {
        enterOuterAlt(_localctx, 2);
        setState(2410);
        _la = _input->LA(1);
        if (!((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ReentParser::Cilk_for)
          | (1ULL << ReentParser::Cilk_for_)
          | (1ULL << ReentParser::For))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2411);
        match(ReentParser::LeftParen);
        setState(2424);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
        case 1: {
          setState(2412);
          forInitStatement();
          setState(2414);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 261, _ctx)) {
          case 1: {
            setState(2413);
            condition();
            break;
          }

          default:
            break;
          }
          setState(2416);
          match(ReentParser::Semi);
          setState(2418);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 262, _ctx)) {
          case 1: {
            setState(2417);
            expression();
            break;
          }

          default:
            break;
          }
          break;
        }

        case 2: {
          setState(2420);
          forRangeDeclaration();
          setState(2421);
          match(ReentParser::Colon);
          setState(2422);
          forRangeInitializer();
          break;
        }

        default:
          break;
        }
        setState(2426);
        match(ReentParser::RightParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reent_single_dependentContext ------------------------------------------------------------------

ReentParser::Reent_single_dependentContext::Reent_single_dependentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Reent_single_dependentContext::Id() {
  return getToken(ReentParser::Id, 0);
}

ReentParser::CastExpressionContext* ReentParser::Reent_single_dependentContext::castExpression() {
  return getRuleContext<ReentParser::CastExpressionContext>(0);
}

tree::TerminalNode* ReentParser::Reent_single_dependentContext::Dot() {
  return getToken(ReentParser::Dot, 0);
}

tree::TerminalNode* ReentParser::Reent_single_dependentContext::Arrow() {
  return getToken(ReentParser::Arrow, 0);
}


size_t ReentParser::Reent_single_dependentContext::getRuleIndex() const {
  return ReentParser::RuleReent_single_dependent;
}

void ReentParser::Reent_single_dependentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReent_single_dependent(this);
}

void ReentParser::Reent_single_dependentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReent_single_dependent(this);
}

ReentParser::Reent_single_dependentContext* ReentParser::reent_single_dependent() {
  Reent_single_dependentContext *_localctx = _tracker.createInstance<Reent_single_dependentContext>(_ctx, getState());
  enterRule(_localctx, 424, ReentParser::RuleReent_single_dependent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2430);
    match(ReentParser::Id);
    setState(2431);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Arrow

    || _la == ReentParser::Dot)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2432);
    castExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Chain_interfaceContext ------------------------------------------------------------------

ReentParser::Chain_interfaceContext::Chain_interfaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Chain_interfaceContext::Throw() {
  return getToken(ReentParser::Throw, 0);
}

tree::TerminalNode* ReentParser::Chain_interfaceContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::Chain_interfaceContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::Reent_chain_paramsContext* ReentParser::Chain_interfaceContext::reent_chain_params() {
  return getRuleContext<ReentParser::Reent_chain_paramsContext>(0);
}


size_t ReentParser::Chain_interfaceContext::getRuleIndex() const {
  return ReentParser::RuleChain_interface;
}

void ReentParser::Chain_interfaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChain_interface(this);
}

void ReentParser::Chain_interfaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChain_interface(this);
}

ReentParser::Chain_interfaceContext* ReentParser::chain_interface() {
  Chain_interfaceContext *_localctx = _tracker.createInstance<Chain_interfaceContext>(_ctx, getState());
  enterRule(_localctx, 426, ReentParser::RuleChain_interface);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2434);
    match(ReentParser::Throw);
    setState(2435);
    match(ReentParser::LeftParen);
    setState(2437);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 18) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 18)) & ((1ULL << (ReentParser::Auto - 18))
      | (1ULL << (ReentParser::Begin - 18))
      | (1ULL << (ReentParser::Bool - 18))
      | (1ULL << (ReentParser::Cfunnel - 18))
      | (1ULL << (ReentParser::Char - 18))
      | (1ULL << (ReentParser::Char16 - 18))
      | (1ULL << (ReentParser::Char32 - 18))
      | (1ULL << (ReentParser::Class - 18))
      | (1ULL << (ReentParser::Clustered - 18))
      | (1ULL << (ReentParser::Common - 18))
      | (1ULL << (ReentParser::Const - 18))
      | (1ULL << (ReentParser::Constexpr - 18))
      | (1ULL << (ReentParser::Csem - 18))
      | (1ULL << (ReentParser::Cvar - 18))
      | (1ULL << (ReentParser::Decltype - 18))
      | (1ULL << (ReentParser::Depends - 18))
      | (1ULL << (ReentParser::Double - 18))
      | (1ULL << (ReentParser::End - 18))
      | (1ULL << (ReentParser::Enum - 18))
      | (1ULL << (ReentParser::Explicit - 18))
      | (1ULL << (ReentParser::Extern - 18))
      | (1ULL << (ReentParser::Float - 18))
      | (1ULL << (ReentParser::Friend - 18))
      | (1ULL << (ReentParser::Funnel - 18))
      | (1ULL << (ReentParser::Global - 18))
      | (1ULL << (ReentParser::Gpu - 18))
      | (1ULL << (ReentParser::GpuGlobal - 18))
      | (1ULL << (ReentParser::GpuLocal - 18))
      | (1ULL << (ReentParser::Id - 18))
      | (1ULL << (ReentParser::In - 18))
      | (1ULL << (ReentParser::Inline - 18))
      | (1ULL << (ReentParser::Int - 18))
      | (1ULL << (ReentParser::Local - 18))
      | (1ULL << (ReentParser::Long - 18))
      | (1ULL << (ReentParser::MarkPreCondition - 18))
      | (1ULL << (ReentParser::MarkState - 18))
      | (1ULL << (ReentParser::Markupdef - 18))
      | (1ULL << (ReentParser::Mutable - 18)))) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & ((1ULL << (ReentParser::Operator - 84))
      | (1ULL << (ReentParser::Out - 84))
      | (1ULL << (ReentParser::Plan - 84))
      | (1ULL << (ReentParser::Plan_item_type - 84))
      | (1ULL << (ReentParser::Plan_type - 84))
      | (1ULL << (ReentParser::Reduction - 84))
      | (1ULL << (ReentParser::Register - 84))
      | (1ULL << (ReentParser::Reset - 84))
      | (1ULL << (ReentParser::Set - 84))
      | (1ULL << (ReentParser::Short - 84))
      | (1ULL << (ReentParser::Signed - 84))
      | (1ULL << (ReentParser::Soft_transact_array - 84))
      | (1ULL << (ReentParser::Soft_transact_in - 84))
      | (1ULL << (ReentParser::Soft_transact_out - 84))
      | (1ULL << (ReentParser::Soft_transact_var - 84))
      | (1ULL << (ReentParser::Static - 84))
      | (1ULL << (ReentParser::Struct - 84))
      | (1ULL << (ReentParser::Thread_local - 84))
      | (1ULL << (ReentParser::Typedef - 84))
      | (1ULL << (ReentParser::Typename_ - 84))
      | (1ULL << (ReentParser::Union - 84))
      | (1ULL << (ReentParser::Unsigned - 84))
      | (1ULL << (ReentParser::Vectorized - 84))
      | (1ULL << (ReentParser::Virtual - 84)))) != 0) || ((((_la - 148) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 148)) & ((1ULL << (ReentParser::Void - 148))
      | (1ULL << (ReentParser::Volatile - 148))
      | (1ULL << (ReentParser::Wchar - 148))
      | (1ULL << (ReentParser::LeftParen - 148))
      | (1ULL << (ReentParser::Star - 148))
      | (1ULL << (ReentParser::And - 148))
      | (1ULL << (ReentParser::Tilde - 148))
      | (1ULL << (ReentParser::AndAnd - 148))
      | (1ULL << (ReentParser::Doublecolon - 148))
      | (1ULL << (ReentParser::Ellipsis - 148))
      | (1ULL << (ReentParser::Identifier - 148)))) != 0)) {
      setState(2436);
      reent_chain_params();
    }
    setState(2439);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainDefinitionContext ------------------------------------------------------------------

ReentParser::ChainDefinitionContext::ChainDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ChainHeadContext* ReentParser::ChainDefinitionContext::chainHead() {
  return getRuleContext<ReentParser::ChainHeadContext>(0);
}

ReentParser::CompoundStatementContext* ReentParser::ChainDefinitionContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}


size_t ReentParser::ChainDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleChainDefinition;
}

void ReentParser::ChainDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainDefinition(this);
}

void ReentParser::ChainDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainDefinition(this);
}

ReentParser::ChainDefinitionContext* ReentParser::chainDefinition() {
  ChainDefinitionContext *_localctx = _tracker.createInstance<ChainDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 428, ReentParser::RuleChainDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2441);
    chainHead();
     chains[last_reent_chain_declarator] = 0; 
    setState(2443);
    compoundStatement();
     in_chain = false; 
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainDeclarationContext ------------------------------------------------------------------

ReentParser::ChainDeclarationContext::ChainDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ChainHeadContext* ReentParser::ChainDeclarationContext::chainHead() {
  return getRuleContext<ReentParser::ChainHeadContext>(0);
}

tree::TerminalNode* ReentParser::ChainDeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}


size_t ReentParser::ChainDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleChainDeclaration;
}

void ReentParser::ChainDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainDeclaration(this);
}

void ReentParser::ChainDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainDeclaration(this);
}

ReentParser::ChainDeclarationContext* ReentParser::chainDeclaration() {
  ChainDeclarationContext *_localctx = _tracker.createInstance<ChainDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 430, ReentParser::RuleChainDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2446);
    chainHead();
     in_chain = false; chains[last_reent_chain_declarator] = 0; 
    setState(2448);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChainHeadContext ------------------------------------------------------------------

ReentParser::ChainHeadContext::ChainHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ChainHeadContext::Chain() {
  return getToken(ReentParser::Chain, 0);
}

ReentParser::Reent_chain_headerContext* ReentParser::ChainHeadContext::reent_chain_header() {
  return getRuleContext<ReentParser::Reent_chain_headerContext>(0);
}

tree::TerminalNode* ReentParser::ChainHeadContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::ChainHeadContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::ChainHeadContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

ReentParser::Chain_interfaceContext* ReentParser::ChainHeadContext::chain_interface() {
  return getRuleContext<ReentParser::Chain_interfaceContext>(0);
}

std::vector<ReentParser::Reent_chain_predicateContext *> ReentParser::ChainHeadContext::reent_chain_predicate() {
  return getRuleContexts<ReentParser::Reent_chain_predicateContext>();
}

ReentParser::Reent_chain_predicateContext* ReentParser::ChainHeadContext::reent_chain_predicate(size_t i) {
  return getRuleContext<ReentParser::Reent_chain_predicateContext>(i);
}


size_t ReentParser::ChainHeadContext::getRuleIndex() const {
  return ReentParser::RuleChainHead;
}

void ReentParser::ChainHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChainHead(this);
}

void ReentParser::ChainHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChainHead(this);
}

ReentParser::ChainHeadContext* ReentParser::chainHead() {
  ChainHeadContext *_localctx = _tracker.createInstance<ChainHeadContext>(_ctx, getState());
  enterRule(_localctx, 432, ReentParser::RuleChainHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2450);
    match(ReentParser::Chain);
    setState(2455);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::LeftBracket) {
      setState(2451);
      match(ReentParser::LeftBracket);
      setState(2452);
      constantExpression();
      setState(2453);
      match(ReentParser::RightBracket);
    }

    		in_chain = true;
    	
    setState(2458);
    reent_chain_header();
    setState(2460);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Throw) {
      setState(2459);
      chain_interface();
    }
    setState(2465);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Depends || ((((_la - 70) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 70)) & ((1ULL << (ReentParser::If - 70))
      | (1ULL << (ReentParser::Reset - 70))
      | (1ULL << (ReentParser::Set - 70)))) != 0)) {
      setState(2462);
      reent_chain_predicate();
      setState(2467);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDefinitionContext ------------------------------------------------------------------

ReentParser::FunctionDefinitionContext::FunctionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::FunctionBodyContext* ReentParser::FunctionDefinitionContext::functionBody() {
  return getRuleContext<ReentParser::FunctionBodyContext>(0);
}

ReentParser::Special_method_nameContext* ReentParser::FunctionDefinitionContext::special_method_name() {
  return getRuleContext<ReentParser::Special_method_nameContext>(0);
}

tree::TerminalNode* ReentParser::FunctionDefinitionContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::FunctionDefinitionContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::DeclaratorContext* ReentParser::FunctionDefinitionContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

ReentParser::ParameterDeclarationClauseContext* ReentParser::FunctionDefinitionContext::parameterDeclarationClause() {
  return getRuleContext<ReentParser::ParameterDeclarationClauseContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::FunctionDefinitionContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::FunctionDefinitionContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::VirtualSpecifierSeqContext* ReentParser::FunctionDefinitionContext::virtualSpecifierSeq() {
  return getRuleContext<ReentParser::VirtualSpecifierSeqContext>(0);
}


size_t ReentParser::FunctionDefinitionContext::getRuleIndex() const {
  return ReentParser::RuleFunctionDefinition;
}

void ReentParser::FunctionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDefinition(this);
}

void ReentParser::FunctionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDefinition(this);
}

ReentParser::FunctionDefinitionContext* ReentParser::functionDefinition() {
  FunctionDefinitionContext *_localctx = _tracker.createInstance<FunctionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 434, ReentParser::RuleFunctionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2485);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
    case 1: {
      setState(2468);
      special_method_name();
      setState(2469);
      match(ReentParser::LeftParen);
      setState(2471);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 15) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 15)) & ((1ULL << (ReentParser::Alignas - 15))
        | (1ULL << (ReentParser::Auto - 15))
        | (1ULL << (ReentParser::Begin - 15))
        | (1ULL << (ReentParser::Bool - 15))
        | (1ULL << (ReentParser::Cfunnel - 15))
        | (1ULL << (ReentParser::Char - 15))
        | (1ULL << (ReentParser::Char16 - 15))
        | (1ULL << (ReentParser::Char32 - 15))
        | (1ULL << (ReentParser::Class - 15))
        | (1ULL << (ReentParser::Clustered - 15))
        | (1ULL << (ReentParser::Common - 15))
        | (1ULL << (ReentParser::Const - 15))
        | (1ULL << (ReentParser::Constexpr - 15))
        | (1ULL << (ReentParser::Csem - 15))
        | (1ULL << (ReentParser::Cvar - 15))
        | (1ULL << (ReentParser::Decltype - 15))
        | (1ULL << (ReentParser::Depends - 15))
        | (1ULL << (ReentParser::Double - 15))
        | (1ULL << (ReentParser::End - 15))
        | (1ULL << (ReentParser::Enum - 15))
        | (1ULL << (ReentParser::Explicit - 15))
        | (1ULL << (ReentParser::Extern - 15))
        | (1ULL << (ReentParser::Float - 15))
        | (1ULL << (ReentParser::Friend - 15))
        | (1ULL << (ReentParser::Funnel - 15))
        | (1ULL << (ReentParser::Global - 15))
        | (1ULL << (ReentParser::Gpu - 15))
        | (1ULL << (ReentParser::Id - 15))
        | (1ULL << (ReentParser::In - 15))
        | (1ULL << (ReentParser::Inline - 15))
        | (1ULL << (ReentParser::Int - 15))
        | (1ULL << (ReentParser::Local - 15))
        | (1ULL << (ReentParser::Long - 15))
        | (1ULL << (ReentParser::MarkPreCondition - 15))
        | (1ULL << (ReentParser::MarkState - 15))
        | (1ULL << (ReentParser::Markupdef - 15)))) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 79)) & ((1ULL << (ReentParser::Mutable - 79))
        | (1ULL << (ReentParser::Out - 79))
        | (1ULL << (ReentParser::Plan - 79))
        | (1ULL << (ReentParser::Plan_item_type - 79))
        | (1ULL << (ReentParser::Plan_type - 79))
        | (1ULL << (ReentParser::Register - 79))
        | (1ULL << (ReentParser::Reset - 79))
        | (1ULL << (ReentParser::Set - 79))
        | (1ULL << (ReentParser::Short - 79))
        | (1ULL << (ReentParser::Signed - 79))
        | (1ULL << (ReentParser::Soft_transact_array - 79))
        | (1ULL << (ReentParser::Soft_transact_in - 79))
        | (1ULL << (ReentParser::Soft_transact_out - 79))
        | (1ULL << (ReentParser::Soft_transact_var - 79))
        | (1ULL << (ReentParser::Static - 79))
        | (1ULL << (ReentParser::Struct - 79))
        | (1ULL << (ReentParser::Thread_local - 79))
        | (1ULL << (ReentParser::Typedef - 79))
        | (1ULL << (ReentParser::Typename_ - 79)))) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 143)) & ((1ULL << (ReentParser::Union - 143))
        | (1ULL << (ReentParser::Unsigned - 143))
        | (1ULL << (ReentParser::Vectorized - 143))
        | (1ULL << (ReentParser::Virtual - 143))
        | (1ULL << (ReentParser::Void - 143))
        | (1ULL << (ReentParser::Volatile - 143))
        | (1ULL << (ReentParser::Wchar - 143))
        | (1ULL << (ReentParser::LeftBracket - 143))
        | (1ULL << (ReentParser::Doublecolon - 143))
        | (1ULL << (ReentParser::Identifier - 143)))) != 0)) {
        setState(2470);
        parameterDeclarationClause();
      }
      setState(2473);
      match(ReentParser::RightParen);
      break;
    }

    case 2: {
      setState(2476);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
        setState(2475);
        attributeSpecifierSeq();
      }
      setState(2479);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
      case 1: {
        setState(2478);
        declSpecifierSeq();
        break;
      }

      default:
        break;
      }
      setState(2481);
      declarator();
      setState(2483);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Final

      || _la == ReentParser::Override) {
        setState(2482);
        virtualSpecifierSeq();
      }
      break;
    }

    default:
      break;
    }
    setState(2487);
    functionBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Special_method_nameContext ------------------------------------------------------------------

ReentParser::Special_method_nameContext::Special_method_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::AnyIdentifierContext *> ReentParser::Special_method_nameContext::anyIdentifier() {
  return getRuleContexts<ReentParser::AnyIdentifierContext>();
}

ReentParser::AnyIdentifierContext* ReentParser::Special_method_nameContext::anyIdentifier(size_t i) {
  return getRuleContext<ReentParser::AnyIdentifierContext>(i);
}

tree::TerminalNode* ReentParser::Special_method_nameContext::Doublecolon() {
  return getToken(ReentParser::Doublecolon, 0);
}

tree::TerminalNode* ReentParser::Special_method_nameContext::Tilde() {
  return getToken(ReentParser::Tilde, 0);
}


size_t ReentParser::Special_method_nameContext::getRuleIndex() const {
  return ReentParser::RuleSpecial_method_name;
}

void ReentParser::Special_method_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecial_method_name(this);
}

void ReentParser::Special_method_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecial_method_name(this);
}

ReentParser::Special_method_nameContext* ReentParser::special_method_name() {
  Special_method_nameContext *_localctx = _tracker.createInstance<Special_method_nameContext>(_ctx, getState());
  enterRule(_localctx, 436, ReentParser::RuleSpecial_method_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2489);
    anyIdentifier();
    setState(2490);
    match(ReentParser::Doublecolon);
    setState(2492);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Tilde) {
      setState(2491);
      match(ReentParser::Tilde);
    }
    setState(2494);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionBodyContext ------------------------------------------------------------------

ReentParser::FunctionBodyContext::FunctionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::CompoundStatementContext* ReentParser::FunctionBodyContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}

ReentParser::ConstructorInitializerContext* ReentParser::FunctionBodyContext::constructorInitializer() {
  return getRuleContext<ReentParser::ConstructorInitializerContext>(0);
}

ReentParser::FunctionTryBlockContext* ReentParser::FunctionBodyContext::functionTryBlock() {
  return getRuleContext<ReentParser::FunctionTryBlockContext>(0);
}

tree::TerminalNode* ReentParser::FunctionBodyContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

tree::TerminalNode* ReentParser::FunctionBodyContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::FunctionBodyContext::Default() {
  return getToken(ReentParser::Default, 0);
}

tree::TerminalNode* ReentParser::FunctionBodyContext::Delete() {
  return getToken(ReentParser::Delete, 0);
}


size_t ReentParser::FunctionBodyContext::getRuleIndex() const {
  return ReentParser::RuleFunctionBody;
}

void ReentParser::FunctionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionBody(this);
}

void ReentParser::FunctionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionBody(this);
}

ReentParser::FunctionBodyContext* ReentParser::functionBody() {
  FunctionBodyContext *_localctx = _tracker.createInstance<FunctionBodyContext>(_ctx, getState());
  enterRule(_localctx, 438, ReentParser::RuleFunctionBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2504);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftBrace:
      case ReentParser::Colon: {
        enterOuterAlt(_localctx, 1);
        setState(2497);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Colon) {
          setState(2496);
          constructorInitializer();
        }
        setState(2499);
        compoundStatement();
        break;
      }

      case ReentParser::Try: {
        enterOuterAlt(_localctx, 2);
        setState(2500);
        functionTryBlock();
        break;
      }

      case ReentParser::Assign: {
        enterOuterAlt(_localctx, 3);
        setState(2501);
        match(ReentParser::Assign);
        setState(2502);
        _la = _input->LA(1);
        if (!(_la == ReentParser::Default

        || _la == ReentParser::Delete)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2503);
        match(ReentParser::Semi);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitializerContext ------------------------------------------------------------------

ReentParser::InitializerContext::InitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::BraceOrEqualInitializerContext* ReentParser::InitializerContext::braceOrEqualInitializer() {
  return getRuleContext<ReentParser::BraceOrEqualInitializerContext>(0);
}

tree::TerminalNode* ReentParser::InitializerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExpressionListContext* ReentParser::InitializerContext::expressionList() {
  return getRuleContext<ReentParser::ExpressionListContext>(0);
}

tree::TerminalNode* ReentParser::InitializerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::InitializerContext::getRuleIndex() const {
  return ReentParser::RuleInitializer;
}

void ReentParser::InitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializer(this);
}

void ReentParser::InitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializer(this);
}

ReentParser::InitializerContext* ReentParser::initializer() {
  InitializerContext *_localctx = _tracker.createInstance<InitializerContext>(_ctx, getState());
  enterRule(_localctx, 440, ReentParser::RuleInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2511);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftBrace:
      case ReentParser::Assign: {
        enterOuterAlt(_localctx, 1);
        setState(2506);
        braceOrEqualInitializer();
        break;
      }

      case ReentParser::LeftParen: {
        enterOuterAlt(_localctx, 2);
        setState(2507);
        match(ReentParser::LeftParen);
        setState(2508);
        expressionList();
        setState(2509);
        match(ReentParser::RightParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BraceOrEqualInitializerContext ------------------------------------------------------------------

ReentParser::BraceOrEqualInitializerContext::BraceOrEqualInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::BraceOrEqualInitializerContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::InitializerClauseContext* ReentParser::BraceOrEqualInitializerContext::initializerClause() {
  return getRuleContext<ReentParser::InitializerClauseContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::BraceOrEqualInitializerContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}


size_t ReentParser::BraceOrEqualInitializerContext::getRuleIndex() const {
  return ReentParser::RuleBraceOrEqualInitializer;
}

void ReentParser::BraceOrEqualInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBraceOrEqualInitializer(this);
}

void ReentParser::BraceOrEqualInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBraceOrEqualInitializer(this);
}

ReentParser::BraceOrEqualInitializerContext* ReentParser::braceOrEqualInitializer() {
  BraceOrEqualInitializerContext *_localctx = _tracker.createInstance<BraceOrEqualInitializerContext>(_ctx, getState());
  enterRule(_localctx, 442, ReentParser::RuleBraceOrEqualInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2516);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Assign: {
        enterOuterAlt(_localctx, 1);
        setState(2513);
        match(ReentParser::Assign);
        setState(2514);
        initializerClause();
        break;
      }

      case ReentParser::LeftBrace: {
        enterOuterAlt(_localctx, 2);
        setState(2515);
        bracedInitList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitializerClauseContext ------------------------------------------------------------------

ReentParser::InitializerClauseContext::InitializerClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AssignmentExpressionContext* ReentParser::InitializerClauseContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}

ReentParser::BracedInitListContext* ReentParser::InitializerClauseContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}


size_t ReentParser::InitializerClauseContext::getRuleIndex() const {
  return ReentParser::RuleInitializerClause;
}

void ReentParser::InitializerClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializerClause(this);
}

void ReentParser::InitializerClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializerClause(this);
}

ReentParser::InitializerClauseContext* ReentParser::initializerClause() {
  InitializerClauseContext *_localctx = _tracker.createInstance<InitializerClauseContext>(_ctx, getState());
  enterRule(_localctx, 444, ReentParser::RuleInitializerClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2520);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2518);
      assignmentExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2519);
      bracedInitList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitializerListContext ------------------------------------------------------------------

ReentParser::InitializerListContext::InitializerListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::InitializerClauseContext *> ReentParser::InitializerListContext::initializerClause() {
  return getRuleContexts<ReentParser::InitializerClauseContext>();
}

ReentParser::InitializerClauseContext* ReentParser::InitializerListContext::initializerClause(size_t i) {
  return getRuleContext<ReentParser::InitializerClauseContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::InitializerListContext::Ellipsis() {
  return getTokens(ReentParser::Ellipsis);
}

tree::TerminalNode* ReentParser::InitializerListContext::Ellipsis(size_t i) {
  return getToken(ReentParser::Ellipsis, i);
}

std::vector<tree::TerminalNode *> ReentParser::InitializerListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::InitializerListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::InitializerListContext::getRuleIndex() const {
  return ReentParser::RuleInitializerList;
}

void ReentParser::InitializerListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitializerList(this);
}

void ReentParser::InitializerListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitializerList(this);
}

ReentParser::InitializerListContext* ReentParser::initializerList() {
  InitializerListContext *_localctx = _tracker.createInstance<InitializerListContext>(_ctx, getState());
  enterRule(_localctx, 446, ReentParser::RuleInitializerList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2522);
    initializerClause();
    setState(2524);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(2523);
      match(ReentParser::Ellipsis);
    }
    setState(2533);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2526);
        match(ReentParser::Comma);
        setState(2527);
        initializerClause();
        setState(2529);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Ellipsis) {
          setState(2528);
          match(ReentParser::Ellipsis);
        } 
      }
      setState(2535);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BracedInitListContext ------------------------------------------------------------------

ReentParser::BracedInitListContext::BracedInitListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::BracedInitListContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::BracedInitListContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

ReentParser::InitializerListContext* ReentParser::BracedInitListContext::initializerList() {
  return getRuleContext<ReentParser::InitializerListContext>(0);
}

tree::TerminalNode* ReentParser::BracedInitListContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}


size_t ReentParser::BracedInitListContext::getRuleIndex() const {
  return ReentParser::RuleBracedInitList;
}

void ReentParser::BracedInitListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBracedInitList(this);
}

void ReentParser::BracedInitListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBracedInitList(this);
}

ReentParser::BracedInitListContext* ReentParser::bracedInitList() {
  BracedInitListContext *_localctx = _tracker.createInstance<BracedInitListContext>(_ctx, getState());
  enterRule(_localctx, 448, ReentParser::RuleBracedInitList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2536);
    match(ReentParser::LeftBrace);
    setState(2541);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
    case 1: {
      setState(2537);
      initializerList();
      setState(2539);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Comma) {
        setState(2538);
        match(ReentParser::Comma);
      }
      break;
    }

    default:
      break;
    }
    setState(2543);
    match(ReentParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassNameContext ------------------------------------------------------------------

ReentParser::ClassNameContext::ClassNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::SimpleTemplateIdContext* ReentParser::ClassNameContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::ClassNameContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::ClassNameContext::getRuleIndex() const {
  return ReentParser::RuleClassName;
}

void ReentParser::ClassNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassName(this);
}

void ReentParser::ClassNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassName(this);
}

ReentParser::ClassNameContext* ReentParser::className() {
  ClassNameContext *_localctx = _tracker.createInstance<ClassNameContext>(_ctx, getState());
  enterRule(_localctx, 450, ReentParser::RuleClassName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2547);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2545);
      simpleTemplateId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2546);
      anyIdentifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassSpecifierContext ------------------------------------------------------------------

ReentParser::ClassSpecifierContext::ClassSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassHeadContext* ReentParser::ClassSpecifierContext::classHead() {
  return getRuleContext<ReentParser::ClassHeadContext>(0);
}

tree::TerminalNode* ReentParser::ClassSpecifierContext::LeftBrace() {
  return getToken(ReentParser::LeftBrace, 0);
}

tree::TerminalNode* ReentParser::ClassSpecifierContext::RightBrace() {
  return getToken(ReentParser::RightBrace, 0);
}

ReentParser::MemberSpecificationContext* ReentParser::ClassSpecifierContext::memberSpecification() {
  return getRuleContext<ReentParser::MemberSpecificationContext>(0);
}


size_t ReentParser::ClassSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleClassSpecifier;
}

void ReentParser::ClassSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassSpecifier(this);
}

void ReentParser::ClassSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassSpecifier(this);
}

ReentParser::ClassSpecifierContext* ReentParser::classSpecifier() {
  ClassSpecifierContext *_localctx = _tracker.createInstance<ClassSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 452, ReentParser::RuleClassSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2549);
    classHead();
    setState(2550);
    match(ReentParser::LeftBrace);
    setState(2552);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 15) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 15)) & ((1ULL << (ReentParser::Alignas - 15))
      | (1ULL << (ReentParser::Auto - 15))
      | (1ULL << (ReentParser::Begin - 15))
      | (1ULL << (ReentParser::Bool - 15))
      | (1ULL << (ReentParser::Cfunnel - 15))
      | (1ULL << (ReentParser::Char - 15))
      | (1ULL << (ReentParser::Char16 - 15))
      | (1ULL << (ReentParser::Char32 - 15))
      | (1ULL << (ReentParser::Class - 15))
      | (1ULL << (ReentParser::Clustered - 15))
      | (1ULL << (ReentParser::Common - 15))
      | (1ULL << (ReentParser::Const - 15))
      | (1ULL << (ReentParser::Constexpr - 15))
      | (1ULL << (ReentParser::Csem - 15))
      | (1ULL << (ReentParser::Cvar - 15))
      | (1ULL << (ReentParser::Decltype - 15))
      | (1ULL << (ReentParser::Depends - 15))
      | (1ULL << (ReentParser::Double - 15))
      | (1ULL << (ReentParser::End - 15))
      | (1ULL << (ReentParser::Enum - 15))
      | (1ULL << (ReentParser::Explicit - 15))
      | (1ULL << (ReentParser::Extern - 15))
      | (1ULL << (ReentParser::Float - 15))
      | (1ULL << (ReentParser::Friend - 15))
      | (1ULL << (ReentParser::Funnel - 15))
      | (1ULL << (ReentParser::Global - 15))
      | (1ULL << (ReentParser::Gpu - 15))
      | (1ULL << (ReentParser::Id - 15))
      | (1ULL << (ReentParser::In - 15))
      | (1ULL << (ReentParser::Inline - 15))
      | (1ULL << (ReentParser::Int - 15))
      | (1ULL << (ReentParser::Local - 15))
      | (1ULL << (ReentParser::Long - 15))
      | (1ULL << (ReentParser::MarkPreCondition - 15))
      | (1ULL << (ReentParser::MarkState - 15))
      | (1ULL << (ReentParser::Markupdef - 15)))) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (ReentParser::Mutable - 79))
      | (1ULL << (ReentParser::Operator - 79))
      | (1ULL << (ReentParser::Out - 79))
      | (1ULL << (ReentParser::Plan - 79))
      | (1ULL << (ReentParser::Plan_item_type - 79))
      | (1ULL << (ReentParser::Plan_type - 79))
      | (1ULL << (ReentParser::Private - 79))
      | (1ULL << (ReentParser::Protected - 79))
      | (1ULL << (ReentParser::Public - 79))
      | (1ULL << (ReentParser::Register - 79))
      | (1ULL << (ReentParser::Reset - 79))
      | (1ULL << (ReentParser::Set - 79))
      | (1ULL << (ReentParser::Short - 79))
      | (1ULL << (ReentParser::Signed - 79))
      | (1ULL << (ReentParser::Soft_transact_array - 79))
      | (1ULL << (ReentParser::Soft_transact_in - 79))
      | (1ULL << (ReentParser::Soft_transact_out - 79))
      | (1ULL << (ReentParser::Soft_transact_var - 79))
      | (1ULL << (ReentParser::Static - 79))
      | (1ULL << (ReentParser::Static_assert - 79))
      | (1ULL << (ReentParser::Struct - 79))
      | (1ULL << (ReentParser::Template - 79))
      | (1ULL << (ReentParser::Thread_local - 79))
      | (1ULL << (ReentParser::Typedef - 79))
      | (1ULL << (ReentParser::Typename_ - 79)))) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & ((1ULL << (ReentParser::Union - 143))
      | (1ULL << (ReentParser::Unsigned - 143))
      | (1ULL << (ReentParser::Using - 143))
      | (1ULL << (ReentParser::Vectorized - 143))
      | (1ULL << (ReentParser::Virtual - 143))
      | (1ULL << (ReentParser::Void - 143))
      | (1ULL << (ReentParser::Volatile - 143))
      | (1ULL << (ReentParser::Wchar - 143))
      | (1ULL << (ReentParser::LeftParen - 143))
      | (1ULL << (ReentParser::LeftBracket - 143))
      | (1ULL << (ReentParser::Star - 143))
      | (1ULL << (ReentParser::And - 143))
      | (1ULL << (ReentParser::Tilde - 143))
      | (1ULL << (ReentParser::AndAnd - 143))
      | (1ULL << (ReentParser::Colon - 143))
      | (1ULL << (ReentParser::Doublecolon - 143))
      | (1ULL << (ReentParser::Semi - 143))
      | (1ULL << (ReentParser::Ellipsis - 143))
      | (1ULL << (ReentParser::Identifier - 143)))) != 0)) {
      setState(2551);
      memberSpecification();
    }
    setState(2554);
    match(ReentParser::RightBrace);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassHeadContext ------------------------------------------------------------------

ReentParser::ClassHeadContext::ClassHeadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassKeyContext* ReentParser::ClassHeadContext::classKey() {
  return getRuleContext<ReentParser::ClassKeyContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ClassHeadContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::ClassHeadNameContext* ReentParser::ClassHeadContext::classHeadName() {
  return getRuleContext<ReentParser::ClassHeadNameContext>(0);
}

ReentParser::BaseClauseContext* ReentParser::ClassHeadContext::baseClause() {
  return getRuleContext<ReentParser::BaseClauseContext>(0);
}

ReentParser::ClassVirtSpecifierContext* ReentParser::ClassHeadContext::classVirtSpecifier() {
  return getRuleContext<ReentParser::ClassVirtSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::ClassHeadContext::Union() {
  return getToken(ReentParser::Union, 0);
}


size_t ReentParser::ClassHeadContext::getRuleIndex() const {
  return ReentParser::RuleClassHead;
}

void ReentParser::ClassHeadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassHead(this);
}

void ReentParser::ClassHeadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassHead(this);
}

ReentParser::ClassHeadContext* ReentParser::classHead() {
  ClassHeadContext *_localctx = _tracker.createInstance<ClassHeadContext>(_ctx, getState());
  enterRule(_localctx, 454, ReentParser::RuleClassHead);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2579);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Class:
      case ReentParser::Struct: {
        enterOuterAlt(_localctx, 1);
        setState(2556);
        classKey();
        setState(2558);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
          setState(2557);
          attributeSpecifierSeq();
        }
        setState(2564);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ReentParser::Begin)
          | (1ULL << ReentParser::Clustered)
          | (1ULL << ReentParser::Common)
          | (1ULL << ReentParser::Decltype)
          | (1ULL << ReentParser::Depends)
          | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
          | (1ULL << (ReentParser::Gpu - 64))
          | (1ULL << (ReentParser::Id - 64))
          | (1ULL << (ReentParser::In - 64))
          | (1ULL << (ReentParser::Local - 64))
          | (1ULL << (ReentParser::MarkPreCondition - 64))
          | (1ULL << (ReentParser::MarkState - 64))
          | (1ULL << (ReentParser::Out - 64))
          | (1ULL << (ReentParser::Plan - 64))
          | (1ULL << (ReentParser::Reset - 64))
          | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
          | (1ULL << (ReentParser::Doublecolon - 146))
          | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
          setState(2560);
          classHeadName();
          setState(2562);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ReentParser::Final) {
            setState(2561);
            classVirtSpecifier();
          }
        }
        setState(2567);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Colon) {
          setState(2566);
          baseClause();
        }
        break;
      }

      case ReentParser::Union: {
        enterOuterAlt(_localctx, 2);
        setState(2569);
        match(ReentParser::Union);
        setState(2571);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
          setState(2570);
          attributeSpecifierSeq();
        }
        setState(2577);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & ((1ULL << ReentParser::Begin)
          | (1ULL << ReentParser::Clustered)
          | (1ULL << ReentParser::Common)
          | (1ULL << ReentParser::Decltype)
          | (1ULL << ReentParser::Depends)
          | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
          | (1ULL << (ReentParser::Gpu - 64))
          | (1ULL << (ReentParser::Id - 64))
          | (1ULL << (ReentParser::In - 64))
          | (1ULL << (ReentParser::Local - 64))
          | (1ULL << (ReentParser::MarkPreCondition - 64))
          | (1ULL << (ReentParser::MarkState - 64))
          | (1ULL << (ReentParser::Out - 64))
          | (1ULL << (ReentParser::Plan - 64))
          | (1ULL << (ReentParser::Reset - 64))
          | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
          | (1ULL << (ReentParser::Doublecolon - 146))
          | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
          setState(2573);
          classHeadName();
          setState(2575);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ReentParser::Final) {
            setState(2574);
            classVirtSpecifier();
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassHeadNameContext ------------------------------------------------------------------

ReentParser::ClassHeadNameContext::ClassHeadNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassNameContext* ReentParser::ClassHeadNameContext::className() {
  return getRuleContext<ReentParser::ClassNameContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::ClassHeadNameContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}


size_t ReentParser::ClassHeadNameContext::getRuleIndex() const {
  return ReentParser::RuleClassHeadName;
}

void ReentParser::ClassHeadNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassHeadName(this);
}

void ReentParser::ClassHeadNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassHeadName(this);
}

ReentParser::ClassHeadNameContext* ReentParser::classHeadName() {
  ClassHeadNameContext *_localctx = _tracker.createInstance<ClassHeadNameContext>(_ctx, getState());
  enterRule(_localctx, 456, ReentParser::RuleClassHeadName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2582);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
    case 1: {
      setState(2581);
      nestedNameSpecifier(0);
      break;
    }

    default:
      break;
    }
    setState(2584);
    className();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassVirtSpecifierContext ------------------------------------------------------------------

ReentParser::ClassVirtSpecifierContext::ClassVirtSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ClassVirtSpecifierContext::Final() {
  return getToken(ReentParser::Final, 0);
}


size_t ReentParser::ClassVirtSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleClassVirtSpecifier;
}

void ReentParser::ClassVirtSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassVirtSpecifier(this);
}

void ReentParser::ClassVirtSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassVirtSpecifier(this);
}

ReentParser::ClassVirtSpecifierContext* ReentParser::classVirtSpecifier() {
  ClassVirtSpecifierContext *_localctx = _tracker.createInstance<ClassVirtSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 458, ReentParser::RuleClassVirtSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2586);
    match(ReentParser::Final);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassKeyContext ------------------------------------------------------------------

ReentParser::ClassKeyContext::ClassKeyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ClassKeyContext::Class() {
  return getToken(ReentParser::Class, 0);
}

tree::TerminalNode* ReentParser::ClassKeyContext::Struct() {
  return getToken(ReentParser::Struct, 0);
}


size_t ReentParser::ClassKeyContext::getRuleIndex() const {
  return ReentParser::RuleClassKey;
}

void ReentParser::ClassKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassKey(this);
}

void ReentParser::ClassKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassKey(this);
}

ReentParser::ClassKeyContext* ReentParser::classKey() {
  ClassKeyContext *_localctx = _tracker.createInstance<ClassKeyContext>(_ctx, getState());
  enterRule(_localctx, 460, ReentParser::RuleClassKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2588);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Class || _la == ReentParser::Struct)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberSpecificationContext ------------------------------------------------------------------

ReentParser::MemberSpecificationContext::MemberSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::MarkedmemberdeclarationContext *> ReentParser::MemberSpecificationContext::markedmemberdeclaration() {
  return getRuleContexts<ReentParser::MarkedmemberdeclarationContext>();
}

ReentParser::MarkedmemberdeclarationContext* ReentParser::MemberSpecificationContext::markedmemberdeclaration(size_t i) {
  return getRuleContext<ReentParser::MarkedmemberdeclarationContext>(i);
}

std::vector<ReentParser::MemberdeclarationContext *> ReentParser::MemberSpecificationContext::memberdeclaration() {
  return getRuleContexts<ReentParser::MemberdeclarationContext>();
}

ReentParser::MemberdeclarationContext* ReentParser::MemberSpecificationContext::memberdeclaration(size_t i) {
  return getRuleContext<ReentParser::MemberdeclarationContext>(i);
}

std::vector<ReentParser::AccessSpecifierContext *> ReentParser::MemberSpecificationContext::accessSpecifier() {
  return getRuleContexts<ReentParser::AccessSpecifierContext>();
}

ReentParser::AccessSpecifierContext* ReentParser::MemberSpecificationContext::accessSpecifier(size_t i) {
  return getRuleContext<ReentParser::AccessSpecifierContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::MemberSpecificationContext::Colon() {
  return getTokens(ReentParser::Colon);
}

tree::TerminalNode* ReentParser::MemberSpecificationContext::Colon(size_t i) {
  return getToken(ReentParser::Colon, i);
}


size_t ReentParser::MemberSpecificationContext::getRuleIndex() const {
  return ReentParser::RuleMemberSpecification;
}

void ReentParser::MemberSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberSpecification(this);
}

void ReentParser::MemberSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberSpecification(this);
}

ReentParser::MemberSpecificationContext* ReentParser::memberSpecification() {
  MemberSpecificationContext *_localctx = _tracker.createInstance<MemberSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 462, ReentParser::RuleMemberSpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2595); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2595);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
      case 1: {
        setState(2590);
        markedmemberdeclaration();
        break;
      }

      case 2: {
        setState(2591);
        memberdeclaration();
        break;
      }

      case 3: {
        setState(2592);
        accessSpecifier();
        setState(2593);
        match(ReentParser::Colon);
        break;
      }

      default:
        break;
      }
      setState(2597); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 15) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 15)) & ((1ULL << (ReentParser::Alignas - 15))
      | (1ULL << (ReentParser::Auto - 15))
      | (1ULL << (ReentParser::Begin - 15))
      | (1ULL << (ReentParser::Bool - 15))
      | (1ULL << (ReentParser::Cfunnel - 15))
      | (1ULL << (ReentParser::Char - 15))
      | (1ULL << (ReentParser::Char16 - 15))
      | (1ULL << (ReentParser::Char32 - 15))
      | (1ULL << (ReentParser::Class - 15))
      | (1ULL << (ReentParser::Clustered - 15))
      | (1ULL << (ReentParser::Common - 15))
      | (1ULL << (ReentParser::Const - 15))
      | (1ULL << (ReentParser::Constexpr - 15))
      | (1ULL << (ReentParser::Csem - 15))
      | (1ULL << (ReentParser::Cvar - 15))
      | (1ULL << (ReentParser::Decltype - 15))
      | (1ULL << (ReentParser::Depends - 15))
      | (1ULL << (ReentParser::Double - 15))
      | (1ULL << (ReentParser::End - 15))
      | (1ULL << (ReentParser::Enum - 15))
      | (1ULL << (ReentParser::Explicit - 15))
      | (1ULL << (ReentParser::Extern - 15))
      | (1ULL << (ReentParser::Float - 15))
      | (1ULL << (ReentParser::Friend - 15))
      | (1ULL << (ReentParser::Funnel - 15))
      | (1ULL << (ReentParser::Global - 15))
      | (1ULL << (ReentParser::Gpu - 15))
      | (1ULL << (ReentParser::Id - 15))
      | (1ULL << (ReentParser::In - 15))
      | (1ULL << (ReentParser::Inline - 15))
      | (1ULL << (ReentParser::Int - 15))
      | (1ULL << (ReentParser::Local - 15))
      | (1ULL << (ReentParser::Long - 15))
      | (1ULL << (ReentParser::MarkPreCondition - 15))
      | (1ULL << (ReentParser::MarkState - 15))
      | (1ULL << (ReentParser::Markupdef - 15)))) != 0) || ((((_la - 79) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 79)) & ((1ULL << (ReentParser::Mutable - 79))
      | (1ULL << (ReentParser::Operator - 79))
      | (1ULL << (ReentParser::Out - 79))
      | (1ULL << (ReentParser::Plan - 79))
      | (1ULL << (ReentParser::Plan_item_type - 79))
      | (1ULL << (ReentParser::Plan_type - 79))
      | (1ULL << (ReentParser::Private - 79))
      | (1ULL << (ReentParser::Protected - 79))
      | (1ULL << (ReentParser::Public - 79))
      | (1ULL << (ReentParser::Register - 79))
      | (1ULL << (ReentParser::Reset - 79))
      | (1ULL << (ReentParser::Set - 79))
      | (1ULL << (ReentParser::Short - 79))
      | (1ULL << (ReentParser::Signed - 79))
      | (1ULL << (ReentParser::Soft_transact_array - 79))
      | (1ULL << (ReentParser::Soft_transact_in - 79))
      | (1ULL << (ReentParser::Soft_transact_out - 79))
      | (1ULL << (ReentParser::Soft_transact_var - 79))
      | (1ULL << (ReentParser::Static - 79))
      | (1ULL << (ReentParser::Static_assert - 79))
      | (1ULL << (ReentParser::Struct - 79))
      | (1ULL << (ReentParser::Template - 79))
      | (1ULL << (ReentParser::Thread_local - 79))
      | (1ULL << (ReentParser::Typedef - 79))
      | (1ULL << (ReentParser::Typename_ - 79)))) != 0) || ((((_la - 143) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 143)) & ((1ULL << (ReentParser::Union - 143))
      | (1ULL << (ReentParser::Unsigned - 143))
      | (1ULL << (ReentParser::Using - 143))
      | (1ULL << (ReentParser::Vectorized - 143))
      | (1ULL << (ReentParser::Virtual - 143))
      | (1ULL << (ReentParser::Void - 143))
      | (1ULL << (ReentParser::Volatile - 143))
      | (1ULL << (ReentParser::Wchar - 143))
      | (1ULL << (ReentParser::LeftParen - 143))
      | (1ULL << (ReentParser::LeftBracket - 143))
      | (1ULL << (ReentParser::Star - 143))
      | (1ULL << (ReentParser::And - 143))
      | (1ULL << (ReentParser::Tilde - 143))
      | (1ULL << (ReentParser::AndAnd - 143))
      | (1ULL << (ReentParser::Colon - 143))
      | (1ULL << (ReentParser::Doublecolon - 143))
      | (1ULL << (ReentParser::Semi - 143))
      | (1ULL << (ReentParser::Ellipsis - 143))
      | (1ULL << (ReentParser::Identifier - 143)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MarkedmemberdeclarationContext ------------------------------------------------------------------

ReentParser::MarkedmemberdeclarationContext::MarkedmemberdeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclaratorContext* ReentParser::MarkedmemberdeclarationContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

tree::TerminalNode* ReentParser::MarkedmemberdeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

tree::TerminalNode* ReentParser::MarkedmemberdeclarationContext::MarkPreCondition() {
  return getToken(ReentParser::MarkPreCondition, 0);
}

tree::TerminalNode* ReentParser::MarkedmemberdeclarationContext::MarkState() {
  return getToken(ReentParser::MarkState, 0);
}

tree::TerminalNode* ReentParser::MarkedmemberdeclarationContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

std::vector<ReentParser::PrimaryExpressionContext *> ReentParser::MarkedmemberdeclarationContext::primaryExpression() {
  return getRuleContexts<ReentParser::PrimaryExpressionContext>();
}

ReentParser::PrimaryExpressionContext* ReentParser::MarkedmemberdeclarationContext::primaryExpression(size_t i) {
  return getRuleContext<ReentParser::PrimaryExpressionContext>(i);
}

tree::TerminalNode* ReentParser::MarkedmemberdeclarationContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

tree::TerminalNode* ReentParser::MarkedmemberdeclarationContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::MarkedmemberdeclarationContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}


size_t ReentParser::MarkedmemberdeclarationContext::getRuleIndex() const {
  return ReentParser::RuleMarkedmemberdeclaration;
}

void ReentParser::MarkedmemberdeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMarkedmemberdeclaration(this);
}

void ReentParser::MarkedmemberdeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMarkedmemberdeclaration(this);
}

ReentParser::MarkedmemberdeclarationContext* ReentParser::markedmemberdeclaration() {
  MarkedmemberdeclarationContext *_localctx = _tracker.createInstance<MarkedmemberdeclarationContext>(_ctx, getState());
  enterRule(_localctx, 464, ReentParser::RuleMarkedmemberdeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2607);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::MarkPreCondition: {
        setState(2599);
        match(ReentParser::MarkPreCondition);
        break;
      }

      case ReentParser::MarkState: {
        setState(2600);
        match(ReentParser::MarkState);
        setState(2601);
        match(ReentParser::LeftParen);
        setState(2602);
        primaryExpression();
        setState(2603);
        match(ReentParser::Comma);
        setState(2604);
        primaryExpression();
        setState(2605);
        match(ReentParser::RightParen);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2610);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(2609);
      declSpecifierSeq();
      break;
    }

    default:
      break;
    }
    setState(2612);
    declarator();
    setState(2613);
    match(ReentParser::Semi);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberdeclarationContext ------------------------------------------------------------------

ReentParser::MemberdeclarationContext::MemberdeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::MemberdeclarationContext::Semi() {
  return getToken(ReentParser::Semi, 0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::MemberdeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::DeclSpecifierSeqContext* ReentParser::MemberdeclarationContext::declSpecifierSeq() {
  return getRuleContext<ReentParser::DeclSpecifierSeqContext>(0);
}

ReentParser::MemberDeclaratorListContext* ReentParser::MemberdeclarationContext::memberDeclaratorList() {
  return getRuleContext<ReentParser::MemberDeclaratorListContext>(0);
}

ReentParser::FunctionDefinitionContext* ReentParser::MemberdeclarationContext::functionDefinition() {
  return getRuleContext<ReentParser::FunctionDefinitionContext>(0);
}

ReentParser::UsingDeclarationContext* ReentParser::MemberdeclarationContext::usingDeclaration() {
  return getRuleContext<ReentParser::UsingDeclarationContext>(0);
}

ReentParser::StaticAssertDeclarationContext* ReentParser::MemberdeclarationContext::staticAssertDeclaration() {
  return getRuleContext<ReentParser::StaticAssertDeclarationContext>(0);
}

ReentParser::TemplateDeclarationContext* ReentParser::MemberdeclarationContext::templateDeclaration() {
  return getRuleContext<ReentParser::TemplateDeclarationContext>(0);
}

ReentParser::AliasDeclarationContext* ReentParser::MemberdeclarationContext::aliasDeclaration() {
  return getRuleContext<ReentParser::AliasDeclarationContext>(0);
}

ReentParser::EmptyDeclarationContext* ReentParser::MemberdeclarationContext::emptyDeclaration() {
  return getRuleContext<ReentParser::EmptyDeclarationContext>(0);
}


size_t ReentParser::MemberdeclarationContext::getRuleIndex() const {
  return ReentParser::RuleMemberdeclaration;
}

void ReentParser::MemberdeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberdeclaration(this);
}

void ReentParser::MemberdeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberdeclaration(this);
}

ReentParser::MemberdeclarationContext* ReentParser::memberdeclaration() {
  MemberdeclarationContext *_localctx = _tracker.createInstance<MemberdeclarationContext>(_ctx, getState());
  enterRule(_localctx, 466, ReentParser::RuleMemberdeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2631);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2616);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
      case 1: {
        setState(2615);
        attributeSpecifierSeq();
        break;
      }

      default:
        break;
      }
      setState(2619);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
      case 1: {
        setState(2618);
        declSpecifierSeq();
        break;
      }

      default:
        break;
      }
      setState(2622);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << ReentParser::Alignas)
        | (1ULL << ReentParser::Begin)
        | (1ULL << ReentParser::Clustered)
        | (1ULL << ReentParser::Common)
        | (1ULL << ReentParser::Decltype)
        | (1ULL << ReentParser::Depends)
        | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
        | (1ULL << (ReentParser::Gpu - 64))
        | (1ULL << (ReentParser::Id - 64))
        | (1ULL << (ReentParser::In - 64))
        | (1ULL << (ReentParser::Local - 64))
        | (1ULL << (ReentParser::MarkPreCondition - 64))
        | (1ULL << (ReentParser::MarkState - 64))
        | (1ULL << (ReentParser::Operator - 64))
        | (1ULL << (ReentParser::Out - 64))
        | (1ULL << (ReentParser::Plan - 64))
        | (1ULL << (ReentParser::Reset - 64))
        | (1ULL << (ReentParser::Set - 64)))) != 0) || ((((_la - 146) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 146)) & ((1ULL << (ReentParser::Vectorized - 146))
        | (1ULL << (ReentParser::LeftParen - 146))
        | (1ULL << (ReentParser::LeftBracket - 146))
        | (1ULL << (ReentParser::Star - 146))
        | (1ULL << (ReentParser::And - 146))
        | (1ULL << (ReentParser::Tilde - 146))
        | (1ULL << (ReentParser::AndAnd - 146))
        | (1ULL << (ReentParser::Colon - 146))
        | (1ULL << (ReentParser::Doublecolon - 146))
        | (1ULL << (ReentParser::Ellipsis - 146))
        | (1ULL << (ReentParser::Identifier - 146)))) != 0)) {
        setState(2621);
        memberDeclaratorList();
      }
      setState(2624);
      match(ReentParser::Semi);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2625);
      functionDefinition();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2626);
      usingDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2627);
      staticAssertDeclaration();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2628);
      templateDeclaration();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2629);
      aliasDeclaration();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2630);
      emptyDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberDeclaratorListContext ------------------------------------------------------------------

ReentParser::MemberDeclaratorListContext::MemberDeclaratorListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::MemberDeclaratorContext *> ReentParser::MemberDeclaratorListContext::memberDeclarator() {
  return getRuleContexts<ReentParser::MemberDeclaratorContext>();
}

ReentParser::MemberDeclaratorContext* ReentParser::MemberDeclaratorListContext::memberDeclarator(size_t i) {
  return getRuleContext<ReentParser::MemberDeclaratorContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::MemberDeclaratorListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::MemberDeclaratorListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::MemberDeclaratorListContext::getRuleIndex() const {
  return ReentParser::RuleMemberDeclaratorList;
}

void ReentParser::MemberDeclaratorListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberDeclaratorList(this);
}

void ReentParser::MemberDeclaratorListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberDeclaratorList(this);
}

ReentParser::MemberDeclaratorListContext* ReentParser::memberDeclaratorList() {
  MemberDeclaratorListContext *_localctx = _tracker.createInstance<MemberDeclaratorListContext>(_ctx, getState());
  enterRule(_localctx, 468, ReentParser::RuleMemberDeclaratorList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2633);
    memberDeclarator();
    setState(2638);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2634);
      match(ReentParser::Comma);
      setState(2635);
      memberDeclarator();
      setState(2640);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemberDeclaratorContext ------------------------------------------------------------------

ReentParser::MemberDeclaratorContext::MemberDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DeclaratorContext* ReentParser::MemberDeclaratorContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

ReentParser::VirtualSpecifierSeqContext* ReentParser::MemberDeclaratorContext::virtualSpecifierSeq() {
  return getRuleContext<ReentParser::VirtualSpecifierSeqContext>(0);
}

ReentParser::PureSpecifierContext* ReentParser::MemberDeclaratorContext::pureSpecifier() {
  return getRuleContext<ReentParser::PureSpecifierContext>(0);
}

ReentParser::BraceOrEqualInitializerContext* ReentParser::MemberDeclaratorContext::braceOrEqualInitializer() {
  return getRuleContext<ReentParser::BraceOrEqualInitializerContext>(0);
}

tree::TerminalNode* ReentParser::MemberDeclaratorContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::MemberDeclaratorContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::MemberDeclaratorContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::MemberDeclaratorContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::MemberDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleMemberDeclarator;
}

void ReentParser::MemberDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemberDeclarator(this);
}

void ReentParser::MemberDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemberDeclarator(this);
}

ReentParser::MemberDeclaratorContext* ReentParser::memberDeclarator() {
  MemberDeclaratorContext *_localctx = _tracker.createInstance<MemberDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 470, ReentParser::RuleMemberDeclarator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2660);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2641);
      declarator();
      setState(2650);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case ReentParser::Final:
        case ReentParser::Override: {
          setState(2642);
          virtualSpecifierSeq();
          setState(2644);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == ReentParser::Assign) {
            setState(2643);
            pureSpecifier();
          }
          break;
        }

        case ReentParser::LeftBrace:
        case ReentParser::Assign:
        case ReentParser::Comma:
        case ReentParser::Semi: {
          setState(2648);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
          case 1: {
            setState(2646);
            pureSpecifier();
            break;
          }

          case 2: {
            setState(2647);
            braceOrEqualInitializer();
            break;
          }

          default:
            break;
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2653);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << ReentParser::Begin)
        | (1ULL << ReentParser::Clustered)
        | (1ULL << ReentParser::Common)
        | (1ULL << ReentParser::Depends)
        | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
        | (1ULL << (ReentParser::Gpu - 64))
        | (1ULL << (ReentParser::Id - 64))
        | (1ULL << (ReentParser::In - 64))
        | (1ULL << (ReentParser::Local - 64))
        | (1ULL << (ReentParser::MarkPreCondition - 64))
        | (1ULL << (ReentParser::MarkState - 64))
        | (1ULL << (ReentParser::Out - 64))
        | (1ULL << (ReentParser::Plan - 64))
        | (1ULL << (ReentParser::Reset - 64))
        | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

      || _la == ReentParser::Identifier) {
        setState(2652);
        anyIdentifier();
      }
      setState(2656);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
        setState(2655);
        attributeSpecifierSeq();
      }
      setState(2658);
      match(ReentParser::Colon);
      setState(2659);
      constantExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VirtualSpecifierSeqContext ------------------------------------------------------------------

ReentParser::VirtualSpecifierSeqContext::VirtualSpecifierSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::VirtualSpecifierContext *> ReentParser::VirtualSpecifierSeqContext::virtualSpecifier() {
  return getRuleContexts<ReentParser::VirtualSpecifierContext>();
}

ReentParser::VirtualSpecifierContext* ReentParser::VirtualSpecifierSeqContext::virtualSpecifier(size_t i) {
  return getRuleContext<ReentParser::VirtualSpecifierContext>(i);
}


size_t ReentParser::VirtualSpecifierSeqContext::getRuleIndex() const {
  return ReentParser::RuleVirtualSpecifierSeq;
}

void ReentParser::VirtualSpecifierSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVirtualSpecifierSeq(this);
}

void ReentParser::VirtualSpecifierSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVirtualSpecifierSeq(this);
}

ReentParser::VirtualSpecifierSeqContext* ReentParser::virtualSpecifierSeq() {
  VirtualSpecifierSeqContext *_localctx = _tracker.createInstance<VirtualSpecifierSeqContext>(_ctx, getState());
  enterRule(_localctx, 472, ReentParser::RuleVirtualSpecifierSeq);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2663); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2662);
      virtualSpecifier();
      setState(2665); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == ReentParser::Final

    || _la == ReentParser::Override);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VirtualSpecifierContext ------------------------------------------------------------------

ReentParser::VirtualSpecifierContext::VirtualSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::VirtualSpecifierContext::Override() {
  return getToken(ReentParser::Override, 0);
}

tree::TerminalNode* ReentParser::VirtualSpecifierContext::Final() {
  return getToken(ReentParser::Final, 0);
}


size_t ReentParser::VirtualSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleVirtualSpecifier;
}

void ReentParser::VirtualSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVirtualSpecifier(this);
}

void ReentParser::VirtualSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVirtualSpecifier(this);
}

ReentParser::VirtualSpecifierContext* ReentParser::virtualSpecifier() {
  VirtualSpecifierContext *_localctx = _tracker.createInstance<VirtualSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 474, ReentParser::RuleVirtualSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2667);
    _la = _input->LA(1);
    if (!(_la == ReentParser::Final

    || _la == ReentParser::Override)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PureSpecifierContext ------------------------------------------------------------------

ReentParser::PureSpecifierContext::PureSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::PureSpecifierContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

tree::TerminalNode* ReentParser::PureSpecifierContext::OctalLiteral() {
  return getToken(ReentParser::OctalLiteral, 0);
}


size_t ReentParser::PureSpecifierContext::getRuleIndex() const {
  return ReentParser::RulePureSpecifier;
}

void ReentParser::PureSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPureSpecifier(this);
}

void ReentParser::PureSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPureSpecifier(this);
}

ReentParser::PureSpecifierContext* ReentParser::pureSpecifier() {
  PureSpecifierContext *_localctx = _tracker.createInstance<PureSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 476, ReentParser::RulePureSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2669);
    match(ReentParser::Assign);
    setState(2670);
    dynamic_cast<PureSpecifierContext *>(_localctx)->val = match(ReentParser::OctalLiteral);
    if((dynamic_cast<PureSpecifierContext *>(_localctx)->val != nullptr ? dynamic_cast<PureSpecifierContext *>(_localctx)->val->getText() : "").compare("0")!=0) throw InputMismatchException(this);
    		
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseClauseContext ------------------------------------------------------------------

ReentParser::BaseClauseContext::BaseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::BaseClauseContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::BaseSpecifierListContext* ReentParser::BaseClauseContext::baseSpecifierList() {
  return getRuleContext<ReentParser::BaseSpecifierListContext>(0);
}


size_t ReentParser::BaseClauseContext::getRuleIndex() const {
  return ReentParser::RuleBaseClause;
}

void ReentParser::BaseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseClause(this);
}

void ReentParser::BaseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseClause(this);
}

ReentParser::BaseClauseContext* ReentParser::baseClause() {
  BaseClauseContext *_localctx = _tracker.createInstance<BaseClauseContext>(_ctx, getState());
  enterRule(_localctx, 478, ReentParser::RuleBaseClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2673);
    match(ReentParser::Colon);
    setState(2674);
    baseSpecifierList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseSpecifierListContext ------------------------------------------------------------------

ReentParser::BaseSpecifierListContext::BaseSpecifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::BaseSpecifierContext *> ReentParser::BaseSpecifierListContext::baseSpecifier() {
  return getRuleContexts<ReentParser::BaseSpecifierContext>();
}

ReentParser::BaseSpecifierContext* ReentParser::BaseSpecifierListContext::baseSpecifier(size_t i) {
  return getRuleContext<ReentParser::BaseSpecifierContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::BaseSpecifierListContext::Ellipsis() {
  return getTokens(ReentParser::Ellipsis);
}

tree::TerminalNode* ReentParser::BaseSpecifierListContext::Ellipsis(size_t i) {
  return getToken(ReentParser::Ellipsis, i);
}

std::vector<tree::TerminalNode *> ReentParser::BaseSpecifierListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::BaseSpecifierListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::BaseSpecifierListContext::getRuleIndex() const {
  return ReentParser::RuleBaseSpecifierList;
}

void ReentParser::BaseSpecifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseSpecifierList(this);
}

void ReentParser::BaseSpecifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseSpecifierList(this);
}

ReentParser::BaseSpecifierListContext* ReentParser::baseSpecifierList() {
  BaseSpecifierListContext *_localctx = _tracker.createInstance<BaseSpecifierListContext>(_ctx, getState());
  enterRule(_localctx, 480, ReentParser::RuleBaseSpecifierList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2676);
    baseSpecifier();
    setState(2678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(2677);
      match(ReentParser::Ellipsis);
    }
    setState(2687);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2680);
      match(ReentParser::Comma);
      setState(2681);
      baseSpecifier();
      setState(2683);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Ellipsis) {
        setState(2682);
        match(ReentParser::Ellipsis);
      }
      setState(2689);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseSpecifierContext ------------------------------------------------------------------

ReentParser::BaseSpecifierContext::BaseSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::BaseTypeSpecifierContext* ReentParser::BaseSpecifierContext::baseTypeSpecifier() {
  return getRuleContext<ReentParser::BaseTypeSpecifierContext>(0);
}

tree::TerminalNode* ReentParser::BaseSpecifierContext::Virtual() {
  return getToken(ReentParser::Virtual, 0);
}

ReentParser::AccessSpecifierContext* ReentParser::BaseSpecifierContext::accessSpecifier() {
  return getRuleContext<ReentParser::AccessSpecifierContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::BaseSpecifierContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}


size_t ReentParser::BaseSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleBaseSpecifier;
}

void ReentParser::BaseSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseSpecifier(this);
}

void ReentParser::BaseSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseSpecifier(this);
}

ReentParser::BaseSpecifierContext* ReentParser::baseSpecifier() {
  BaseSpecifierContext *_localctx = _tracker.createInstance<BaseSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 482, ReentParser::RuleBaseSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2691);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
      setState(2690);
      attributeSpecifierSeq();
    }
    setState(2705);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        setState(2693);
        baseTypeSpecifier();
        break;
      }

      case ReentParser::Virtual: {
        setState(2694);
        match(ReentParser::Virtual);
        setState(2696);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 109) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 109)) & ((1ULL << (ReentParser::Private - 109))
          | (1ULL << (ReentParser::Protected - 109))
          | (1ULL << (ReentParser::Public - 109)))) != 0)) {
          setState(2695);
          accessSpecifier();
        }
        setState(2698);
        baseTypeSpecifier();
        break;
      }

      case ReentParser::Private:
      case ReentParser::Protected:
      case ReentParser::Public: {
        setState(2699);
        accessSpecifier();
        setState(2701);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Virtual) {
          setState(2700);
          match(ReentParser::Virtual);
        }
        setState(2703);
        baseTypeSpecifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassOrDeclTypeContext ------------------------------------------------------------------

ReentParser::ClassOrDeclTypeContext::ClassOrDeclTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassNameContext* ReentParser::ClassOrDeclTypeContext::className() {
  return getRuleContext<ReentParser::ClassNameContext>(0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::ClassOrDeclTypeContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

ReentParser::DecltypeSpecifierContext* ReentParser::ClassOrDeclTypeContext::decltypeSpecifier() {
  return getRuleContext<ReentParser::DecltypeSpecifierContext>(0);
}


size_t ReentParser::ClassOrDeclTypeContext::getRuleIndex() const {
  return ReentParser::RuleClassOrDeclType;
}

void ReentParser::ClassOrDeclTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClassOrDeclType(this);
}

void ReentParser::ClassOrDeclTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClassOrDeclType(this);
}

ReentParser::ClassOrDeclTypeContext* ReentParser::classOrDeclType() {
  ClassOrDeclTypeContext *_localctx = _tracker.createInstance<ClassOrDeclTypeContext>(_ctx, getState());
  enterRule(_localctx, 484, ReentParser::RuleClassOrDeclType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2712);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2708);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
      case 1: {
        setState(2707);
        nestedNameSpecifier(0);
        break;
      }

      default:
        break;
      }
      setState(2710);
      className();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2711);
      decltypeSpecifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BaseTypeSpecifierContext ------------------------------------------------------------------

ReentParser::BaseTypeSpecifierContext::BaseTypeSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassOrDeclTypeContext* ReentParser::BaseTypeSpecifierContext::classOrDeclType() {
  return getRuleContext<ReentParser::ClassOrDeclTypeContext>(0);
}


size_t ReentParser::BaseTypeSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleBaseTypeSpecifier;
}

void ReentParser::BaseTypeSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBaseTypeSpecifier(this);
}

void ReentParser::BaseTypeSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBaseTypeSpecifier(this);
}

ReentParser::BaseTypeSpecifierContext* ReentParser::baseTypeSpecifier() {
  BaseTypeSpecifierContext *_localctx = _tracker.createInstance<BaseTypeSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 486, ReentParser::RuleBaseTypeSpecifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2714);
    classOrDeclType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessSpecifierContext ------------------------------------------------------------------

ReentParser::AccessSpecifierContext::AccessSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::AccessSpecifierContext::Private() {
  return getToken(ReentParser::Private, 0);
}

tree::TerminalNode* ReentParser::AccessSpecifierContext::Protected() {
  return getToken(ReentParser::Protected, 0);
}

tree::TerminalNode* ReentParser::AccessSpecifierContext::Public() {
  return getToken(ReentParser::Public, 0);
}


size_t ReentParser::AccessSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleAccessSpecifier;
}

void ReentParser::AccessSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessSpecifier(this);
}

void ReentParser::AccessSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessSpecifier(this);
}

ReentParser::AccessSpecifierContext* ReentParser::accessSpecifier() {
  AccessSpecifierContext *_localctx = _tracker.createInstance<AccessSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 488, ReentParser::RuleAccessSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2716);
    _la = _input->LA(1);
    if (!(((((_la - 109) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 109)) & ((1ULL << (ReentParser::Private - 109))
      | (1ULL << (ReentParser::Protected - 109))
      | (1ULL << (ReentParser::Public - 109)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConversionFunctionIdContext ------------------------------------------------------------------

ReentParser::ConversionFunctionIdContext::ConversionFunctionIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ConversionFunctionIdContext::Operator() {
  return getToken(ReentParser::Operator, 0);
}

ReentParser::ConversionTypeIdContext* ReentParser::ConversionFunctionIdContext::conversionTypeId() {
  return getRuleContext<ReentParser::ConversionTypeIdContext>(0);
}


size_t ReentParser::ConversionFunctionIdContext::getRuleIndex() const {
  return ReentParser::RuleConversionFunctionId;
}

void ReentParser::ConversionFunctionIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConversionFunctionId(this);
}

void ReentParser::ConversionFunctionIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConversionFunctionId(this);
}

ReentParser::ConversionFunctionIdContext* ReentParser::conversionFunctionId() {
  ConversionFunctionIdContext *_localctx = _tracker.createInstance<ConversionFunctionIdContext>(_ctx, getState());
  enterRule(_localctx, 490, ReentParser::RuleConversionFunctionId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2718);
    match(ReentParser::Operator);
    setState(2719);
    conversionTypeId();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConversionTypeIdContext ------------------------------------------------------------------

ReentParser::ConversionTypeIdContext::ConversionTypeIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TypeSpecifierSeqContext* ReentParser::ConversionTypeIdContext::typeSpecifierSeq() {
  return getRuleContext<ReentParser::TypeSpecifierSeqContext>(0);
}

ReentParser::ConversionDeclaratorContext* ReentParser::ConversionTypeIdContext::conversionDeclarator() {
  return getRuleContext<ReentParser::ConversionDeclaratorContext>(0);
}


size_t ReentParser::ConversionTypeIdContext::getRuleIndex() const {
  return ReentParser::RuleConversionTypeId;
}

void ReentParser::ConversionTypeIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConversionTypeId(this);
}

void ReentParser::ConversionTypeIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConversionTypeId(this);
}

ReentParser::ConversionTypeIdContext* ReentParser::conversionTypeId() {
  ConversionTypeIdContext *_localctx = _tracker.createInstance<ConversionTypeIdContext>(_ctx, getState());
  enterRule(_localctx, 492, ReentParser::RuleConversionTypeId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2721);
    typeSpecifierSeq();
    setState(2723);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 321, _ctx)) {
    case 1: {
      setState(2722);
      conversionDeclarator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConversionDeclaratorContext ------------------------------------------------------------------

ReentParser::ConversionDeclaratorContext::ConversionDeclaratorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::PointerOperatorContext* ReentParser::ConversionDeclaratorContext::pointerOperator() {
  return getRuleContext<ReentParser::PointerOperatorContext>(0);
}

ReentParser::ConversionDeclaratorContext* ReentParser::ConversionDeclaratorContext::conversionDeclarator() {
  return getRuleContext<ReentParser::ConversionDeclaratorContext>(0);
}


size_t ReentParser::ConversionDeclaratorContext::getRuleIndex() const {
  return ReentParser::RuleConversionDeclarator;
}

void ReentParser::ConversionDeclaratorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConversionDeclarator(this);
}

void ReentParser::ConversionDeclaratorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConversionDeclarator(this);
}

ReentParser::ConversionDeclaratorContext* ReentParser::conversionDeclarator() {
  ConversionDeclaratorContext *_localctx = _tracker.createInstance<ConversionDeclaratorContext>(_ctx, getState());
  enterRule(_localctx, 494, ReentParser::RuleConversionDeclarator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2725);
    pointerOperator();
    setState(2727);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
    case 1: {
      setState(2726);
      conversionDeclarator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstructorInitializerContext ------------------------------------------------------------------

ReentParser::ConstructorInitializerContext::ConstructorInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ConstructorInitializerContext::Colon() {
  return getToken(ReentParser::Colon, 0);
}

ReentParser::MemInitializerListContext* ReentParser::ConstructorInitializerContext::memInitializerList() {
  return getRuleContext<ReentParser::MemInitializerListContext>(0);
}


size_t ReentParser::ConstructorInitializerContext::getRuleIndex() const {
  return ReentParser::RuleConstructorInitializer;
}

void ReentParser::ConstructorInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstructorInitializer(this);
}

void ReentParser::ConstructorInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstructorInitializer(this);
}

ReentParser::ConstructorInitializerContext* ReentParser::constructorInitializer() {
  ConstructorInitializerContext *_localctx = _tracker.createInstance<ConstructorInitializerContext>(_ctx, getState());
  enterRule(_localctx, 496, ReentParser::RuleConstructorInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2729);
    match(ReentParser::Colon);
    setState(2730);
    memInitializerList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemInitializerListContext ------------------------------------------------------------------

ReentParser::MemInitializerListContext::MemInitializerListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::MemInitializerContext *> ReentParser::MemInitializerListContext::memInitializer() {
  return getRuleContexts<ReentParser::MemInitializerContext>();
}

ReentParser::MemInitializerContext* ReentParser::MemInitializerListContext::memInitializer(size_t i) {
  return getRuleContext<ReentParser::MemInitializerContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::MemInitializerListContext::Ellipsis() {
  return getTokens(ReentParser::Ellipsis);
}

tree::TerminalNode* ReentParser::MemInitializerListContext::Ellipsis(size_t i) {
  return getToken(ReentParser::Ellipsis, i);
}

std::vector<tree::TerminalNode *> ReentParser::MemInitializerListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::MemInitializerListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::MemInitializerListContext::getRuleIndex() const {
  return ReentParser::RuleMemInitializerList;
}

void ReentParser::MemInitializerListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemInitializerList(this);
}

void ReentParser::MemInitializerListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemInitializerList(this);
}

ReentParser::MemInitializerListContext* ReentParser::memInitializerList() {
  MemInitializerListContext *_localctx = _tracker.createInstance<MemInitializerListContext>(_ctx, getState());
  enterRule(_localctx, 498, ReentParser::RuleMemInitializerList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2732);
    memInitializer();
    setState(2734);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(2733);
      match(ReentParser::Ellipsis);
    }
    setState(2743);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2736);
      match(ReentParser::Comma);
      setState(2737);
      memInitializer();
      setState(2739);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Ellipsis) {
        setState(2738);
        match(ReentParser::Ellipsis);
      }
      setState(2745);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MemInitializerContext ------------------------------------------------------------------

ReentParser::MemInitializerContext::MemInitializerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::MeminitializeridContext* ReentParser::MemInitializerContext::meminitializerid() {
  return getRuleContext<ReentParser::MeminitializeridContext>(0);
}

tree::TerminalNode* ReentParser::MemInitializerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::MemInitializerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::BracedInitListContext* ReentParser::MemInitializerContext::bracedInitList() {
  return getRuleContext<ReentParser::BracedInitListContext>(0);
}

ReentParser::ExpressionListContext* ReentParser::MemInitializerContext::expressionList() {
  return getRuleContext<ReentParser::ExpressionListContext>(0);
}


size_t ReentParser::MemInitializerContext::getRuleIndex() const {
  return ReentParser::RuleMemInitializer;
}

void ReentParser::MemInitializerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMemInitializer(this);
}

void ReentParser::MemInitializerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMemInitializer(this);
}

ReentParser::MemInitializerContext* ReentParser::memInitializer() {
  MemInitializerContext *_localctx = _tracker.createInstance<MemInitializerContext>(_ctx, getState());
  enterRule(_localctx, 500, ReentParser::RuleMemInitializer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2746);
    meminitializerid();
    setState(2753);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::LeftParen: {
        setState(2747);
        match(ReentParser::LeftParen);
        setState(2749);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx)) {
        case 1: {
          setState(2748);
          expressionList();
          break;
        }

        default:
          break;
        }
        setState(2751);
        match(ReentParser::RightParen);
        break;
      }

      case ReentParser::LeftBrace: {
        setState(2752);
        bracedInitList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MeminitializeridContext ------------------------------------------------------------------

ReentParser::MeminitializeridContext::MeminitializeridContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::ClassOrDeclTypeContext* ReentParser::MeminitializeridContext::classOrDeclType() {
  return getRuleContext<ReentParser::ClassOrDeclTypeContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::MeminitializeridContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::MeminitializeridContext::getRuleIndex() const {
  return ReentParser::RuleMeminitializerid;
}

void ReentParser::MeminitializeridContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMeminitializerid(this);
}

void ReentParser::MeminitializeridContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMeminitializerid(this);
}

ReentParser::MeminitializeridContext* ReentParser::meminitializerid() {
  MeminitializeridContext *_localctx = _tracker.createInstance<MeminitializeridContext>(_ctx, getState());
  enterRule(_localctx, 502, ReentParser::RuleMeminitializerid);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2757);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 328, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2755);
      classOrDeclType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2756);
      anyIdentifier();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OperatorFunctionIdContext ------------------------------------------------------------------

ReentParser::OperatorFunctionIdContext::OperatorFunctionIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::OperatorFunctionIdContext::Operator() {
  return getToken(ReentParser::Operator, 0);
}

ReentParser::TheOperatorContext* ReentParser::OperatorFunctionIdContext::theOperator() {
  return getRuleContext<ReentParser::TheOperatorContext>(0);
}


size_t ReentParser::OperatorFunctionIdContext::getRuleIndex() const {
  return ReentParser::RuleOperatorFunctionId;
}

void ReentParser::OperatorFunctionIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperatorFunctionId(this);
}

void ReentParser::OperatorFunctionIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperatorFunctionId(this);
}

ReentParser::OperatorFunctionIdContext* ReentParser::operatorFunctionId() {
  OperatorFunctionIdContext *_localctx = _tracker.createInstance<OperatorFunctionIdContext>(_ctx, getState());
  enterRule(_localctx, 504, ReentParser::RuleOperatorFunctionId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2759);
    match(ReentParser::Operator);
    setState(2760);
    theOperator();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralOperatorIdContext ------------------------------------------------------------------

ReentParser::LiteralOperatorIdContext::LiteralOperatorIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::LiteralOperatorIdContext::Operator() {
  return getToken(ReentParser::Operator, 0);
}

tree::TerminalNode* ReentParser::LiteralOperatorIdContext::StringLiteral() {
  return getToken(ReentParser::StringLiteral, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::LiteralOperatorIdContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

tree::TerminalNode* ReentParser::LiteralOperatorIdContext::UserDefinedStringLiteral() {
  return getToken(ReentParser::UserDefinedStringLiteral, 0);
}


size_t ReentParser::LiteralOperatorIdContext::getRuleIndex() const {
  return ReentParser::RuleLiteralOperatorId;
}

void ReentParser::LiteralOperatorIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralOperatorId(this);
}

void ReentParser::LiteralOperatorIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralOperatorId(this);
}

ReentParser::LiteralOperatorIdContext* ReentParser::literalOperatorId() {
  LiteralOperatorIdContext *_localctx = _tracker.createInstance<LiteralOperatorIdContext>(_ctx, getState());
  enterRule(_localctx, 506, ReentParser::RuleLiteralOperatorId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2762);
    match(ReentParser::Operator);
    setState(2766);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::StringLiteral: {
        setState(2763);
        match(ReentParser::StringLiteral);
        setState(2764);
        anyIdentifier();
        break;
      }

      case ReentParser::UserDefinedStringLiteral: {
        setState(2765);
        match(ReentParser::UserDefinedStringLiteral);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateDeclarationContext ------------------------------------------------------------------

ReentParser::TemplateDeclarationContext::TemplateDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TemplateDeclarationContext::Template() {
  return getToken(ReentParser::Template, 0);
}

tree::TerminalNode* ReentParser::TemplateDeclarationContext::Less() {
  return getToken(ReentParser::Less, 0);
}

ReentParser::TemplateparameterListContext* ReentParser::TemplateDeclarationContext::templateparameterList() {
  return getRuleContext<ReentParser::TemplateparameterListContext>(0);
}

tree::TerminalNode* ReentParser::TemplateDeclarationContext::Greater() {
  return getToken(ReentParser::Greater, 0);
}

ReentParser::DeclarationContext* ReentParser::TemplateDeclarationContext::declaration() {
  return getRuleContext<ReentParser::DeclarationContext>(0);
}


size_t ReentParser::TemplateDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleTemplateDeclaration;
}

void ReentParser::TemplateDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateDeclaration(this);
}

void ReentParser::TemplateDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateDeclaration(this);
}

ReentParser::TemplateDeclarationContext* ReentParser::templateDeclaration() {
  TemplateDeclarationContext *_localctx = _tracker.createInstance<TemplateDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 508, ReentParser::RuleTemplateDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2768);
    match(ReentParser::Template);
    setState(2769);
    match(ReentParser::Less);
    setState(2770);
    templateparameterList();
    setState(2771);
    match(ReentParser::Greater);
    setState(2772);
    declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateparameterListContext ------------------------------------------------------------------

ReentParser::TemplateparameterListContext::TemplateparameterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::TemplateParameterContext *> ReentParser::TemplateparameterListContext::templateParameter() {
  return getRuleContexts<ReentParser::TemplateParameterContext>();
}

ReentParser::TemplateParameterContext* ReentParser::TemplateparameterListContext::templateParameter(size_t i) {
  return getRuleContext<ReentParser::TemplateParameterContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::TemplateparameterListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::TemplateparameterListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::TemplateparameterListContext::getRuleIndex() const {
  return ReentParser::RuleTemplateparameterList;
}

void ReentParser::TemplateparameterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateparameterList(this);
}

void ReentParser::TemplateparameterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateparameterList(this);
}

ReentParser::TemplateparameterListContext* ReentParser::templateparameterList() {
  TemplateparameterListContext *_localctx = _tracker.createInstance<TemplateparameterListContext>(_ctx, getState());
  enterRule(_localctx, 510, ReentParser::RuleTemplateparameterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2774);
    templateParameter();
    setState(2779);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2775);
      match(ReentParser::Comma);
      setState(2776);
      templateParameter();
      setState(2781);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateParameterContext ------------------------------------------------------------------

ReentParser::TemplateParameterContext::TemplateParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TypeParameterContext* ReentParser::TemplateParameterContext::typeParameter() {
  return getRuleContext<ReentParser::TypeParameterContext>(0);
}

ReentParser::ParameterDeclarationContext* ReentParser::TemplateParameterContext::parameterDeclaration() {
  return getRuleContext<ReentParser::ParameterDeclarationContext>(0);
}


size_t ReentParser::TemplateParameterContext::getRuleIndex() const {
  return ReentParser::RuleTemplateParameter;
}

void ReentParser::TemplateParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateParameter(this);
}

void ReentParser::TemplateParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateParameter(this);
}

ReentParser::TemplateParameterContext* ReentParser::templateParameter() {
  TemplateParameterContext *_localctx = _tracker.createInstance<TemplateParameterContext>(_ctx, getState());
  enterRule(_localctx, 512, ReentParser::RuleTemplateParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2784);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2782);
      typeParameter();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2783);
      parameterDeclaration();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeParameterContext ------------------------------------------------------------------

ReentParser::TypeParameterContext::TypeParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TypeParameterContext::Class() {
  return getToken(ReentParser::Class, 0);
}

tree::TerminalNode* ReentParser::TypeParameterContext::Typename_() {
  return getToken(ReentParser::Typename_, 0);
}

tree::TerminalNode* ReentParser::TypeParameterContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

ReentParser::TheTypeIdContext* ReentParser::TypeParameterContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

tree::TerminalNode* ReentParser::TypeParameterContext::Template() {
  return getToken(ReentParser::Template, 0);
}

tree::TerminalNode* ReentParser::TypeParameterContext::Less() {
  return getToken(ReentParser::Less, 0);
}

ReentParser::TemplateparameterListContext* ReentParser::TypeParameterContext::templateparameterList() {
  return getRuleContext<ReentParser::TemplateparameterListContext>(0);
}

tree::TerminalNode* ReentParser::TypeParameterContext::Greater() {
  return getToken(ReentParser::Greater, 0);
}

tree::TerminalNode* ReentParser::TypeParameterContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}

ReentParser::AnyIdentifierContext* ReentParser::TypeParameterContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::TypeParameterContext::getRuleIndex() const {
  return ReentParser::RuleTypeParameter;
}

void ReentParser::TypeParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeParameter(this);
}

void ReentParser::TypeParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeParameter(this);
}

ReentParser::TypeParameterContext* ReentParser::typeParameter() {
  TypeParameterContext *_localctx = _tracker.createInstance<TypeParameterContext>(_ctx, getState());
  enterRule(_localctx, 514, ReentParser::RuleTypeParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Class:
      case ReentParser::Template: {
        setState(2791);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Template) {
          setState(2786);
          match(ReentParser::Template);
          setState(2787);
          match(ReentParser::Less);
          setState(2788);
          templateparameterList();
          setState(2789);
          match(ReentParser::Greater);
        }
        setState(2793);
        match(ReentParser::Class);
        break;
      }

      case ReentParser::Typename_: {
        setState(2794);
        match(ReentParser::Typename_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      setState(2798);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Ellipsis) {
        setState(2797);
        match(ReentParser::Ellipsis);
      }
      setState(2801);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << ReentParser::Begin)
        | (1ULL << ReentParser::Clustered)
        | (1ULL << ReentParser::Common)
        | (1ULL << ReentParser::Depends)
        | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
        | (1ULL << (ReentParser::Gpu - 64))
        | (1ULL << (ReentParser::Id - 64))
        | (1ULL << (ReentParser::In - 64))
        | (1ULL << (ReentParser::Local - 64))
        | (1ULL << (ReentParser::MarkPreCondition - 64))
        | (1ULL << (ReentParser::MarkState - 64))
        | (1ULL << (ReentParser::Out - 64))
        | (1ULL << (ReentParser::Plan - 64))
        | (1ULL << (ReentParser::Reset - 64))
        | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

      || _la == ReentParser::Identifier) {
        setState(2800);
        anyIdentifier();
      }
      break;
    }

    case 2: {
      setState(2804);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << ReentParser::Begin)
        | (1ULL << ReentParser::Clustered)
        | (1ULL << ReentParser::Common)
        | (1ULL << ReentParser::Depends)
        | (1ULL << ReentParser::End))) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & ((1ULL << (ReentParser::Global - 64))
        | (1ULL << (ReentParser::Gpu - 64))
        | (1ULL << (ReentParser::Id - 64))
        | (1ULL << (ReentParser::In - 64))
        | (1ULL << (ReentParser::Local - 64))
        | (1ULL << (ReentParser::MarkPreCondition - 64))
        | (1ULL << (ReentParser::MarkState - 64))
        | (1ULL << (ReentParser::Out - 64))
        | (1ULL << (ReentParser::Plan - 64))
        | (1ULL << (ReentParser::Reset - 64))
        | (1ULL << (ReentParser::Set - 64)))) != 0) || _la == ReentParser::Vectorized

      || _la == ReentParser::Identifier) {
        setState(2803);
        anyIdentifier();
      }
      setState(2806);
      match(ReentParser::Assign);
      setState(2807);
      theTypeId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleTemplateIdContext ------------------------------------------------------------------

ReentParser::SimpleTemplateIdContext::SimpleTemplateIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::SimpleTemplateIdContext::Less() {
  return getToken(ReentParser::Less, 0);
}

tree::TerminalNode* ReentParser::SimpleTemplateIdContext::Greater() {
  return getToken(ReentParser::Greater, 0);
}

ReentParser::TemplateNameContext* ReentParser::SimpleTemplateIdContext::templateName() {
  return getRuleContext<ReentParser::TemplateNameContext>(0);
}

ReentParser::TemplateArgumentListContext* ReentParser::SimpleTemplateIdContext::templateArgumentList() {
  return getRuleContext<ReentParser::TemplateArgumentListContext>(0);
}


size_t ReentParser::SimpleTemplateIdContext::getRuleIndex() const {
  return ReentParser::RuleSimpleTemplateId;
}

void ReentParser::SimpleTemplateIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleTemplateId(this);
}

void ReentParser::SimpleTemplateIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleTemplateId(this);
}

ReentParser::SimpleTemplateIdContext* ReentParser::simpleTemplateId() {
  SimpleTemplateIdContext *_localctx = _tracker.createInstance<SimpleTemplateIdContext>(_ctx, getState());
  enterRule(_localctx, 516, ReentParser::RuleSimpleTemplateId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2810);
    dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id = templateName();
    setState(2811);
    match(ReentParser::Less);
    setState(2813);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
    case 1: {
      setState(2812);
      templateArgumentList();
      break;
    }

    default:
      break;
    }
    setState(2815);
    match(ReentParser::Greater);
     if (!allow_clustered && ((dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id != nullptr ? _input->getText(dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id->start, dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id->stop) : nullptr) == "cfunneled_predictor_in" || (dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id != nullptr ? _input->getText(dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id->start, dynamic_cast<SimpleTemplateIdContext *>(_localctx)->id->stop) : nullptr) == "cfunneled_predictor_out" ))
    		throw FailedPredicateException(this, "cfunneled_predictor_{in|out} can't be used without '#pragma plan clustered'");
    	
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateIdContext ------------------------------------------------------------------

ReentParser::TemplateIdContext::TemplateIdContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::SimpleTemplateIdContext* ReentParser::TemplateIdContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

tree::TerminalNode* ReentParser::TemplateIdContext::Less() {
  return getToken(ReentParser::Less, 0);
}

tree::TerminalNode* ReentParser::TemplateIdContext::Greater() {
  return getToken(ReentParser::Greater, 0);
}

ReentParser::OperatorFunctionIdContext* ReentParser::TemplateIdContext::operatorFunctionId() {
  return getRuleContext<ReentParser::OperatorFunctionIdContext>(0);
}

ReentParser::LiteralOperatorIdContext* ReentParser::TemplateIdContext::literalOperatorId() {
  return getRuleContext<ReentParser::LiteralOperatorIdContext>(0);
}

ReentParser::TemplateArgumentListContext* ReentParser::TemplateIdContext::templateArgumentList() {
  return getRuleContext<ReentParser::TemplateArgumentListContext>(0);
}


size_t ReentParser::TemplateIdContext::getRuleIndex() const {
  return ReentParser::RuleTemplateId;
}

void ReentParser::TemplateIdContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateId(this);
}

void ReentParser::TemplateIdContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateId(this);
}

ReentParser::TemplateIdContext* ReentParser::templateId() {
  TemplateIdContext *_localctx = _tracker.createInstance<TemplateIdContext>(_ctx, getState());
  enterRule(_localctx, 518, ReentParser::RuleTemplateId);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2829);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Depends:
      case ReentParser::End:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Local:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Vectorized:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2818);
        simpleTemplateId();
        break;
      }

      case ReentParser::Operator: {
        enterOuterAlt(_localctx, 2);
        setState(2821);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
        case 1: {
          setState(2819);
          operatorFunctionId();
          break;
        }

        case 2: {
          setState(2820);
          literalOperatorId();
          break;
        }

        default:
          break;
        }
        setState(2823);
        match(ReentParser::Less);
        setState(2825);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
        case 1: {
          setState(2824);
          templateArgumentList();
          break;
        }

        default:
          break;
        }
        setState(2827);
        match(ReentParser::Greater);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateNameContext ------------------------------------------------------------------

ReentParser::TemplateNameContext::TemplateNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::AnyIdentifierContext* ReentParser::TemplateNameContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}


size_t ReentParser::TemplateNameContext::getRuleIndex() const {
  return ReentParser::RuleTemplateName;
}

void ReentParser::TemplateNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateName(this);
}

void ReentParser::TemplateNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateName(this);
}

ReentParser::TemplateNameContext* ReentParser::templateName() {
  TemplateNameContext *_localctx = _tracker.createInstance<TemplateNameContext>(_ctx, getState());
  enterRule(_localctx, 520, ReentParser::RuleTemplateName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2831);
    anyIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateArgumentListContext ------------------------------------------------------------------

ReentParser::TemplateArgumentListContext::TemplateArgumentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::TemplateArgumentContext *> ReentParser::TemplateArgumentListContext::templateArgument() {
  return getRuleContexts<ReentParser::TemplateArgumentContext>();
}

ReentParser::TemplateArgumentContext* ReentParser::TemplateArgumentListContext::templateArgument(size_t i) {
  return getRuleContext<ReentParser::TemplateArgumentContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::TemplateArgumentListContext::Ellipsis() {
  return getTokens(ReentParser::Ellipsis);
}

tree::TerminalNode* ReentParser::TemplateArgumentListContext::Ellipsis(size_t i) {
  return getToken(ReentParser::Ellipsis, i);
}

std::vector<tree::TerminalNode *> ReentParser::TemplateArgumentListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::TemplateArgumentListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::TemplateArgumentListContext::getRuleIndex() const {
  return ReentParser::RuleTemplateArgumentList;
}

void ReentParser::TemplateArgumentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateArgumentList(this);
}

void ReentParser::TemplateArgumentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateArgumentList(this);
}

ReentParser::TemplateArgumentListContext* ReentParser::templateArgumentList() {
  TemplateArgumentListContext *_localctx = _tracker.createInstance<TemplateArgumentListContext>(_ctx, getState());
  enterRule(_localctx, 522, ReentParser::RuleTemplateArgumentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2833);
    templateArgument();
    setState(2835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(2834);
      match(ReentParser::Ellipsis);
    }
    setState(2844);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2837);
      match(ReentParser::Comma);
      setState(2838);
      templateArgument();
      setState(2840);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Ellipsis) {
        setState(2839);
        match(ReentParser::Ellipsis);
      }
      setState(2846);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemplateArgumentContext ------------------------------------------------------------------

ReentParser::TemplateArgumentContext::TemplateArgumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TheTypeIdContext* ReentParser::TemplateArgumentContext::theTypeId() {
  return getRuleContext<ReentParser::TheTypeIdContext>(0);
}

ReentParser::ConstantExpressionContext* ReentParser::TemplateArgumentContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

ReentParser::IdExpressionContext* ReentParser::TemplateArgumentContext::idExpression() {
  return getRuleContext<ReentParser::IdExpressionContext>(0);
}


size_t ReentParser::TemplateArgumentContext::getRuleIndex() const {
  return ReentParser::RuleTemplateArgument;
}

void ReentParser::TemplateArgumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplateArgument(this);
}

void ReentParser::TemplateArgumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplateArgument(this);
}

ReentParser::TemplateArgumentContext* ReentParser::templateArgument() {
  TemplateArgumentContext *_localctx = _tracker.createInstance<TemplateArgumentContext>(_ctx, getState());
  enterRule(_localctx, 524, ReentParser::RuleTemplateArgument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2850);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2847);
      theTypeId();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2848);
      constantExpression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2849);
      idExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeNameSpecifierContext ------------------------------------------------------------------

ReentParser::TypeNameSpecifierContext::TypeNameSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TypeNameSpecifierContext::Typename_() {
  return getToken(ReentParser::Typename_, 0);
}

ReentParser::NestedNameSpecifierContext* ReentParser::TypeNameSpecifierContext::nestedNameSpecifier() {
  return getRuleContext<ReentParser::NestedNameSpecifierContext>(0);
}

ReentParser::AnyIdentifierContext* ReentParser::TypeNameSpecifierContext::anyIdentifier() {
  return getRuleContext<ReentParser::AnyIdentifierContext>(0);
}

ReentParser::SimpleTemplateIdContext* ReentParser::TypeNameSpecifierContext::simpleTemplateId() {
  return getRuleContext<ReentParser::SimpleTemplateIdContext>(0);
}

tree::TerminalNode* ReentParser::TypeNameSpecifierContext::Template() {
  return getToken(ReentParser::Template, 0);
}


size_t ReentParser::TypeNameSpecifierContext::getRuleIndex() const {
  return ReentParser::RuleTypeNameSpecifier;
}

void ReentParser::TypeNameSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeNameSpecifier(this);
}

void ReentParser::TypeNameSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeNameSpecifier(this);
}

ReentParser::TypeNameSpecifierContext* ReentParser::typeNameSpecifier() {
  TypeNameSpecifierContext *_localctx = _tracker.createInstance<TypeNameSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 526, ReentParser::RuleTypeNameSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2852);
    match(ReentParser::Typename_);
    setState(2853);
    nestedNameSpecifier(0);
    setState(2859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx)) {
    case 1: {
      setState(2854);
      anyIdentifier();
      break;
    }

    case 2: {
      setState(2856);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Template) {
        setState(2855);
        match(ReentParser::Template);
      }
      setState(2858);
      simpleTemplateId();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitInstantiationContext ------------------------------------------------------------------

ReentParser::ExplicitInstantiationContext::ExplicitInstantiationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ExplicitInstantiationContext::Template() {
  return getToken(ReentParser::Template, 0);
}

ReentParser::DeclarationContext* ReentParser::ExplicitInstantiationContext::declaration() {
  return getRuleContext<ReentParser::DeclarationContext>(0);
}

tree::TerminalNode* ReentParser::ExplicitInstantiationContext::Extern() {
  return getToken(ReentParser::Extern, 0);
}


size_t ReentParser::ExplicitInstantiationContext::getRuleIndex() const {
  return ReentParser::RuleExplicitInstantiation;
}

void ReentParser::ExplicitInstantiationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitInstantiation(this);
}

void ReentParser::ExplicitInstantiationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitInstantiation(this);
}

ReentParser::ExplicitInstantiationContext* ReentParser::explicitInstantiation() {
  ExplicitInstantiationContext *_localctx = _tracker.createInstance<ExplicitInstantiationContext>(_ctx, getState());
  enterRule(_localctx, 528, ReentParser::RuleExplicitInstantiation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2862);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Extern) {
      setState(2861);
      match(ReentParser::Extern);
    }
    setState(2864);
    match(ReentParser::Template);
    setState(2865);
    declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitSpecializationContext ------------------------------------------------------------------

ReentParser::ExplicitSpecializationContext::ExplicitSpecializationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ExplicitSpecializationContext::Template() {
  return getToken(ReentParser::Template, 0);
}

tree::TerminalNode* ReentParser::ExplicitSpecializationContext::Less() {
  return getToken(ReentParser::Less, 0);
}

tree::TerminalNode* ReentParser::ExplicitSpecializationContext::Greater() {
  return getToken(ReentParser::Greater, 0);
}

ReentParser::DeclarationContext* ReentParser::ExplicitSpecializationContext::declaration() {
  return getRuleContext<ReentParser::DeclarationContext>(0);
}


size_t ReentParser::ExplicitSpecializationContext::getRuleIndex() const {
  return ReentParser::RuleExplicitSpecialization;
}

void ReentParser::ExplicitSpecializationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitSpecialization(this);
}

void ReentParser::ExplicitSpecializationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitSpecialization(this);
}

ReentParser::ExplicitSpecializationContext* ReentParser::explicitSpecialization() {
  ExplicitSpecializationContext *_localctx = _tracker.createInstance<ExplicitSpecializationContext>(_ctx, getState());
  enterRule(_localctx, 530, ReentParser::RuleExplicitSpecialization);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2867);
    match(ReentParser::Template);
    setState(2868);
    match(ReentParser::Less);
    setState(2869);
    match(ReentParser::Greater);
    setState(2870);
    declaration();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TryBlockContext ------------------------------------------------------------------

ReentParser::TryBlockContext::TryBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TryBlockContext::Try() {
  return getToken(ReentParser::Try, 0);
}

ReentParser::CompoundStatementContext* ReentParser::TryBlockContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}

ReentParser::HandlerSeqContext* ReentParser::TryBlockContext::handlerSeq() {
  return getRuleContext<ReentParser::HandlerSeqContext>(0);
}


size_t ReentParser::TryBlockContext::getRuleIndex() const {
  return ReentParser::RuleTryBlock;
}

void ReentParser::TryBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTryBlock(this);
}

void ReentParser::TryBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTryBlock(this);
}

ReentParser::TryBlockContext* ReentParser::tryBlock() {
  TryBlockContext *_localctx = _tracker.createInstance<TryBlockContext>(_ctx, getState());
  enterRule(_localctx, 532, ReentParser::RuleTryBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2872);
    match(ReentParser::Try);
    setState(2873);
    compoundStatement();
    setState(2874);
    handlerSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionTryBlockContext ------------------------------------------------------------------

ReentParser::FunctionTryBlockContext::FunctionTryBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::FunctionTryBlockContext::Try() {
  return getToken(ReentParser::Try, 0);
}

ReentParser::CompoundStatementContext* ReentParser::FunctionTryBlockContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}

ReentParser::HandlerSeqContext* ReentParser::FunctionTryBlockContext::handlerSeq() {
  return getRuleContext<ReentParser::HandlerSeqContext>(0);
}

ReentParser::ConstructorInitializerContext* ReentParser::FunctionTryBlockContext::constructorInitializer() {
  return getRuleContext<ReentParser::ConstructorInitializerContext>(0);
}


size_t ReentParser::FunctionTryBlockContext::getRuleIndex() const {
  return ReentParser::RuleFunctionTryBlock;
}

void ReentParser::FunctionTryBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionTryBlock(this);
}

void ReentParser::FunctionTryBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionTryBlock(this);
}

ReentParser::FunctionTryBlockContext* ReentParser::functionTryBlock() {
  FunctionTryBlockContext *_localctx = _tracker.createInstance<FunctionTryBlockContext>(_ctx, getState());
  enterRule(_localctx, 534, ReentParser::RuleFunctionTryBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2876);
    match(ReentParser::Try);
    setState(2878);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Colon) {
      setState(2877);
      constructorInitializer();
    }
    setState(2880);
    compoundStatement();
    setState(2881);
    handlerSeq();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerSeqContext ------------------------------------------------------------------

ReentParser::HandlerSeqContext::HandlerSeqContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::HandlerContext *> ReentParser::HandlerSeqContext::handler() {
  return getRuleContexts<ReentParser::HandlerContext>();
}

ReentParser::HandlerContext* ReentParser::HandlerSeqContext::handler(size_t i) {
  return getRuleContext<ReentParser::HandlerContext>(i);
}


size_t ReentParser::HandlerSeqContext::getRuleIndex() const {
  return ReentParser::RuleHandlerSeq;
}

void ReentParser::HandlerSeqContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerSeq(this);
}

void ReentParser::HandlerSeqContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerSeq(this);
}

ReentParser::HandlerSeqContext* ReentParser::handlerSeq() {
  HandlerSeqContext *_localctx = _tracker.createInstance<HandlerSeqContext>(_ctx, getState());
  enterRule(_localctx, 536, ReentParser::RuleHandlerSeq);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2884); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(2883);
              handler();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(2886); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 350, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerContext ------------------------------------------------------------------

ReentParser::HandlerContext::HandlerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::HandlerContext::Catch() {
  return getToken(ReentParser::Catch, 0);
}

tree::TerminalNode* ReentParser::HandlerContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ExceptionDeclarationContext* ReentParser::HandlerContext::exceptionDeclaration() {
  return getRuleContext<ReentParser::ExceptionDeclarationContext>(0);
}

tree::TerminalNode* ReentParser::HandlerContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::CompoundStatementContext* ReentParser::HandlerContext::compoundStatement() {
  return getRuleContext<ReentParser::CompoundStatementContext>(0);
}


size_t ReentParser::HandlerContext::getRuleIndex() const {
  return ReentParser::RuleHandler;
}

void ReentParser::HandlerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandler(this);
}

void ReentParser::HandlerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandler(this);
}

ReentParser::HandlerContext* ReentParser::handler() {
  HandlerContext *_localctx = _tracker.createInstance<HandlerContext>(_ctx, getState());
  enterRule(_localctx, 538, ReentParser::RuleHandler);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2888);
    match(ReentParser::Catch);
    setState(2889);
    match(ReentParser::LeftParen);
    setState(2890);
    exceptionDeclaration();
    setState(2891);
    match(ReentParser::RightParen);
    setState(2892);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExceptionDeclarationContext ------------------------------------------------------------------

ReentParser::ExceptionDeclarationContext::ExceptionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::TypeSpecifierSeqContext* ReentParser::ExceptionDeclarationContext::typeSpecifierSeq() {
  return getRuleContext<ReentParser::TypeSpecifierSeqContext>(0);
}

ReentParser::AttributeSpecifierSeqContext* ReentParser::ExceptionDeclarationContext::attributeSpecifierSeq() {
  return getRuleContext<ReentParser::AttributeSpecifierSeqContext>(0);
}

ReentParser::DeclaratorContext* ReentParser::ExceptionDeclarationContext::declarator() {
  return getRuleContext<ReentParser::DeclaratorContext>(0);
}

ReentParser::AbstractDeclaratorContext* ReentParser::ExceptionDeclarationContext::abstractDeclarator() {
  return getRuleContext<ReentParser::AbstractDeclaratorContext>(0);
}

tree::TerminalNode* ReentParser::ExceptionDeclarationContext::Ellipsis() {
  return getToken(ReentParser::Ellipsis, 0);
}


size_t ReentParser::ExceptionDeclarationContext::getRuleIndex() const {
  return ReentParser::RuleExceptionDeclaration;
}

void ReentParser::ExceptionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExceptionDeclaration(this);
}

void ReentParser::ExceptionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExceptionDeclaration(this);
}

ReentParser::ExceptionDeclarationContext* ReentParser::exceptionDeclaration() {
  ExceptionDeclarationContext *_localctx = _tracker.createInstance<ExceptionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 540, ReentParser::RuleExceptionDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2903);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Alignas:
      case ReentParser::Auto:
      case ReentParser::Begin:
      case ReentParser::Bool:
      case ReentParser::Cfunnel:
      case ReentParser::Char:
      case ReentParser::Char16:
      case ReentParser::Char32:
      case ReentParser::Class:
      case ReentParser::Clustered:
      case ReentParser::Common:
      case ReentParser::Const:
      case ReentParser::Csem:
      case ReentParser::Cvar:
      case ReentParser::Decltype:
      case ReentParser::Depends:
      case ReentParser::Double:
      case ReentParser::End:
      case ReentParser::Enum:
      case ReentParser::Float:
      case ReentParser::Funnel:
      case ReentParser::Global:
      case ReentParser::Gpu:
      case ReentParser::Id:
      case ReentParser::In:
      case ReentParser::Int:
      case ReentParser::Local:
      case ReentParser::Long:
      case ReentParser::MarkPreCondition:
      case ReentParser::MarkState:
      case ReentParser::Out:
      case ReentParser::Plan:
      case ReentParser::Plan_item_type:
      case ReentParser::Plan_type:
      case ReentParser::Reset:
      case ReentParser::Set:
      case ReentParser::Short:
      case ReentParser::Signed:
      case ReentParser::Soft_transact_array:
      case ReentParser::Soft_transact_in:
      case ReentParser::Soft_transact_out:
      case ReentParser::Soft_transact_var:
      case ReentParser::Struct:
      case ReentParser::Typename_:
      case ReentParser::Union:
      case ReentParser::Unsigned:
      case ReentParser::Vectorized:
      case ReentParser::Void:
      case ReentParser::Volatile:
      case ReentParser::Wchar:
      case ReentParser::LeftBracket:
      case ReentParser::Doublecolon:
      case ReentParser::Identifier: {
        enterOuterAlt(_localctx, 1);
        setState(2895);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == ReentParser::Alignas || _la == ReentParser::LeftBracket) {
          setState(2894);
          attributeSpecifierSeq();
        }
        setState(2897);
        typeSpecifierSeq();
        setState(2900);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
        case 1: {
          setState(2898);
          declarator();
          break;
        }

        case 2: {
          setState(2899);
          abstractDeclarator();
          break;
        }

        default:
          break;
        }
        break;
      }

      case ReentParser::Ellipsis: {
        enterOuterAlt(_localctx, 2);
        setState(2902);
        match(ReentParser::Ellipsis);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThrowExpressionContext ------------------------------------------------------------------

ReentParser::ThrowExpressionContext::ThrowExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::ThrowExpressionContext::Throw() {
  return getToken(ReentParser::Throw, 0);
}

ReentParser::AssignmentExpressionContext* ReentParser::ThrowExpressionContext::assignmentExpression() {
  return getRuleContext<ReentParser::AssignmentExpressionContext>(0);
}


size_t ReentParser::ThrowExpressionContext::getRuleIndex() const {
  return ReentParser::RuleThrowExpression;
}

void ReentParser::ThrowExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThrowExpression(this);
}

void ReentParser::ThrowExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThrowExpression(this);
}

ReentParser::ThrowExpressionContext* ReentParser::throwExpression() {
  ThrowExpressionContext *_localctx = _tracker.createInstance<ThrowExpressionContext>(_ctx, getState());
  enterRule(_localctx, 542, ReentParser::RuleThrowExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2905);
    match(ReentParser::Throw);
    setState(2907);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      setState(2906);
      assignmentExpression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExceptionSpecificationContext ------------------------------------------------------------------

ReentParser::ExceptionSpecificationContext::ExceptionSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::DynamicExceptionSpecificationContext* ReentParser::ExceptionSpecificationContext::dynamicExceptionSpecification() {
  return getRuleContext<ReentParser::DynamicExceptionSpecificationContext>(0);
}

ReentParser::NoeExceptSpecificationContext* ReentParser::ExceptionSpecificationContext::noeExceptSpecification() {
  return getRuleContext<ReentParser::NoeExceptSpecificationContext>(0);
}


size_t ReentParser::ExceptionSpecificationContext::getRuleIndex() const {
  return ReentParser::RuleExceptionSpecification;
}

void ReentParser::ExceptionSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExceptionSpecification(this);
}

void ReentParser::ExceptionSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExceptionSpecification(this);
}

ReentParser::ExceptionSpecificationContext* ReentParser::exceptionSpecification() {
  ExceptionSpecificationContext *_localctx = _tracker.createInstance<ExceptionSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 544, ReentParser::RuleExceptionSpecification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2911);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Throw: {
        enterOuterAlt(_localctx, 1);
        setState(2909);
        dynamicExceptionSpecification();
        break;
      }

      case ReentParser::Noexcept: {
        enterOuterAlt(_localctx, 2);
        setState(2910);
        noeExceptSpecification();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DynamicExceptionSpecificationContext ------------------------------------------------------------------

ReentParser::DynamicExceptionSpecificationContext::DynamicExceptionSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::DynamicExceptionSpecificationContext::Throw() {
  return getToken(ReentParser::Throw, 0);
}

tree::TerminalNode* ReentParser::DynamicExceptionSpecificationContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::DynamicExceptionSpecificationContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}

ReentParser::TypeIdListContext* ReentParser::DynamicExceptionSpecificationContext::typeIdList() {
  return getRuleContext<ReentParser::TypeIdListContext>(0);
}


size_t ReentParser::DynamicExceptionSpecificationContext::getRuleIndex() const {
  return ReentParser::RuleDynamicExceptionSpecification;
}

void ReentParser::DynamicExceptionSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDynamicExceptionSpecification(this);
}

void ReentParser::DynamicExceptionSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDynamicExceptionSpecification(this);
}

ReentParser::DynamicExceptionSpecificationContext* ReentParser::dynamicExceptionSpecification() {
  DynamicExceptionSpecificationContext *_localctx = _tracker.createInstance<DynamicExceptionSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 546, ReentParser::RuleDynamicExceptionSpecification);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2913);
    match(ReentParser::Throw);
    setState(2914);
    match(ReentParser::LeftParen);
    setState(2916);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 18) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 18)) & ((1ULL << (ReentParser::Auto - 18))
      | (1ULL << (ReentParser::Begin - 18))
      | (1ULL << (ReentParser::Bool - 18))
      | (1ULL << (ReentParser::Cfunnel - 18))
      | (1ULL << (ReentParser::Char - 18))
      | (1ULL << (ReentParser::Char16 - 18))
      | (1ULL << (ReentParser::Char32 - 18))
      | (1ULL << (ReentParser::Class - 18))
      | (1ULL << (ReentParser::Clustered - 18))
      | (1ULL << (ReentParser::Common - 18))
      | (1ULL << (ReentParser::Const - 18))
      | (1ULL << (ReentParser::Csem - 18))
      | (1ULL << (ReentParser::Cvar - 18))
      | (1ULL << (ReentParser::Decltype - 18))
      | (1ULL << (ReentParser::Depends - 18))
      | (1ULL << (ReentParser::Double - 18))
      | (1ULL << (ReentParser::End - 18))
      | (1ULL << (ReentParser::Enum - 18))
      | (1ULL << (ReentParser::Float - 18))
      | (1ULL << (ReentParser::Funnel - 18))
      | (1ULL << (ReentParser::Global - 18))
      | (1ULL << (ReentParser::Gpu - 18))
      | (1ULL << (ReentParser::Id - 18))
      | (1ULL << (ReentParser::In - 18))
      | (1ULL << (ReentParser::Int - 18))
      | (1ULL << (ReentParser::Local - 18))
      | (1ULL << (ReentParser::Long - 18))
      | (1ULL << (ReentParser::MarkPreCondition - 18))
      | (1ULL << (ReentParser::MarkState - 18)))) != 0) || ((((_la - 85) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 85)) & ((1ULL << (ReentParser::Out - 85))
      | (1ULL << (ReentParser::Plan - 85))
      | (1ULL << (ReentParser::Plan_item_type - 85))
      | (1ULL << (ReentParser::Plan_type - 85))
      | (1ULL << (ReentParser::Reset - 85))
      | (1ULL << (ReentParser::Set - 85))
      | (1ULL << (ReentParser::Short - 85))
      | (1ULL << (ReentParser::Signed - 85))
      | (1ULL << (ReentParser::Soft_transact_array - 85))
      | (1ULL << (ReentParser::Soft_transact_in - 85))
      | (1ULL << (ReentParser::Soft_transact_out - 85))
      | (1ULL << (ReentParser::Soft_transact_var - 85))
      | (1ULL << (ReentParser::Struct - 85))
      | (1ULL << (ReentParser::Typename_ - 85))
      | (1ULL << (ReentParser::Union - 85))
      | (1ULL << (ReentParser::Unsigned - 85))
      | (1ULL << (ReentParser::Vectorized - 85))
      | (1ULL << (ReentParser::Void - 85)))) != 0) || ((((_la - 149) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 149)) & ((1ULL << (ReentParser::Volatile - 149))
      | (1ULL << (ReentParser::Wchar - 149))
      | (1ULL << (ReentParser::Doublecolon - 149))
      | (1ULL << (ReentParser::Identifier - 149)))) != 0)) {
      setState(2915);
      typeIdList();
    }
    setState(2918);
    match(ReentParser::RightParen);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeIdListContext ------------------------------------------------------------------

ReentParser::TypeIdListContext::TypeIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<ReentParser::TheTypeIdContext *> ReentParser::TypeIdListContext::theTypeId() {
  return getRuleContexts<ReentParser::TheTypeIdContext>();
}

ReentParser::TheTypeIdContext* ReentParser::TypeIdListContext::theTypeId(size_t i) {
  return getRuleContext<ReentParser::TheTypeIdContext>(i);
}

std::vector<tree::TerminalNode *> ReentParser::TypeIdListContext::Ellipsis() {
  return getTokens(ReentParser::Ellipsis);
}

tree::TerminalNode* ReentParser::TypeIdListContext::Ellipsis(size_t i) {
  return getToken(ReentParser::Ellipsis, i);
}

std::vector<tree::TerminalNode *> ReentParser::TypeIdListContext::Comma() {
  return getTokens(ReentParser::Comma);
}

tree::TerminalNode* ReentParser::TypeIdListContext::Comma(size_t i) {
  return getToken(ReentParser::Comma, i);
}


size_t ReentParser::TypeIdListContext::getRuleIndex() const {
  return ReentParser::RuleTypeIdList;
}

void ReentParser::TypeIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeIdList(this);
}

void ReentParser::TypeIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeIdList(this);
}

ReentParser::TypeIdListContext* ReentParser::typeIdList() {
  TypeIdListContext *_localctx = _tracker.createInstance<TypeIdListContext>(_ctx, getState());
  enterRule(_localctx, 548, ReentParser::RuleTypeIdList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2920);
    theTypeId();
    setState(2922);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == ReentParser::Ellipsis) {
      setState(2921);
      match(ReentParser::Ellipsis);
    }
    setState(2931);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == ReentParser::Comma) {
      setState(2924);
      match(ReentParser::Comma);
      setState(2925);
      theTypeId();
      setState(2927);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == ReentParser::Ellipsis) {
        setState(2926);
        match(ReentParser::Ellipsis);
      }
      setState(2933);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoeExceptSpecificationContext ------------------------------------------------------------------

ReentParser::NoeExceptSpecificationContext::NoeExceptSpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::NoeExceptSpecificationContext::Noexcept() {
  return getToken(ReentParser::Noexcept, 0);
}

tree::TerminalNode* ReentParser::NoeExceptSpecificationContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

ReentParser::ConstantExpressionContext* ReentParser::NoeExceptSpecificationContext::constantExpression() {
  return getRuleContext<ReentParser::ConstantExpressionContext>(0);
}

tree::TerminalNode* ReentParser::NoeExceptSpecificationContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::NoeExceptSpecificationContext::getRuleIndex() const {
  return ReentParser::RuleNoeExceptSpecification;
}

void ReentParser::NoeExceptSpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoeExceptSpecification(this);
}

void ReentParser::NoeExceptSpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoeExceptSpecification(this);
}

ReentParser::NoeExceptSpecificationContext* ReentParser::noeExceptSpecification() {
  NoeExceptSpecificationContext *_localctx = _tracker.createInstance<NoeExceptSpecificationContext>(_ctx, getState());
  enterRule(_localctx, 550, ReentParser::RuleNoeExceptSpecification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2940);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2934);
      match(ReentParser::Noexcept);
      setState(2935);
      match(ReentParser::LeftParen);
      setState(2936);
      constantExpression();
      setState(2937);
      match(ReentParser::RightParen);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2939);
      match(ReentParser::Noexcept);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_pragmaContext ------------------------------------------------------------------

ReentParser::Plan_pragmaContext::Plan_pragmaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_pragmaContext::PlanPragma() {
  return getToken(ReentParser::PlanPragma, 0);
}

ReentParser::Plan_directiveContext* ReentParser::Plan_pragmaContext::plan_directive() {
  return getRuleContext<ReentParser::Plan_directiveContext>(0);
}


size_t ReentParser::Plan_pragmaContext::getRuleIndex() const {
  return ReentParser::RulePlan_pragma;
}

void ReentParser::Plan_pragmaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_pragma(this);
}

void ReentParser::Plan_pragmaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_pragma(this);
}

ReentParser::Plan_pragmaContext* ReentParser::plan_pragma() {
  Plan_pragmaContext *_localctx = _tracker.createInstance<Plan_pragmaContext>(_ctx, getState());
  enterRule(_localctx, 552, ReentParser::RulePlan_pragma);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2942);
    match(ReentParser::PlanPragma);
    setState(2943);
    plan_directive();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_directiveContext ------------------------------------------------------------------

ReentParser::Plan_directiveContext::Plan_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

ReentParser::Plan_dir_vectorizedContext* ReentParser::Plan_directiveContext::plan_dir_vectorized() {
  return getRuleContext<ReentParser::Plan_dir_vectorizedContext>(0);
}

ReentParser::Plan_dir_clusteredContext* ReentParser::Plan_directiveContext::plan_dir_clustered() {
  return getRuleContext<ReentParser::Plan_dir_clusteredContext>(0);
}

ReentParser::Plan_commonContext* ReentParser::Plan_directiveContext::plan_common() {
  return getRuleContext<ReentParser::Plan_commonContext>(0);
}

ReentParser::Plan_gpuContext* ReentParser::Plan_directiveContext::plan_gpu() {
  return getRuleContext<ReentParser::Plan_gpuContext>(0);
}


size_t ReentParser::Plan_directiveContext::getRuleIndex() const {
  return ReentParser::RulePlan_directive;
}

void ReentParser::Plan_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_directive(this);
}

void ReentParser::Plan_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_directive(this);
}

ReentParser::Plan_directiveContext* ReentParser::plan_directive() {
  Plan_directiveContext *_localctx = _tracker.createInstance<Plan_directiveContext>(_ctx, getState());
  enterRule(_localctx, 554, ReentParser::RulePlan_directive);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2949);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Vectorized: {
        enterOuterAlt(_localctx, 1);
        setState(2945);
        plan_dir_vectorized();
        break;
      }

      case ReentParser::Clustered: {
        enterOuterAlt(_localctx, 2);
        setState(2946);
        plan_dir_clustered();
        break;
      }

      case ReentParser::Common: {
        enterOuterAlt(_localctx, 3);
        setState(2947);
        plan_common();
        break;
      }

      case ReentParser::Gpu: {
        enterOuterAlt(_localctx, 4);
        setState(2948);
        plan_gpu();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_dir_vectorizedContext ------------------------------------------------------------------

ReentParser::Plan_dir_vectorizedContext::Plan_dir_vectorizedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_dir_vectorizedContext::Vectorized() {
  return getToken(ReentParser::Vectorized, 0);
}


size_t ReentParser::Plan_dir_vectorizedContext::getRuleIndex() const {
  return ReentParser::RulePlan_dir_vectorized;
}

void ReentParser::Plan_dir_vectorizedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_dir_vectorized(this);
}

void ReentParser::Plan_dir_vectorizedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_dir_vectorized(this);
}

ReentParser::Plan_dir_vectorizedContext* ReentParser::plan_dir_vectorized() {
  Plan_dir_vectorizedContext *_localctx = _tracker.createInstance<Plan_dir_vectorizedContext>(_ctx, getState());
  enterRule(_localctx, 556, ReentParser::RulePlan_dir_vectorized);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2951);
    match(ReentParser::Vectorized);
     allow_vectorized = true; 
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_dir_clusteredContext ------------------------------------------------------------------

ReentParser::Plan_dir_clusteredContext::Plan_dir_clusteredContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_dir_clusteredContext::Clustered() {
  return getToken(ReentParser::Clustered, 0);
}


size_t ReentParser::Plan_dir_clusteredContext::getRuleIndex() const {
  return ReentParser::RulePlan_dir_clustered;
}

void ReentParser::Plan_dir_clusteredContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_dir_clustered(this);
}

void ReentParser::Plan_dir_clusteredContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_dir_clustered(this);
}

ReentParser::Plan_dir_clusteredContext* ReentParser::plan_dir_clustered() {
  Plan_dir_clusteredContext *_localctx = _tracker.createInstance<Plan_dir_clusteredContext>(_ctx, getState());
  enterRule(_localctx, 558, ReentParser::RulePlan_dir_clustered);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2954);
    match(ReentParser::Clustered);
     allow_clustered = true; 
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_commonContext ------------------------------------------------------------------

ReentParser::Plan_commonContext::Plan_commonContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_commonContext::Common() {
  return getToken(ReentParser::Common, 0);
}

tree::TerminalNode* ReentParser::Plan_commonContext::Begin() {
  return getToken(ReentParser::Begin, 0);
}

tree::TerminalNode* ReentParser::Plan_commonContext::End() {
  return getToken(ReentParser::End, 0);
}


size_t ReentParser::Plan_commonContext::getRuleIndex() const {
  return ReentParser::RulePlan_common;
}

void ReentParser::Plan_commonContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_common(this);
}

void ReentParser::Plan_commonContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_common(this);
}

ReentParser::Plan_commonContext* ReentParser::plan_common() {
  Plan_commonContext *_localctx = _tracker.createInstance<Plan_commonContext>(_ctx, getState());
  enterRule(_localctx, 560, ReentParser::RulePlan_common);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2957);
    match(ReentParser::Common);

    		if (!allow_vectorized)
    			throw FailedPredicateException(this, "'#pragma plan common' without '#pragma plan vectorized'");
    		if (gpu_block_opened)
    			throw FailedPredicateException(this, "'#pragma plan common' can present only in non-gpu blocks'");
    	
    setState(2963);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin: {
        setState(2959);
        match(ReentParser::Begin);

        		if (common_block_opened)
        			throw FailedPredicateException(this, "'#pragma plan common begin' reintroduced");
        		common_block_opened = true;
        	  
        break;
      }

      case ReentParser::End: {
        setState(2961);
        match(ReentParser::End);

        		if (!common_block_opened)
        			throw FailedPredicateException(this, "'#pragma plan common end' in non-common block");
        		common_block_opened = false;
        	  
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Plan_gpuContext ------------------------------------------------------------------

ReentParser::Plan_gpuContext::Plan_gpuContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::Plan_gpuContext::Gpu() {
  return getToken(ReentParser::Gpu, 0);
}

tree::TerminalNode* ReentParser::Plan_gpuContext::Begin() {
  return getToken(ReentParser::Begin, 0);
}

tree::TerminalNode* ReentParser::Plan_gpuContext::End() {
  return getToken(ReentParser::End, 0);
}


size_t ReentParser::Plan_gpuContext::getRuleIndex() const {
  return ReentParser::RulePlan_gpu;
}

void ReentParser::Plan_gpuContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlan_gpu(this);
}

void ReentParser::Plan_gpuContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlan_gpu(this);
}

ReentParser::Plan_gpuContext* ReentParser::plan_gpu() {
  Plan_gpuContext *_localctx = _tracker.createInstance<Plan_gpuContext>(_ctx, getState());
  enterRule(_localctx, 562, ReentParser::RulePlan_gpu);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2965);
    match(ReentParser::Gpu);

    		if (!allow_vectorized)
    			throw FailedPredicateException(this, "'#pragma plan gpu' without '#pragma plan vectorized'");
    		if (common_block_opened)
    			throw FailedPredicateException(this, "'#pragma plan gpu' can present only in non-common blocks'");
    	
    setState(2971);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case ReentParser::Begin: {
        setState(2967);
        match(ReentParser::Begin);

        		if (gpu_block_opened)
        			throw FailedPredicateException(this, "'#pragma plan gpu begin' reintroduced");
        		gpu_block_opened = true;
        	  
        break;
      }

      case ReentParser::End: {
        setState(2969);
        match(ReentParser::End);

        		if (!gpu_block_opened)
        			throw FailedPredicateException(this, "'#pragma plan gpu end' in non-gpu block");
        		gpu_block_opened = false;
        	  
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TheOperatorContext ------------------------------------------------------------------

ReentParser::TheOperatorContext::TheOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::TheOperatorContext::New() {
  return getToken(ReentParser::New, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::LeftBracket() {
  return getToken(ReentParser::LeftBracket, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::RightBracket() {
  return getToken(ReentParser::RightBracket, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Delete() {
  return getToken(ReentParser::Delete, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Plus() {
  return getToken(ReentParser::Plus, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Minus() {
  return getToken(ReentParser::Minus, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Star() {
  return getToken(ReentParser::Star, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Div() {
  return getToken(ReentParser::Div, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Mod() {
  return getToken(ReentParser::Mod, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Caret() {
  return getToken(ReentParser::Caret, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::And() {
  return getToken(ReentParser::And, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Or() {
  return getToken(ReentParser::Or, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Tilde() {
  return getToken(ReentParser::Tilde, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Not() {
  return getToken(ReentParser::Not, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Assign() {
  return getToken(ReentParser::Assign, 0);
}

std::vector<tree::TerminalNode *> ReentParser::TheOperatorContext::Greater() {
  return getTokens(ReentParser::Greater);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Greater(size_t i) {
  return getToken(ReentParser::Greater, i);
}

std::vector<tree::TerminalNode *> ReentParser::TheOperatorContext::Less() {
  return getTokens(ReentParser::Less);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Less(size_t i) {
  return getToken(ReentParser::Less, i);
}

tree::TerminalNode* ReentParser::TheOperatorContext::GreaterEqual() {
  return getToken(ReentParser::GreaterEqual, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::PlusAssign() {
  return getToken(ReentParser::PlusAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::MinusAssign() {
  return getToken(ReentParser::MinusAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::StarAssign() {
  return getToken(ReentParser::StarAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::ModAssign() {
  return getToken(ReentParser::ModAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::XorAssign() {
  return getToken(ReentParser::XorAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::AndAssign() {
  return getToken(ReentParser::AndAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::OrAssign() {
  return getToken(ReentParser::OrAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::RightShiftAssign() {
  return getToken(ReentParser::RightShiftAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::LeftShiftAssign() {
  return getToken(ReentParser::LeftShiftAssign, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Equal() {
  return getToken(ReentParser::Equal, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::NotEqual() {
  return getToken(ReentParser::NotEqual, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::LessEqual() {
  return getToken(ReentParser::LessEqual, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::AndAnd() {
  return getToken(ReentParser::AndAnd, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::OrOr() {
  return getToken(ReentParser::OrOr, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::PlusPlus() {
  return getToken(ReentParser::PlusPlus, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::MinusMinus() {
  return getToken(ReentParser::MinusMinus, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Comma() {
  return getToken(ReentParser::Comma, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::ArrowStar() {
  return getToken(ReentParser::ArrowStar, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::Arrow() {
  return getToken(ReentParser::Arrow, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::LeftParen() {
  return getToken(ReentParser::LeftParen, 0);
}

tree::TerminalNode* ReentParser::TheOperatorContext::RightParen() {
  return getToken(ReentParser::RightParen, 0);
}


size_t ReentParser::TheOperatorContext::getRuleIndex() const {
  return ReentParser::RuleTheOperator;
}

void ReentParser::TheOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTheOperator(this);
}

void ReentParser::TheOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTheOperator(this);
}

ReentParser::TheOperatorContext* ReentParser::theOperator() {
  TheOperatorContext *_localctx = _tracker.createInstance<TheOperatorContext>(_ctx, getState());
  enterRule(_localctx, 564, ReentParser::RuleTheOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3024);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2973);
      match(ReentParser::New);
      setState(2976);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
      case 1: {
        setState(2974);
        match(ReentParser::LeftBracket);
        setState(2975);
        match(ReentParser::RightBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2978);
      match(ReentParser::Delete);
      setState(2981);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
      case 1: {
        setState(2979);
        match(ReentParser::LeftBracket);
        setState(2980);
        match(ReentParser::RightBracket);
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2983);
      match(ReentParser::Plus);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2984);
      match(ReentParser::Minus);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2985);
      match(ReentParser::Star);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2986);
      match(ReentParser::Div);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2987);
      match(ReentParser::Mod);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2988);
      match(ReentParser::Caret);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2989);
      match(ReentParser::And);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2990);
      match(ReentParser::Or);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(2991);
      match(ReentParser::Tilde);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(2992);
      match(ReentParser::Not);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(2993);
      match(ReentParser::Assign);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(2994);
      match(ReentParser::Greater);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(2995);
      match(ReentParser::Less);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(2996);
      match(ReentParser::GreaterEqual);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(2997);
      match(ReentParser::PlusAssign);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(2998);
      match(ReentParser::MinusAssign);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(2999);
      match(ReentParser::StarAssign);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(3000);
      match(ReentParser::ModAssign);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(3001);
      match(ReentParser::XorAssign);
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(3002);
      match(ReentParser::AndAssign);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(3003);
      match(ReentParser::OrAssign);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(3004);
      match(ReentParser::Less);
      setState(3005);
      match(ReentParser::Less);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(3006);
      match(ReentParser::Greater);
      setState(3007);
      match(ReentParser::Greater);
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(3008);
      match(ReentParser::RightShiftAssign);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(3009);
      match(ReentParser::LeftShiftAssign);
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(3010);
      match(ReentParser::Equal);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(3011);
      match(ReentParser::NotEqual);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(3012);
      match(ReentParser::LessEqual);
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(3013);
      match(ReentParser::AndAnd);
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(3014);
      match(ReentParser::OrOr);
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(3015);
      match(ReentParser::PlusPlus);
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(3016);
      match(ReentParser::MinusMinus);
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(3017);
      match(ReentParser::Comma);
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(3018);
      match(ReentParser::ArrowStar);
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(3019);
      match(ReentParser::Arrow);
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(3020);
      match(ReentParser::LeftParen);
      setState(3021);
      match(ReentParser::RightParen);
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(3022);
      match(ReentParser::LeftBracket);
      setState(3023);
      match(ReentParser::RightBracket);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

ReentParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* ReentParser::LiteralContext::IntegerLiteral() {
  return getToken(ReentParser::IntegerLiteral, 0);
}

tree::TerminalNode* ReentParser::LiteralContext::CharacterLiteral() {
  return getToken(ReentParser::CharacterLiteral, 0);
}

tree::TerminalNode* ReentParser::LiteralContext::FloatingLiteral() {
  return getToken(ReentParser::FloatingLiteral, 0);
}

tree::TerminalNode* ReentParser::LiteralContext::StringLiteral() {
  return getToken(ReentParser::StringLiteral, 0);
}

tree::TerminalNode* ReentParser::LiteralContext::BooleanLiteral() {
  return getToken(ReentParser::BooleanLiteral, 0);
}

tree::TerminalNode* ReentParser::LiteralContext::PointerLiteral() {
  return getToken(ReentParser::PointerLiteral, 0);
}

tree::TerminalNode* ReentParser::LiteralContext::UserDefinedLiteral() {
  return getToken(ReentParser::UserDefinedLiteral, 0);
}


size_t ReentParser::LiteralContext::getRuleIndex() const {
  return ReentParser::RuleLiteral;
}

void ReentParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void ReentParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<ReentParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

ReentParser::LiteralContext* ReentParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 566, ReentParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3026);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << ReentParser::IntegerLiteral)
      | (1ULL << ReentParser::CharacterLiteral)
      | (1ULL << ReentParser::FloatingLiteral)
      | (1ULL << ReentParser::StringLiteral)
      | (1ULL << ReentParser::BooleanLiteral)
      | (1ULL << ReentParser::PointerLiteral)
      | (1ULL << ReentParser::UserDefinedLiteral))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool ReentParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 4: return reent_funs_idSempred(dynamic_cast<Reent_funs_idContext *>(context), predicateIndex);
    case 5: return chain_funs_idSempred(dynamic_cast<Chain_funs_idContext *>(context), predicateIndex);
    case 8: return nestedNameSpecifierSempred(dynamic_cast<NestedNameSpecifierContext *>(context), predicateIndex);
    case 18: return postfixExpressionSempred(dynamic_cast<PostfixExpressionContext *>(context), predicateIndex);
    case 28: return noPointerNewDeclaratorSempred(dynamic_cast<NoPointerNewDeclaratorContext *>(context), predicateIndex);
    case 58: return reent_statementSempred(dynamic_cast<Reent_statementContext *>(context), predicateIndex);
    case 59: return chain_statementSempred(dynamic_cast<Chain_statementContext *>(context), predicateIndex);
    case 60: return atomic_blockSempred(dynamic_cast<Atomic_blockContext *>(context), predicateIndex);
    case 89: return vector_chain_descriptorSempred(dynamic_cast<Vector_chain_descriptorContext *>(context), predicateIndex);
    case 176: return noPointerDeclaratorSempred(dynamic_cast<NoPointerDeclaratorContext *>(context), predicateIndex);
    case 187: return noPointerAbstractDeclaratorSempred(dynamic_cast<NoPointerAbstractDeclaratorContext *>(context), predicateIndex);
    case 189: return noPointerAbstractPackDeclaratorSempred(dynamic_cast<NoPointerAbstractPackDeclaratorContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool ReentParser::reent_funs_idSempred(Reent_funs_idContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return (in_reenterable || in_chain);

  default:
    break;
  }
  return true;
}

bool ReentParser::chain_funs_idSempred(Chain_funs_idContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1: return in_chain;

  default:
    break;
  }
  return true;
}

bool ReentParser::nestedNameSpecifierSempred(NestedNameSpecifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool ReentParser::postfixExpressionSempred(PostfixExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 3: return precpred(_ctx, 8);
    case 4: return precpred(_ctx, 7);
    case 5: return precpred(_ctx, 4);
    case 6: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool ReentParser::noPointerNewDeclaratorSempred(NoPointerNewDeclaratorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool ReentParser::reent_statementSempred(Reent_statementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return (in_reenterable || in_chain);

  default:
    break;
  }
  return true;
}

bool ReentParser::chain_statementSempred(Chain_statementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return in_chain;

  default:
    break;
  }
  return true;
}

bool ReentParser::atomic_blockSempred(Atomic_blockContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10: return (!in_reenterable && !in_chain);

  default:
    break;
  }
  return true;
}

bool ReentParser::vector_chain_descriptorSempred(Vector_chain_descriptorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return  chains.find((dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident != nullptr ? _input->getText(dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident->start, dynamic_cast<Vector_chain_descriptorContext *>(_localctx)->ident->stop) : nullptr)) == chains.end() ;

  default:
    break;
  }
  return true;
}

bool ReentParser::noPointerDeclaratorSempred(NoPointerDeclaratorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool ReentParser::noPointerAbstractDeclaratorSempred(NoPointerAbstractDeclaratorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

bool ReentParser::noPointerAbstractPackDeclaratorSempred(NoPointerAbstractPackDeclaratorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> ReentParser::_decisionToDFA;
atn::PredictionContextCache ReentParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN ReentParser::_atn;
std::vector<uint16_t> ReentParser::_serializedATN;

std::vector<std::string> ReentParser::_ruleNames = {
  "translationUnit", "anyIdentifier", "primaryExpression", "idExpression", 
  "reent_funs_id", "chain_funs_id", "unqualifiedId", "qualifiedId", "nestedNameSpecifier", 
  "lambdaExpression", "lambdaIntroducer", "lambdaCapture", "captureDefault", 
  "captureList", "capture", "simpleCapture", "initcapture", "lambdaDeclarator", 
  "postfixExpression", "typeIdOfTheTypeId", "expressionList", "pseudoDestructorName", 
  "unaryExpression", "unaryOperator", "newExpression", "newPlacement", "newTypeId", 
  "newDeclarator", "noPointerNewDeclarator", "newInitializer", "deleteExpression", 
  "noExceptExpression", "castExpression", "pointerMemberExpression", "multiplicativeExpression", 
  "additiveExpression", "shiftExpression", "shiftOperator", "relationalExpression", 
  "equalityExpression", "andExpression", "exclusiveOrExpression", "inclusiveOrExpression", 
  "logicalAndExpression", "logicalOrExpression", "conditionalExpression", 
  "assignmentExpression", "assignmentOperator", "expression", "constantExpression", 
  "statement", "labeledStatement", "cilk_sync", "fill_into_plan", "fill_from_plan", 
  "reent_filler", "reent_reader", "reent_filler_array", "reent_statement", 
  "chain_statement", "atomic_block", "soft_atomic_block", "plan_first", 
  "plan_get_first", "plan_last", "plan_get_last", "plan_register", "plan_registered_barrier", 
  "plan_critical", "plan_stop", "clear_plan", "plan_group_first", "plan_group_last", 
  "plan_group_parallelize", "plan_group_atomize", "plan_group_soft_atomize", 
  "plan_group_vectorize", "throw_first", "throw_last", "planning_params", 
  "reent_parameter_cut", "reent_special_call", "reent_continue_any_call", 
  "reent_compact_continue", "reent_np_call", "start_chain", "start_single_proc_chain", 
  "start_multi_proc_chain", "chain_descriptor", "vector_chain_descriptor", 
  "list_chain_descriptor", "start_topology", "topology_item", "topology_line", 
  "topology_reverse", "topology_node", "chain_call", "qualified_call_statement", 
  "spawned_call_statement", "expressionStatement", "compoundStatement", 
  "statementSeq", "selectionStatement", "condition", "iterationStatement", 
  "forInitStatement", "forRangeDeclaration", "forRangeInitializer", "jumpStatement", 
  "declarationStatement", "declarationseq", "declaration", "blockDeclaration", 
  "aliasDeclaration", "simpleDeclaration", "staticAssertDeclaration", "emptyDeclaration", 
  "attributeDeclaration", "declSpecifier", "declSpecifierSeq", "reent_special_type", 
  "reent_funnel_type", "reent_cfunnel_type", "reent_cvar_type", "reent_csem_type", 
  "reent_soft_transact_array", "reent_soft_transact_var", "reent_soft_transact_in", 
  "reent_soft_transact_out", "reent_plan_type", "reent_plan_item_type", 
  "storageClassSpecifier", "functionSpecifier", "typedefName", "typeSpecifier", 
  "trailingTypeSpecifier", "typeSpecifierSeq", "trailingTypeSpecifierSeq", 
  "simpleTypeLengthModifier", "simpleTypeSignednessModifier", "simpleTypeSpecifier", 
  "theTypeName", "decltypeSpecifier", "elaboratedTypeSpecifier", "enumName", 
  "enumSpecifier", "enumHead", "opaqueEnumDeclaration", "enumkey", "enumbase", 
  "enumeratorList", "enumeratorDefinition", "enumerator", "namespaceName", 
  "originalNamespaceName", "namespaceDefinition", "namespaceAlias", "namespaceAliasDefinition", 
  "qualifiednamespacespecifier", "usingDeclaration", "usingDirective", "asmDefinition", 
  "linkageSpecification", "attributeSpecifierSeq", "attributeSpecifier", 
  "alignmentspecifier", "attributeList", "attribute", "attributeNamespace", 
  "attributeArgumentClause", "balancedTokenSeq", "balancedtoken", "initDeclaratorList", 
  "initDeclarator", "declarator", "pointerDeclarator", "noPointerDeclarator", 
  "parametersAndQualifiers", "trailingReturnType", "pointerOperator", "cvqualifierseq", 
  "cvQualifier", "refqualifier", "declaratorid", "theTypeId", "abstractDeclarator", 
  "pointerAbstractDeclarator", "noPointerAbstractDeclarator", "abstractPackDeclarator", 
  "noPointerAbstractPackDeclarator", "parameterDeclarationClause", "parameterDeclarationList", 
  "parameterDeclaration", "reenterableDefinition", "reenterableDeclaration", 
  "reenterableHead", "reent_chain_header", "reent_chain_params", "reent_chain_param", 
  "reent_recursive_type", "reent_reduction", "reent_gpu_global", "reent_gpu_local", 
  "reduction_symbol", "reent_chain_predicate", "reent_predicate_set", "reent_predicate_reset", 
  "reent_predicate_depends", "reent_predicate_if", "reent_dependents", "reent_enumerator", 
  "loop_statement_header", "reent_single_dependent", "chain_interface", 
  "chainDefinition", "chainDeclaration", "chainHead", "functionDefinition", 
  "special_method_name", "functionBody", "initializer", "braceOrEqualInitializer", 
  "initializerClause", "initializerList", "bracedInitList", "className", 
  "classSpecifier", "classHead", "classHeadName", "classVirtSpecifier", 
  "classKey", "memberSpecification", "markedmemberdeclaration", "memberdeclaration", 
  "memberDeclaratorList", "memberDeclarator", "virtualSpecifierSeq", "virtualSpecifier", 
  "pureSpecifier", "baseClause", "baseSpecifierList", "baseSpecifier", "classOrDeclType", 
  "baseTypeSpecifier", "accessSpecifier", "conversionFunctionId", "conversionTypeId", 
  "conversionDeclarator", "constructorInitializer", "memInitializerList", 
  "memInitializer", "meminitializerid", "operatorFunctionId", "literalOperatorId", 
  "templateDeclaration", "templateparameterList", "templateParameter", "typeParameter", 
  "simpleTemplateId", "templateId", "templateName", "templateArgumentList", 
  "templateArgument", "typeNameSpecifier", "explicitInstantiation", "explicitSpecialization", 
  "tryBlock", "functionTryBlock", "handlerSeq", "handler", "exceptionDeclaration", 
  "throwExpression", "exceptionSpecification", "dynamicExceptionSpecification", 
  "typeIdList", "noeExceptSpecification", "plan_pragma", "plan_directive", 
  "plan_dir_vectorized", "plan_dir_clustered", "plan_common", "plan_gpu", 
  "theOperator", "literal"
};

std::vector<std::string> ReentParser::_literalNames = {
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'alignas'", 
  "'alignof'", "'asm'", "'auto'", "'begin'", "'bool'", "'break'", "'case'", 
  "'catch'", "'cfunnel'", "'chain'", "'char'", "'char16_t'", "'char32_t'", 
  "'cilk_for'", "'_Cilk_for'", "'cilk_spawn'", "'_Cilk_spawn'", "'cilk_sync'", 
  "'_Cilk_sync'", "'class'", "'clear_plan'", "'clustered'", "'common'", 
  "'const'", "'constexpr'", "'const_cast'", "'continue'", "'plan_csem_t'", 
  "'cvar'", "'decltype'", "'default'", "'delete'", "'depends'", "'do'", 
  "'double'", "'dynamic_cast'", "'else'", "'end'", "'enum'", "'explicit'", 
  "'export'", "'extern'", "'false'", "'final'", "'float'", "'for'", "'friend'", 
  "'funnel'", "'global'", "'gpu'", "'goto'", "'_global'", "'_local'", "'id'", 
  "'if'", "'in'", "'inline'", "'int'", "'local'", "'long'", "'pre_id'", 
  "'state'", "'markupdef'", "'mutable'", "'namespace'", "'new'", "'noexcept'", 
  "'nullptr'", "'operator'", "'out'", "'override'", "'plan'", "'plan_atomize'", 
  "'plan_chain'", "'plan_critical'", "'plan_first'", "'plan_get_first'", 
  "'plan_get_last'", "'plan_group_atomize'", "'plan_group_first'", "'plan_group_last'", 
  "'plan_group_parallelize'", "'plan_group_soft_atomize'", "'plan_group_vectorize'", 
  "'plan_item_type'", "'plan_last'", "'plan_parallel_chain'", "'plan_parallel_reverse'", 
  "'plan_register'", "'plan_registered_barrier'", "'plan_stop'", "'plan_topology'", 
  "'plan_type'", "'private'", "'protected'", "'public'", "'reduction'", 
  "'reenterable'", "'register'", "'reinterpret_cast'", "'reset'", "'return'", 
  "'set'", "'short'", "'signed'", "'sizeof'", "'soft_transact_array'", "'soft_transact_in'", 
  "'soft_transact_out'", "'soft_transact_var'", "'static'", "'static_assert'", 
  "'static_cast'", "'struct'", "'switch'", "'template'", "'this'", "'thread_local'", 
  "'throw'", "'throw_first'", "'throw_last'", "'transaction_atomic'", "'true'", 
  "'try'", "'typedef'", "'typeid'", "'typename'", "'union'", "'unsigned'", 
  "'using'", "'vectorized'", "'virtual'", "'void'", "'volatile'", "'wchar_t'", 
  "'while'", "'@'", "'$'", "':-'", "'('", "')'", "'['", "']'", "'{'", "'}'", 
  "'_'", "'+'", "'-'", "'*'", "'/'", "'%'", "'^'", "'&'", "'|'", "'~'", 
  "", "'='", "'<'", "'>'", "'+='", "'-='", "'*='", "'/='", "'%='", "'^='", 
  "'&='", "'|='", "'<<='", "'>>='", "'=='", "'!='", "'<='", "'>='", "", 
  "", "'++'", "'--'", "','", "'->*'", "'->'", "'\u003F'", "':'", "'::'", 
  "';'", "'.'", "'.*'", "'...'"
};

std::vector<std::string> ReentParser::_symbolicNames = {
  "", "IntegerLiteral", "CharacterLiteral", "FloatingLiteral", "StringLiteral", 
  "BooleanLiteral", "PointerLiteral", "UserDefinedLiteral", "PlanPragma", 
  "DoNotCheck", "BlockComment", "OtherPragma", "Line", "MultiLineMacro", 
  "Directive", "Alignas", "Alignof", "Asm", "Auto", "Begin", "Bool", "Break", 
  "Case", "Catch", "Cfunnel", "Chain", "Char", "Char16", "Char32", "Cilk_for", 
  "Cilk_for_", "Cilk_spawn", "Cilk_spawn_", "Cilk_sync", "Cilk_sync_", "Class", 
  "Clear_plan", "Clustered", "Common", "Const", "Constexpr", "Const_cast", 
  "Continue", "Csem", "Cvar", "Decltype", "Default", "Delete", "Depends", 
  "Do", "Double", "Dynamic_cast", "Else", "End", "Enum", "Explicit", "Export", 
  "Extern", "False_", "Final", "Float", "For", "Friend", "Funnel", "Global", 
  "Gpu", "Goto", "GpuGlobal", "GpuLocal", "Id", "If", "In", "Inline", "Int", 
  "Local", "Long", "MarkPreCondition", "MarkState", "Markupdef", "Mutable", 
  "Namespace", "New", "Noexcept", "Nullptr", "Operator", "Out", "Override", 
  "Plan", "Plan_atomize", "Plan_chain", "Plan_critical", "Plan_first", "Plan_get_first", 
  "Plan_get_last", "Plan_group_atomize", "Plan_group_first", "Plan_group_last", 
  "Plan_group_parallelize", "Plan_group_soft_atomize", "Plan_group_vectorize", 
  "Plan_item_type", "Plan_last", "Plan_parallel_chain", "Plan_parallel_reverse", 
  "Plan_register", "Plan_registered_barrier", "Plan_stop", "Plan_topology", 
  "Plan_type", "Private", "Protected", "Public", "Reduction", "Reenterable", 
  "Register", "Reinterpret_cast", "Reset", "Return", "Set", "Short", "Signed", 
  "Sizeof", "Soft_transact_array", "Soft_transact_in", "Soft_transact_out", 
  "Soft_transact_var", "Static", "Static_assert", "Static_cast", "Struct", 
  "Switch", "Template", "This", "Thread_local", "Throw", "Throw_first", 
  "Throw_last", "Transaction_atomic", "True_", "Try", "Typedef", "Typeid_", 
  "Typename_", "Union", "Unsigned", "Using", "Vectorized", "Virtual", "Void", 
  "Volatile", "Wchar", "While", "At", "Dollar", "Is", "LeftParen", "RightParen", 
  "LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "Underscore", 
  "Plus", "Minus", "Star", "Div", "Mod", "Caret", "And", "Or", "Tilde", 
  "Not", "Assign", "Less", "Greater", "PlusAssign", "MinusAssign", "StarAssign", 
  "DivAssign", "ModAssign", "XorAssign", "AndAssign", "OrAssign", "LeftShiftAssign", 
  "RightShiftAssign", "Equal", "NotEqual", "LessEqual", "GreaterEqual", 
  "AndAnd", "OrOr", "PlusPlus", "MinusMinus", "Comma", "ArrowStar", "Arrow", 
  "Question", "Colon", "Doublecolon", "Semi", "Dot", "DotStar", "Ellipsis", 
  "Identifier", "DecimalLiteral", "OctalLiteral", "HexadecimalLiteral", 
  "BinaryLiteral", "Integersuffix", "UserDefinedIntegerLiteral", "UserDefinedFloatingLiteral", 
  "UserDefinedStringLiteral", "UserDefinedCharacterLiteral", "Whitespace", 
  "Newline", "LineComment"
};

dfa::Vocabulary ReentParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> ReentParser::_tokenNames;

ReentParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static const uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0xd9, 0xbd7, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 0x4, 
       0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 0x9, 
       0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 0xa, 
       0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 0x4, 
       0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 0x11, 
       0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 0x14, 
       0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 0x17, 
       0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 0x1a, 
       0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 0x1d, 
       0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 0x20, 
       0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 0x23, 
       0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 0x26, 
       0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 0x29, 
       0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 0x2c, 
       0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 0x2f, 
       0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 0x32, 
       0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 0x35, 
       0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 0x38, 
       0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 0x3b, 
       0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 0x3e, 
       0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 0x41, 
       0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 0x44, 
       0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 0x47, 
       0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 0x4a, 
       0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 0x4d, 
       0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 0x50, 
       0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 0x53, 
       0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 0x56, 
       0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 0x59, 
       0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 0x5c, 
       0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 0x5f, 
       0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 0x62, 
       0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 0x65, 
       0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 0x68, 
       0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 0x6b, 
       0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 0x6e, 
       0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 0x71, 
       0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 0x74, 
       0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 0x77, 
       0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 0x7a, 
       0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 0x7d, 
       0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 0x80, 
       0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 0x83, 
       0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 0x86, 
       0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 0x89, 
       0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 0x8c, 
       0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 0x8f, 
       0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 0x92, 
       0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 0x95, 
       0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 0x98, 
       0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 0x9b, 
       0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 0x9e, 
       0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 0xa1, 
       0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 0xa4, 
       0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 0xa7, 
       0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 0xaa, 
       0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 0xad, 
       0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 0xb0, 
       0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 0xb3, 
       0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 0xb6, 
       0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 0xb9, 
       0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 0xbc, 
       0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 0xbf, 
       0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 0xc2, 
       0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 0xc5, 
       0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 0xc8, 
       0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 0xcb, 
       0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 0xce, 
       0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 0xd1, 
       0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 0xd4, 
       0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 0xd7, 
       0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 0xda, 
       0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 0xdd, 
       0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 0xe0, 
       0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 0xe3, 
       0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 0xe6, 
       0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 0xe9, 
       0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 0xec, 
       0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 0xef, 
       0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 0xf2, 
       0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 0xf5, 
       0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 0xf8, 
       0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 0xfb, 
       0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 0xfe, 
       0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x4, 0x100, 0x9, 0x100, 0x4, 0x101, 
       0x9, 0x101, 0x4, 0x102, 0x9, 0x102, 0x4, 0x103, 0x9, 0x103, 0x4, 
       0x104, 0x9, 0x104, 0x4, 0x105, 0x9, 0x105, 0x4, 0x106, 0x9, 0x106, 
       0x4, 0x107, 0x9, 0x107, 0x4, 0x108, 0x9, 0x108, 0x4, 0x109, 0x9, 
       0x109, 0x4, 0x10a, 0x9, 0x10a, 0x4, 0x10b, 0x9, 0x10b, 0x4, 0x10c, 
       0x9, 0x10c, 0x4, 0x10d, 0x9, 0x10d, 0x4, 0x10e, 0x9, 0x10e, 0x4, 
       0x10f, 0x9, 0x10f, 0x4, 0x110, 0x9, 0x110, 0x4, 0x111, 0x9, 0x111, 
       0x4, 0x112, 0x9, 0x112, 0x4, 0x113, 0x9, 0x113, 0x4, 0x114, 0x9, 
       0x114, 0x4, 0x115, 0x9, 0x115, 0x4, 0x116, 0x9, 0x116, 0x4, 0x117, 
       0x9, 0x117, 0x4, 0x118, 0x9, 0x118, 0x4, 0x119, 0x9, 0x119, 0x4, 
       0x11a, 0x9, 0x11a, 0x4, 0x11b, 0x9, 0x11b, 0x4, 0x11c, 0x9, 0x11c, 
       0x4, 0x11d, 0x9, 0x11d, 0x3, 0x2, 0x5, 0x2, 0x23c, 0xa, 0x2, 0x3, 
       0x2, 0x3, 0x2, 0x3, 0x2, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x6, 0x4, 
       0x244, 0xa, 0x4, 0xd, 0x4, 0xe, 0x4, 0x245, 0x3, 0x4, 0x3, 0x4, 0x3, 
       0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 
       0x5, 0x4, 0x251, 0xa, 0x4, 0x3, 0x5, 0x3, 0x5, 0x5, 0x5, 0x255, 0xa, 
       0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 
       0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x5, 0x8, 0x265, 0xa, 0x8, 0x5, 0x8, 0x267, 0xa, 0x8, 
       0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x26b, 0xa, 0x9, 0x3, 0x9, 0x3, 0x9, 
       0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x5, 0xa, 0x273, 0xa, 0xa, 
       0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x3, 0xa, 0x5, 0xa, 0x27a, 
       0xa, 0xa, 0x3, 0xa, 0x5, 0xa, 0x27d, 0xa, 0xa, 0x3, 0xa, 0x3, 0xa, 
       0x7, 0xa, 0x281, 0xa, 0xa, 0xc, 0xa, 0xe, 0xa, 0x284, 0xb, 0xa, 0x3, 
       0xb, 0x3, 0xb, 0x5, 0xb, 0x288, 0xa, 0xb, 0x3, 0xb, 0x3, 0xb, 0x3, 
       0xc, 0x3, 0xc, 0x5, 0xc, 0x28e, 0xa, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 
       0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x296, 0xa, 0xd, 0x5, 
       0xd, 0x298, 0xa, 0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 
       0xf, 0x7, 0xf, 0x29f, 0xa, 0xf, 0xc, 0xf, 0xe, 0xf, 0x2a2, 0xb, 0xf, 
       0x3, 0xf, 0x5, 0xf, 0x2a5, 0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x5, 0x10, 
       0x2a9, 0xa, 0x10, 0x3, 0x11, 0x5, 0x11, 0x2ac, 0xa, 0x11, 0x3, 0x11, 
       0x3, 0x11, 0x5, 0x11, 0x2b0, 0xa, 0x11, 0x3, 0x12, 0x5, 0x12, 0x2b3, 
       0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x13, 0x3, 0x13, 
       0x5, 0x13, 0x2ba, 0xa, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2be, 
       0xa, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2c1, 0xa, 0x13, 0x3, 0x13, 0x5, 
       0x13, 0x2c4, 0xa, 0x13, 0x3, 0x13, 0x5, 0x13, 0x2c7, 0xa, 0x13, 0x3, 
       0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2cd, 0xa, 0x14, 
       0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2de, 0xa, 0x14, 0x3, 
       0x14, 0x3, 0x14, 0x5, 0x14, 0x2e2, 0xa, 0x14, 0x3, 0x14, 0x3, 0x14, 
       0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2e8, 0xa, 0x14, 0x3, 0x14, 0x3, 
       0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2ef, 0xa, 0x14, 
       0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2f5, 0xa, 
       0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x2fb, 
       0xa, 0x14, 0x3, 0x14, 0x3, 0x14, 0x7, 0x14, 0x2ff, 0xa, 0x14, 0xc, 
       0x14, 0xe, 0x14, 0x302, 0xb, 0x14, 0x3, 0x15, 0x3, 0x15, 0x3, 0x16, 
       0x3, 0x16, 0x3, 0x17, 0x5, 0x17, 0x309, 0xa, 0x17, 0x3, 0x17, 0x3, 
       0x17, 0x3, 0x17, 0x5, 0x17, 0x30e, 0xa, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 
       0x3, 0x17, 0x3, 0x17, 0x3, 0x17, 0x5, 0x17, 0x31b, 0xa, 0x17, 0x3, 
       0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 
       0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 0x328, 
       0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 
       0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 
       0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 0x337, 0xa, 0x18, 0x3, 0x19, 0x3, 
       0x19, 0x3, 0x1a, 0x5, 0x1a, 0x33c, 0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 
       0x5, 0x1a, 0x340, 0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x3, 
       0x1a, 0x3, 0x1a, 0x5, 0x1a, 0x347, 0xa, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 
       0x34a, 0xa, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x3, 
       0x1c, 0x3, 0x1c, 0x5, 0x1c, 0x352, 0xa, 0x1c, 0x3, 0x1d, 0x3, 0x1d, 
       0x5, 0x1d, 0x356, 0xa, 0x1d, 0x3, 0x1d, 0x5, 0x1d, 0x359, 0xa, 0x1d, 
       0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 
       0x360, 0xa, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 0x1e, 0x3, 
       0x1e, 0x5, 0x1e, 0x367, 0xa, 0x1e, 0x7, 0x1e, 0x369, 0xa, 0x1e, 0xc, 
       0x1e, 0xe, 0x1e, 0x36c, 0xb, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 
       0x370, 0xa, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 0x374, 0xa, 0x1f, 
       0x3, 0x20, 0x5, 0x20, 0x377, 0xa, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 
       0x20, 0x5, 0x20, 0x37c, 0xa, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x21, 
       0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x22, 0x3, 0x22, 
       0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x38b, 0xa, 
       0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x23, 0x7, 0x23, 0x390, 0xa, 0x23, 
       0xc, 0x23, 0xe, 0x23, 0x393, 0xb, 0x23, 0x3, 0x24, 0x3, 0x24, 0x3, 
       0x24, 0x7, 0x24, 0x398, 0xa, 0x24, 0xc, 0x24, 0xe, 0x24, 0x39b, 0xb, 
       0x24, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x7, 0x25, 0x3a0, 0xa, 0x25, 
       0xc, 0x25, 0xe, 0x25, 0x3a3, 0xb, 0x25, 0x3, 0x26, 0x3, 0x26, 0x3, 
       0x26, 0x3, 0x26, 0x7, 0x26, 0x3a9, 0xa, 0x26, 0xc, 0x26, 0xe, 0x26, 
       0x3ac, 0xb, 0x26, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x5, 
       0x27, 0x3b2, 0xa, 0x27, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x7, 0x28, 
       0x3b7, 0xa, 0x28, 0xc, 0x28, 0xe, 0x28, 0x3ba, 0xb, 0x28, 0x3, 0x29, 
       0x3, 0x29, 0x3, 0x29, 0x7, 0x29, 0x3bf, 0xa, 0x29, 0xc, 0x29, 0xe, 
       0x29, 0x3c2, 0xb, 0x29, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x7, 0x2a, 
       0x3c7, 0xa, 0x2a, 0xc, 0x2a, 0xe, 0x2a, 0x3ca, 0xb, 0x2a, 0x3, 0x2b, 
       0x3, 0x2b, 0x3, 0x2b, 0x7, 0x2b, 0x3cf, 0xa, 0x2b, 0xc, 0x2b, 0xe, 
       0x2b, 0x3d2, 0xb, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x7, 0x2c, 
       0x3d7, 0xa, 0x2c, 0xc, 0x2c, 0xe, 0x2c, 0x3da, 0xb, 0x2c, 0x3, 0x2d, 
       0x3, 0x2d, 0x3, 0x2d, 0x7, 0x2d, 0x3df, 0xa, 0x2d, 0xc, 0x2d, 0xe, 
       0x2d, 0x3e2, 0xb, 0x2d, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x7, 0x2e, 
       0x3e7, 0xa, 0x2e, 0xc, 0x2e, 0xe, 0x2e, 0x3ea, 0xb, 0x2e, 0x3, 0x2f, 
       0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x3, 0x2f, 0x5, 0x2f, 
       0x3f2, 0xa, 0x2f, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 0x30, 0x3, 
       0x30, 0x3, 0x30, 0x5, 0x30, 0x3fa, 0xa, 0x30, 0x3, 0x31, 0x3, 0x31, 
       0x3, 0x32, 0x3, 0x32, 0x3, 0x32, 0x7, 0x32, 0x401, 0xa, 0x32, 0xc, 
       0x32, 0xe, 0x32, 0x404, 0xb, 0x32, 0x3, 0x33, 0x3, 0x33, 0x3, 0x34, 
       0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 
       0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 
       0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x5, 0x34, 0x419, 0xa, 
       0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 
       0x34, 0x5, 0x34, 0x421, 0xa, 0x34, 0x5, 0x34, 0x423, 0xa, 0x34, 0x3, 
       0x35, 0x5, 0x35, 0x426, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 
       0x3, 0x35, 0x5, 0x35, 0x42c, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 
       0x35, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x37, 0x3, 0x37, 0x3, 
       0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 
       0x37, 0x7, 0x37, 0x43d, 0xa, 0x37, 0xc, 0x37, 0xe, 0x37, 0x440, 0xb, 
       0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x37, 0x3, 0x38, 0x3, 0x38, 0x3, 
       0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 
       0x38, 0x7, 0x38, 0x44e, 0xa, 0x38, 0xc, 0x38, 0xe, 0x38, 0x451, 0xb, 
       0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x38, 0x3, 0x39, 0x3, 0x39, 0x3, 
       0x39, 0x5, 0x39, 0x459, 0xa, 0x39, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 
       0x5, 0x3a, 0x45e, 0xa, 0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x6, 
       0x3b, 0x463, 0xa, 0x3b, 0xd, 0x3b, 0xe, 0x3b, 0x464, 0x3, 0x3c, 0x3, 
       0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 
       0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 
       0x3c, 0x5, 0x3c, 0x475, 0xa, 0x3c, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x5, 0x3d, 0x47a, 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x3, 0x3e, 0x3, 
       0x3e, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x3, 
       0x3f, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 
       0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
       0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 
       0x43, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 
       0x44, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 0x45, 0x3, 
       0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 
       0x46, 0x3, 0x47, 0x3, 0x47, 0x3, 0x47, 0x3, 0x48, 0x3, 0x48, 0x3, 
       0x48, 0x3, 0x49, 0x3, 0x49, 0x3, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x3, 
       0x4a, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 0x3, 
       0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 0x3, 
       0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 0x3, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x50, 0x3, 
       0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x50, 0x3, 0x51, 0x3, 
       0x51, 0x5, 0x51, 0x4da, 0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x51, 
       0x5, 0x51, 0x4df, 0xa, 0x51, 0x7, 0x51, 0x4e1, 0xa, 0x51, 0xc, 0x51, 
       0xe, 0x51, 0x4e4, 0xb, 0x51, 0x3, 0x52, 0x3, 0x52, 0x3, 0x53, 0x3, 
       0x53, 0x3, 0x53, 0x5, 0x53, 0x4eb, 0xa, 0x53, 0x3, 0x54, 0x3, 0x54, 
       0x3, 0x54, 0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 0x4f2, 0xa, 0x54, 0x3, 
       0x54, 0x3, 0x54, 0x3, 0x54, 0x5, 0x54, 0x4f7, 0xa, 0x54, 0x3, 0x54, 
       0x3, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 
       0x5, 0x55, 0x500, 0xa, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 
       0x55, 0x5, 0x55, 0x506, 0xa, 0x55, 0x3, 0x55, 0x3, 0x55, 0x3, 0x56, 
       0x3, 0x56, 0x3, 0x56, 0x5, 0x56, 0x50d, 0xa, 0x56, 0x3, 0x56, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x57, 0x3, 
       0x57, 0x5, 0x57, 0x517, 0xa, 0x57, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 
       0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x59, 
       0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x5, 0x59, 
       0x527, 0xa, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 
       0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x5a, 0x3, 0x5a, 0x5, 
       0x5a, 0x533, 0xa, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 0x3, 0x5b, 
       0x3, 0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 0x53d, 0xa, 
       0x5c, 0xc, 0x5c, 0xe, 0x5c, 0x540, 0xb, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 
       0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x548, 0xa, 
       0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x6, 0x5d, 0x54d, 0xa, 0x5d, 
       0xd, 0x5d, 0xe, 0x5d, 0x54e, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 
       0x5d, 0x554, 0xa, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 
       0x5, 0x5e, 0x55a, 0xa, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5f, 0x3, 
       0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x7, 0x5f, 0x563, 0xa, 0x5f, 
       0xc, 0x5f, 0xe, 0x5f, 0x566, 0xb, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 
       0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 
       0x60, 0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x6, 0x61, 0x574, 0xa, 0x61, 
       0xd, 0x61, 0xe, 0x61, 0x575, 0x3, 0x61, 0x5, 0x61, 0x579, 0xa, 0x61, 
       0x3, 0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x57e, 0xa, 0x61, 0x3, 
       0x61, 0x3, 0x61, 0x3, 0x61, 0x5, 0x61, 0x583, 0xa, 0x61, 0x3, 0x62, 
       0x3, 0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 0x62, 0x589, 0xa, 0x62, 0x3, 
       0x62, 0x3, 0x62, 0x3, 0x62, 0x5, 0x62, 0x58e, 0xa, 0x62, 0x3, 0x63, 
       0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x593, 0xa, 0x63, 0x3, 0x63, 0x3, 
       0x63, 0x3, 0x63, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 0x59b, 
       0xa, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x65, 0x5, 0x65, 
       0x5a1, 0xa, 0x65, 0x3, 0x65, 0x3, 0x65, 0x3, 0x66, 0x3, 0x66, 0x5, 
       0x66, 0x5a7, 0xa, 0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x67, 0x6, 0x67, 
       0x5ac, 0xa, 0x67, 0xd, 0x67, 0xe, 0x67, 0x5ad, 0x3, 0x68, 0x3, 0x68, 
       0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x5, 0x68, 
       0x5b7, 0xa, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 0x3, 
       0x68, 0x3, 0x68, 0x5, 0x68, 0x5bf, 0xa, 0x68, 0x3, 0x69, 0x3, 0x69, 
       0x5, 0x69, 0x5c3, 0xa, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x5, 0x69, 0x5ca, 0xa, 0x69, 0x5, 0x69, 0x5cc, 0xa, 
       0x69, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 
       0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 
       0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 
       0x6a, 0x5, 0x6a, 0x5e0, 0xa, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 
       0x5e4, 0xa, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 
       0x6a, 0x5ea, 0xa, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 
       0x5ef, 0xa, 0x6a, 0x3, 0x6b, 0x3, 0x6b, 0x5, 0x6b, 0x5f3, 0xa, 0x6b, 
       0x3, 0x6c, 0x5, 0x6c, 0x5f6, 0xa, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x3, 
       0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x5, 0x6d, 0x5fd, 0xa, 0x6d, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x604, 0xa, 
       0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x5, 0x6e, 0x608, 0xa, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x70, 0x6, 0x70, 0x60f, 0xa, 
       0x70, 0xd, 0x70, 0xe, 0x70, 0x610, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 
       0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 
       0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x5, 0x71, 
       0x621, 0xa, 0x71, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x3, 0x72, 0x5, 0x72, 0x62b, 0xa, 0x72, 
       0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0x630, 0xa, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x74, 0x3, 0x74, 0x5, 
       0x74, 0x638, 0xa, 0x74, 0x5, 0x74, 0x63a, 0xa, 0x74, 0x3, 0x74, 0x3, 
       0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x5, 0x74, 0x642, 
       0xa, 0x74, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 
       0x3, 0x75, 0x3, 0x75, 0x3, 0x75, 0x3, 0x76, 0x3, 0x76, 0x3, 0x77, 
       0x3, 0x77, 0x3, 0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 
       0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x5, 0x78, 0x658, 0xa, 0x78, 0x3, 
       0x79, 0x6, 0x79, 0x65b, 0xa, 0x79, 0xd, 0x79, 0xe, 0x79, 0x65c, 0x3, 
       0x79, 0x5, 0x79, 0x660, 0xa, 0x79, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 
       0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 0x3, 0x7a, 
       0x3, 0x7a, 0x5, 0x7a, 0x66c, 0xa, 0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x3, 
       0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7c, 0x3, 
       0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 0x7c, 0x3, 
       0x7c, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 
       0x7d, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x3, 
       0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 
       0x80, 0x3, 0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 
       0x81, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 
       0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 0x83, 0x3, 
       0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 
       0x85, 0x3, 0x85, 0x3, 0x86, 0x3, 0x86, 0x3, 0x87, 0x3, 0x87, 0x3, 
       0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 0x6b0, 0xa, 0x88, 
       0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x3, 0x89, 0x5, 0x89, 0x6b6, 0xa, 
       0x89, 0x3, 0x8a, 0x6, 0x8a, 0x6b9, 0xa, 0x8a, 0xd, 0x8a, 0xe, 0x8a, 
       0x6ba, 0x3, 0x8a, 0x5, 0x8a, 0x6be, 0xa, 0x8a, 0x3, 0x8b, 0x6, 0x8b, 
       0x6c1, 0xa, 0x8b, 0xd, 0x8b, 0xe, 0x8b, 0x6c2, 0x3, 0x8b, 0x5, 0x8b, 
       0x6c6, 0xa, 0x8b, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8d, 0x3, 0x8d, 0x3, 
       0x8e, 0x5, 0x8e, 0x6cd, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 
       0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x6d6, 0xa, 
       0x8e, 0x3, 0x8e, 0x6, 0x8e, 0x6d9, 0xa, 0x8e, 0xd, 0x8e, 0xe, 0x8e, 
       0x6da, 0x3, 0x8e, 0x5, 0x8e, 0x6de, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 
       0x5, 0x8e, 0x6e2, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x6e6, 
       0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x6ea, 0xa, 0x8e, 0x3, 
       0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x6ef, 0xa, 0x8e, 0x3, 0x8e, 
       0x7, 0x8e, 0x6f2, 0xa, 0x8e, 0xc, 0x8e, 0xe, 0x8e, 0x6f5, 0xb, 0x8e, 
       0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x6fa, 0xa, 0x8e, 0x3, 
       0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0x700, 0xa, 0x8e, 
       0x3, 0x8f, 0x3, 0x8f, 0x3, 0x8f, 0x5, 0x8f, 0x705, 0xa, 0x8f, 0x3, 
       0x90, 0x3, 0x90, 0x3, 0x90, 0x3, 0x90, 0x5, 0x90, 0x70b, 0xa, 0x90, 
       0x3, 0x90, 0x3, 0x90, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 0x711, 0xa, 
       0x91, 0x3, 0x91, 0x5, 0x91, 0x714, 0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 
       0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 0x71a, 0xa, 0x91, 0x3, 0x91, 0x3, 
       0x91, 0x5, 0x91, 0x71e, 0xa, 0x91, 0x3, 0x91, 0x3, 0x91, 0x5, 0x91, 
       0x722, 0xa, 0x91, 0x3, 0x91, 0x5, 0x91, 0x725, 0xa, 0x91, 0x3, 0x92, 
       0x3, 0x92, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 
       0x72d, 0xa, 0x93, 0x5, 0x93, 0x72f, 0xa, 0x93, 0x3, 0x93, 0x3, 0x93, 
       0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0x735, 0xa, 0x94, 0x3, 0x94, 0x5, 
       0x94, 0x738, 0xa, 0x94, 0x3, 0x94, 0x5, 0x94, 0x73b, 0xa, 0x94, 0x3, 
       0x94, 0x5, 0x94, 0x73e, 0xa, 0x94, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 
       0x742, 0xa, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0x746, 0xa, 0x95, 
       0x3, 0x95, 0x3, 0x95, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0x74c, 0xa, 
       0x96, 0x3, 0x97, 0x3, 0x97, 0x3, 0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 
       0x98, 0x7, 0x98, 0x754, 0xa, 0x98, 0xc, 0x98, 0xe, 0x98, 0x757, 0xb, 
       0x98, 0x3, 0x99, 0x3, 0x99, 0x3, 0x99, 0x5, 0x99, 0x75c, 0xa, 0x99, 
       0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9b, 0x3, 0x9b, 0x5, 0x9b, 0x762, 0xa, 
       0x9b, 0x3, 0x9c, 0x3, 0x9c, 0x3, 0x9d, 0x5, 0x9d, 0x767, 0xa, 0x9d, 
       0x3, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 0x5, 0x9d, 0x76c, 0xa, 0x9d, 0x3, 
       0x9d, 0x3, 0x9d, 0x5, 0x9d, 0x770, 0xa, 0x9d, 0x3, 0x9d, 0x3, 0x9d, 
       0x3, 0x9e, 0x3, 0x9e, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 
       0x3, 0x9f, 0x3, 0x9f, 0x3, 0xa0, 0x5, 0xa0, 0x77d, 0xa, 0xa0, 0x3, 
       0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x5, 0xa1, 0x783, 0xa, 0xa1, 
       0x3, 0xa1, 0x3, 0xa1, 0x5, 0xa1, 0x787, 0xa, 0xa1, 0x3, 0xa1, 0x3, 
       0xa1, 0x3, 0xa1, 0x3, 0xa2, 0x5, 0xa2, 0x78d, 0xa, 0xa2, 0x3, 0xa2, 
       0x3, 0xa2, 0x3, 0xa2, 0x5, 0xa2, 0x792, 0xa, 0xa2, 0x3, 0xa2, 0x3, 
       0xa2, 0x3, 0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 
       0xa3, 0x3, 0xa3, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 
       0xa4, 0x7a1, 0xa, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x5, 0xa4, 0x7a5, 0xa, 
       0xa4, 0x3, 0xa5, 0x6, 0xa5, 0x7a8, 0xa, 0xa5, 0xd, 0xa5, 0xe, 0xa5, 
       0x7a9, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x5, 0xa6, 0x7af, 0xa, 0xa6, 
       0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x5, 0xa6, 0x7b4, 0xa, 0xa6, 0x3, 
       0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x5, 0xa7, 0x7ba, 0xa, 0xa7, 
       0x3, 0xa7, 0x5, 0xa7, 0x7bd, 0xa, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 
       0xa8, 0x3, 0xa8, 0x3, 0xa8, 0x7, 0xa8, 0x7c4, 0xa, 0xa8, 0xc, 0xa8, 
       0xe, 0xa8, 0x7c7, 0xb, 0xa8, 0x3, 0xa8, 0x5, 0xa8, 0x7ca, 0xa, 0xa8, 
       0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x5, 0xa9, 0x7cf, 0xa, 0xa9, 0x3, 
       0xa9, 0x3, 0xa9, 0x5, 0xa9, 0x7d3, 0xa, 0xa9, 0x3, 0xaa, 0x3, 0xaa, 
       0x3, 0xab, 0x3, 0xab, 0x5, 0xab, 0x7d9, 0xa, 0xab, 0x3, 0xab, 0x3, 
       0xab, 0x3, 0xac, 0x6, 0xac, 0x7de, 0xa, 0xac, 0xd, 0xac, 0xe, 0xac, 
       0x7df, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 
       0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 0xad, 0x3, 
       0xad, 0x3, 0xad, 0x6, 0xad, 0x7ef, 0xa, 0xad, 0xd, 0xad, 0xe, 0xad, 
       0x7f0, 0x5, 0xad, 0x7f3, 0xa, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 
       0x7, 0xae, 0x7f8, 0xa, 0xae, 0xc, 0xae, 0xe, 0xae, 0x7fb, 0xb, 0xae, 
       0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 0x7ff, 0xa, 0xaf, 0x3, 0xb0, 0x3, 
       0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 0x5, 0xb0, 0x806, 0xa, 0xb0, 
       0x3, 0xb1, 0x3, 0xb1, 0x5, 0xb1, 0x80a, 0xa, 0xb1, 0x7, 0xb1, 0x80c, 
       0xa, 0xb1, 0xc, 0xb1, 0xe, 0xb1, 0x80f, 0xb, 0xb1, 0x3, 0xb1, 0x3, 
       0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x816, 0xa, 0xb2, 
       0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x81c, 0xa, 
       0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x822, 
       0xa, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x5, 0xb2, 0x826, 0xa, 0xb2, 0x5, 
       0xb2, 0x828, 0xa, 0xb2, 0x7, 0xb2, 0x82a, 0xa, 0xb2, 0xc, 0xb2, 0xe, 
       0xb2, 0x82d, 0xb, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x831, 0xa, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x835, 0xa, 0xb3, 0x3, 0xb3, 
       0x5, 0xb3, 0x838, 0xa, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0x83b, 0xa, 0xb3, 
       0x3, 0xb3, 0x5, 0xb3, 0x83e, 0xa, 0xb3, 0x3, 0xb4, 0x3, 0xb4, 0x3, 
       0xb4, 0x5, 0xb4, 0x843, 0xa, 0xb4, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 
       0x847, 0xa, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0x84a, 0xa, 0xb5, 0x3, 0xb5, 
       0x3, 0xb5, 0x5, 0xb5, 0x84e, 0xa, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0x851, 
       0xa, 0xb5, 0x5, 0xb5, 0x853, 0xa, 0xb5, 0x3, 0xb6, 0x6, 0xb6, 0x856, 
       0xa, 0xb6, 0xd, 0xb6, 0xe, 0xb6, 0x857, 0x3, 0xb7, 0x3, 0xb7, 0x3, 
       0xb8, 0x3, 0xb8, 0x3, 0xb9, 0x5, 0xb9, 0x85f, 0xa, 0xb9, 0x3, 0xb9, 
       0x3, 0xb9, 0x3, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0x866, 0xa, 
       0xba, 0x3, 0xbb, 0x3, 0xbb, 0x5, 0xbb, 0x86a, 0xa, 0xbb, 0x3, 0xbb, 
       0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x5, 0xbb, 0x870, 0xa, 0xbb, 0x3, 
       0xbc, 0x3, 0xbc, 0x6, 0xbc, 0x874, 0xa, 0xbc, 0xd, 0xbc, 0xe, 0xbc, 
       0x875, 0x3, 0xbc, 0x5, 0xbc, 0x879, 0xa, 0xbc, 0x5, 0xbc, 0x87b, 
       0xa, 0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 
       0x881, 0xa, 0xbd, 0x3, 0xbd, 0x6, 0xbd, 0x884, 0xa, 0xbd, 0xd, 0xbd, 
       0xe, 0xbd, 0x885, 0x3, 0xbd, 0x5, 0xbd, 0x889, 0xa, 0xbd, 0x3, 0xbd, 
       0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 0x88f, 0xa, 0xbd, 0x3, 
       0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 0x896, 
       0xa, 0xbd, 0x3, 0xbd, 0x6, 0xbd, 0x899, 0xa, 0xbd, 0xd, 0xbd, 0xe, 
       0xbd, 0x89a, 0x3, 0xbd, 0x5, 0xbd, 0x89e, 0xa, 0xbd, 0x5, 0xbd, 0x8a0, 
       0xa, 0xbd, 0x7, 0xbd, 0x8a2, 0xa, 0xbd, 0xc, 0xbd, 0xe, 0xbd, 0x8a5, 
       0xb, 0xbd, 0x3, 0xbe, 0x7, 0xbe, 0x8a8, 0xa, 0xbe, 0xc, 0xbe, 0xe, 
       0xbe, 0x8ab, 0xb, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbf, 0x3, 0xbf, 
       0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x5, 0xbf, 
       0x8b6, 0xa, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x5, 0xbf, 0x8ba, 0xa, 0xbf, 
       0x5, 0xbf, 0x8bc, 0xa, 0xbf, 0x7, 0xbf, 0x8be, 0xa, 0xbf, 0xc, 0xbf, 
       0xe, 0xbf, 0x8c1, 0xb, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0x8c5, 
       0xa, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0x8c8, 0xa, 0xc0, 0x3, 0xc1, 0x3, 
       0xc1, 0x3, 0xc1, 0x7, 0xc1, 0x8cd, 0xa, 0xc1, 0xc, 0xc1, 0xe, 0xc1, 
       0x8d0, 0xb, 0xc1, 0x3, 0xc2, 0x5, 0xc2, 0x8d3, 0xa, 0xc2, 0x3, 0xc2, 
       0x3, 0xc2, 0x3, 0xc2, 0x5, 0xc2, 0x8d8, 0xa, 0xc2, 0x5, 0xc2, 0x8da, 
       0xa, 0xc2, 0x3, 0xc2, 0x3, 0xc2, 0x5, 0xc2, 0x8de, 0xa, 0xc2, 0x3, 
       0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc4, 0x3, 
       0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 0x3, 
       0xc5, 0x3, 0xc5, 0x5, 0xc5, 0x8ee, 0xa, 0xc5, 0x3, 0xc5, 0x3, 0xc5, 
       0x3, 0xc5, 0x5, 0xc5, 0x8f3, 0xa, 0xc5, 0x5, 0xc5, 0x8f5, 0xa, 0xc5, 
       0x3, 0xc5, 0x3, 0xc5, 0x7, 0xc5, 0x8f9, 0xa, 0xc5, 0xc, 0xc5, 0xe, 
       0xc5, 0x8fc, 0xb, 0xc5, 0x3, 0xc6, 0x5, 0xc6, 0x8ff, 0xa, 0xc6, 0x3, 
       0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 0xc6, 0x905, 0xa, 0xc6, 
       0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 0x3, 0xc7, 
       0x7, 0xc7, 0x90d, 0xa, 0xc7, 0xc, 0xc7, 0xe, 0xc7, 0x910, 0xb, 0xc7, 
       0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0x916, 0xa, 
       0xc8, 0x3, 0xc8, 0x5, 0xc8, 0x919, 0xa, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
       0x3, 0xc8, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xc9, 
       0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xca, 0x5, 0xca, 0x927, 0xa, 
       0xca, 0x3, 0xca, 0x3, 0xca, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x3, 
       0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 
       0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcd, 0x3, 0xcd, 0x3, 
       0xce, 0x3, 0xce, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0x93e, 0xa, 0xce, 
       0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xd0, 
       0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 
       0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 
       0x5, 0xd2, 0x952, 0xa, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 0xd2, 0x3, 
       0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x7, 
       0xd3, 0x95d, 0xa, 0xd3, 0xc, 0xd3, 0xe, 0xd3, 0x960, 0xb, 0xd3, 0x5, 
       0xd3, 0x962, 0xa, 0xd3, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 
       0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 
       0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x5, 0xd5, 0x971, 0xa, 0xd5, 0x3, 
       0xd5, 0x3, 0xd5, 0x5, 0xd5, 0x975, 0xa, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 
       0x3, 0xd5, 0x3, 0xd5, 0x5, 0xd5, 0x97b, 0xa, 0xd5, 0x3, 0xd5, 0x3, 
       0xd5, 0x5, 0xd5, 0x97f, 0xa, 0xd5, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 
       0x3, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x5, 0xd7, 0x988, 0xa, 
       0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 
       0xd8, 0x3, 0xd8, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 0xd9, 0x3, 
       0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0x99a, 
       0xa, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0x99f, 0xa, 
       0xda, 0x3, 0xda, 0x7, 0xda, 0x9a2, 0xa, 0xda, 0xc, 0xda, 0xe, 0xda, 
       0x9a5, 0xb, 0xda, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0x9aa, 
       0xa, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0x9af, 0xa, 
       0xdb, 0x3, 0xdb, 0x5, 0xdb, 0x9b2, 0xa, 0xdb, 0x3, 0xdb, 0x3, 0xdb, 
       0x5, 0xdb, 0x9b6, 0xa, 0xdb, 0x5, 0xdb, 0x9b8, 0xa, 0xdb, 0x3, 0xdb, 
       0x3, 0xdb, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x5, 0xdc, 0x9bf, 0xa, 
       0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdd, 0x5, 0xdd, 0x9c4, 0xa, 0xdd, 
       0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x5, 0xdd, 
       0x9cb, 0xa, 0xdd, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 
       0xde, 0x5, 0xde, 0x9d2, 0xa, 0xde, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 
       0x5, 0xdf, 0x9d7, 0xa, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 0x5, 0xe0, 0x9db, 
       0xa, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x5, 0xe1, 0x9df, 0xa, 0xe1, 0x3, 
       0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x5, 0xe1, 0x9e4, 0xa, 0xe1, 0x7, 0xe1, 
       0x9e6, 0xa, 0xe1, 0xc, 0xe1, 0xe, 0xe1, 0x9e9, 0xb, 0xe1, 0x3, 0xe2, 
       0x3, 0xe2, 0x3, 0xe2, 0x5, 0xe2, 0x9ee, 0xa, 0xe2, 0x5, 0xe2, 0x9f0, 
       0xa, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe3, 0x3, 0xe3, 0x5, 0xe3, 
       0x9f6, 0xa, 0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x5, 0xe4, 0x9fb, 
       0xa, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 
       0xa01, 0xa, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xa05, 0xa, 0xe5, 
       0x5, 0xe5, 0xa07, 0xa, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xa0a, 0xa, 0xe5, 
       0x3, 0xe5, 0x3, 0xe5, 0x5, 0xe5, 0xa0e, 0xa, 0xe5, 0x3, 0xe5, 0x3, 
       0xe5, 0x5, 0xe5, 0xa12, 0xa, 0xe5, 0x5, 0xe5, 0xa14, 0xa, 0xe5, 0x5, 
       0xe5, 0xa16, 0xa, 0xe5, 0x3, 0xe6, 0x5, 0xe6, 0xa19, 0xa, 0xe6, 0x3, 
       0xe6, 0x3, 0xe6, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe8, 0x3, 0xe8, 0x3, 
       0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x3, 0xe9, 0x6, 0xe9, 0xa26, 
       0xa, 0xe9, 0xd, 0xe9, 0xe, 0xe9, 0xa27, 0x3, 0xea, 0x3, 0xea, 0x3, 
       0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x5, 
       0xea, 0xa32, 0xa, 0xea, 0x3, 0xea, 0x5, 0xea, 0xa35, 0xa, 0xea, 0x3, 
       0xea, 0x3, 0xea, 0x3, 0xea, 0x3, 0xeb, 0x5, 0xeb, 0xa3b, 0xa, 0xeb, 
       0x3, 0xeb, 0x5, 0xeb, 0xa3e, 0xa, 0xeb, 0x3, 0xeb, 0x5, 0xeb, 0xa41, 
       0xa, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 0x3, 0xeb, 
       0x3, 0xeb, 0x3, 0xeb, 0x5, 0xeb, 0xa4a, 0xa, 0xeb, 0x3, 0xec, 0x3, 
       0xec, 0x3, 0xec, 0x7, 0xec, 0xa4f, 0xa, 0xec, 0xc, 0xec, 0xe, 0xec, 
       0xa52, 0xb, 0xec, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xa57, 
       0xa, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xa5b, 0xa, 0xed, 0x5, 
       0xed, 0xa5d, 0xa, 0xed, 0x3, 0xed, 0x5, 0xed, 0xa60, 0xa, 0xed, 0x3, 
       0xed, 0x5, 0xed, 0xa63, 0xa, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 
       0xa67, 0xa, 0xed, 0x3, 0xee, 0x6, 0xee, 0xa6a, 0xa, 0xee, 0xd, 0xee, 
       0xe, 0xee, 0xa6b, 0x3, 0xef, 0x3, 0xef, 0x3, 0xf0, 0x3, 0xf0, 0x3, 
       0xf0, 0x3, 0xf0, 0x3, 0xf1, 0x3, 0xf1, 0x3, 0xf1, 0x3, 0xf2, 0x3, 
       0xf2, 0x5, 0xf2, 0xa79, 0xa, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 
       0x5, 0xf2, 0xa7e, 0xa, 0xf2, 0x7, 0xf2, 0xa80, 0xa, 0xf2, 0xc, 0xf2, 
       0xe, 0xf2, 0xa83, 0xb, 0xf2, 0x3, 0xf3, 0x5, 0xf3, 0xa86, 0xa, 0xf3, 
       0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x5, 0xf3, 0xa8b, 0xa, 0xf3, 0x3, 
       0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x5, 0xf3, 0xa90, 0xa, 0xf3, 0x3, 0xf3, 
       0x3, 0xf3, 0x5, 0xf3, 0xa94, 0xa, 0xf3, 0x3, 0xf4, 0x5, 0xf4, 0xa97, 
       0xa, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x5, 0xf4, 0xa9b, 0xa, 0xf4, 0x3, 
       0xf5, 0x3, 0xf5, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf7, 0x3, 0xf7, 0x3, 
       0xf7, 0x3, 0xf8, 0x3, 0xf8, 0x5, 0xf8, 0xaa6, 0xa, 0xf8, 0x3, 0xf9, 
       0x3, 0xf9, 0x5, 0xf9, 0xaaa, 0xa, 0xf9, 0x3, 0xfa, 0x3, 0xfa, 0x3, 
       0xfa, 0x3, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 0xab1, 0xa, 0xfb, 0x3, 0xfb, 
       0x3, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 0xab6, 0xa, 0xfb, 0x7, 0xfb, 0xab8, 
       0xa, 0xfb, 0xc, 0xfb, 0xe, 0xfb, 0xabb, 0xb, 0xfb, 0x3, 0xfc, 0x3, 
       0xfc, 0x3, 0xfc, 0x5, 0xfc, 0xac0, 0xa, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 
       0x5, 0xfc, 0xac4, 0xa, 0xfc, 0x3, 0xfd, 0x3, 0xfd, 0x5, 0xfd, 0xac8, 
       0xa, 0xfd, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xff, 0x3, 0xff, 
       0x3, 0xff, 0x3, 0xff, 0x5, 0xff, 0xad1, 0xa, 0xff, 0x3, 0x100, 0x3, 
       0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x101, 
       0x3, 0x101, 0x3, 0x101, 0x7, 0x101, 0xadc, 0xa, 0x101, 0xc, 0x101, 
       0xe, 0x101, 0xadf, 0xb, 0x101, 0x3, 0x102, 0x3, 0x102, 0x5, 0x102, 
       0xae3, 0xa, 0x102, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x5, 0x103, 0xaea, 0xa, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x5, 0x103, 0xaee, 0xa, 0x103, 0x3, 0x103, 0x5, 0x103, 0xaf1, 0xa, 
       0x103, 0x3, 0x103, 0x5, 0x103, 0xaf4, 0xa, 0x103, 0x3, 0x103, 0x5, 
       0x103, 0xaf7, 0xa, 0x103, 0x3, 0x103, 0x3, 0x103, 0x5, 0x103, 0xafb, 
       0xa, 0x103, 0x3, 0x104, 0x3, 0x104, 0x3, 0x104, 0x5, 0x104, 0xb00, 
       0xa, 0x104, 0x3, 0x104, 0x3, 0x104, 0x3, 0x104, 0x3, 0x105, 0x3, 
       0x105, 0x3, 0x105, 0x5, 0x105, 0xb08, 0xa, 0x105, 0x3, 0x105, 0x3, 
       0x105, 0x5, 0x105, 0xb0c, 0xa, 0x105, 0x3, 0x105, 0x3, 0x105, 0x5, 
       0x105, 0xb10, 0xa, 0x105, 0x3, 0x106, 0x3, 0x106, 0x3, 0x107, 0x3, 
       0x107, 0x5, 0x107, 0xb16, 0xa, 0x107, 0x3, 0x107, 0x3, 0x107, 0x3, 
       0x107, 0x5, 0x107, 0xb1b, 0xa, 0x107, 0x7, 0x107, 0xb1d, 0xa, 0x107, 
       0xc, 0x107, 0xe, 0x107, 0xb20, 0xb, 0x107, 0x3, 0x108, 0x3, 0x108, 
       0x3, 0x108, 0x5, 0x108, 0xb25, 0xa, 0x108, 0x3, 0x109, 0x3, 0x109, 
       0x3, 0x109, 0x3, 0x109, 0x5, 0x109, 0xb2b, 0xa, 0x109, 0x3, 0x109, 
       0x5, 0x109, 0xb2e, 0xa, 0x109, 0x3, 0x10a, 0x5, 0x10a, 0xb31, 0xa, 
       0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10b, 0x3, 0x10b, 
       0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10c, 0x3, 0x10c, 0x3, 
       0x10c, 0x3, 0x10c, 0x3, 0x10d, 0x3, 0x10d, 0x5, 0x10d, 0xb41, 0xa, 
       0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10e, 0x6, 0x10e, 
       0xb47, 0xa, 0x10e, 0xd, 0x10e, 0xe, 0x10e, 0xb48, 0x3, 0x10f, 0x3, 
       0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x110, 
       0x5, 0x110, 0xb52, 0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 
       0x5, 0x110, 0xb57, 0xa, 0x110, 0x3, 0x110, 0x5, 0x110, 0xb5a, 0xa, 
       0x110, 0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0xb5e, 0xa, 0x111, 0x3, 
       0x112, 0x3, 0x112, 0x5, 0x112, 0xb62, 0xa, 0x112, 0x3, 0x113, 0x3, 
       0x113, 0x3, 0x113, 0x5, 0x113, 0xb67, 0xa, 0x113, 0x3, 0x113, 0x3, 
       0x113, 0x3, 0x114, 0x3, 0x114, 0x5, 0x114, 0xb6d, 0xa, 0x114, 0x3, 
       0x114, 0x3, 0x114, 0x3, 0x114, 0x5, 0x114, 0xb72, 0xa, 0x114, 0x7, 
       0x114, 0xb74, 0xa, 0x114, 0xc, 0x114, 0xe, 0x114, 0xb77, 0xb, 0x114, 
       0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 
       0x115, 0x5, 0x115, 0xb7f, 0xa, 0x115, 0x3, 0x116, 0x3, 0x116, 0x3, 
       0x116, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x5, 0x117, 
       0xb88, 0xa, 0x117, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x119, 
       0x3, 0x119, 0x3, 0x119, 0x3, 0x11a, 0x3, 0x11a, 0x3, 0x11a, 0x3, 
       0x11a, 0x3, 0x11a, 0x3, 0x11a, 0x5, 0x11a, 0xb96, 0xa, 0x11a, 0x3, 
       0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11b, 
       0x5, 0x11b, 0xb9e, 0xa, 0x11b, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x5, 0x11c, 0xba3, 0xa, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x5, 0x11c, 0xba8, 0xa, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 
       0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 
       0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 
       0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x5, 
       0x11c, 0xbd3, 0xa, 0x11c, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 
       0x65c, 0x8, 0x12, 0x26, 0x3a, 0x162, 0x178, 0x17c, 0x11e, 0x2, 0x4, 
       0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 
       0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 
       0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 
       0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 
       0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 
       0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 
       0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 
       0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 
       0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 
       0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 
       0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 
       0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 
       0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 0x11c, 0x11e, 0x120, 
       0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 0x130, 0x132, 0x134, 
       0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 0x144, 0x146, 0x148, 
       0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15a, 0x15c, 
       0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 0x16c, 0x16e, 0x170, 
       0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 0x180, 0x182, 0x184, 
       0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 0x194, 0x196, 0x198, 
       0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 0x1a8, 0x1aa, 0x1ac, 
       0x1ae, 0x1b0, 0x1b2, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 0x1bc, 0x1be, 0x1c0, 
       0x1c2, 0x1c4, 0x1c6, 0x1c8, 0x1ca, 0x1cc, 0x1ce, 0x1d0, 0x1d2, 0x1d4, 
       0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1de, 0x1e0, 0x1e2, 0x1e4, 0x1e6, 0x1e8, 
       0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f2, 0x1f4, 0x1f6, 0x1f8, 0x1fa, 0x1fc, 
       0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 0x210, 
       0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 0x220, 0x222, 0x224, 
       0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 0x234, 0x236, 0x238, 
       0x2, 0x24, 0x11, 0x2, 0x15, 0x15, 0x27, 0x28, 0x32, 0x32, 0x37, 0x37, 
       0x42, 0x43, 0x47, 0x47, 0x49, 0x49, 0x4c, 0x4c, 0x4e, 0x4f, 0x57, 
       0x57, 0x59, 0x59, 0x76, 0x76, 0x78, 0x78, 0x94, 0x94, 0xcd, 0xcd, 
       0x6, 0x2, 0x26, 0x26, 0x5d, 0x65, 0x67, 0x67, 0x6c, 0x6c, 0x3, 0x2, 
       0x89, 0x8a, 0x4, 0x2, 0xaa, 0xaa, 0xae, 0xae, 0x6, 0x2, 0x2b, 0x2b, 
       0x35, 0x35, 0x75, 0x75, 0x82, 0x82, 0x4, 0x2, 0xc5, 0xc5, 0xca, 0xca, 
       0x3, 0x2, 0xc1, 0xc2, 0x4, 0x2, 0x7b, 0x7b, 0xc1, 0xc2, 0x4, 0x2, 
       0xa4, 0xa6, 0xaa, 0xad, 0x4, 0x2, 0xc4, 0xc4, 0xcb, 0xcb, 0x3, 0x2, 
       0xa6, 0xa8, 0x3, 0x2, 0xa4, 0xa5, 0x4, 0x2, 0xaf, 0xb0, 0xbd, 0xbe, 
       0x3, 0x2, 0xbb, 0xbc, 0x4, 0x2, 0xae, 0xae, 0xb1, 0xba, 0x3, 0x2, 
       0x21, 0x22, 0x3, 0x2, 0x23, 0x24, 0x4, 0x2, 0xc3, 0xc3, 0xc5, 0xc5, 
       0x4, 0x2, 0x1f, 0x20, 0x3f, 0x3f, 0x4, 0x2, 0x49, 0x49, 0x57, 0x57, 
       0x7, 0x2, 0x3b, 0x3b, 0x51, 0x51, 0x74, 0x74, 0x80, 0x80, 0x87, 0x87, 
       0x5, 0x2, 0x39, 0x39, 0x4a, 0x4a, 0x95, 0x95, 0x4, 0x2, 0x4d, 0x4d, 
       0x79, 0x79, 0x4, 0x2, 0x7a, 0x7a, 0x92, 0x92, 0x4, 0x2, 0x25, 0x25, 
       0x83, 0x83, 0x3, 0x2, 0x9d, 0xa2, 0x4, 0x2, 0xaa, 0xaa, 0xbf, 0xbf, 
       0x4, 0x2, 0x29, 0x29, 0x97, 0x97, 0x4, 0x2, 0x42, 0x42, 0x4c, 0x4c, 
       0x5, 0x2, 0xa4, 0xa6, 0xa9, 0xab, 0xbf, 0xc0, 0x3, 0x2, 0x30, 0x31, 
       0x4, 0x2, 0x3d, 0x3d, 0x58, 0x58, 0x3, 0x2, 0x6f, 0x71, 0x3, 0x2, 
       0x3, 0x9, 0x2, 0xcd4, 0x2, 0x23b, 0x3, 0x2, 0x2, 0x2, 0x4, 0x240, 
       0x3, 0x2, 0x2, 0x2, 0x6, 0x250, 0x3, 0x2, 0x2, 0x2, 0x8, 0x254, 0x3, 
       0x2, 0x2, 0x2, 0xa, 0x256, 0x3, 0x2, 0x2, 0x2, 0xc, 0x259, 0x3, 0x2, 
       0x2, 0x2, 0xe, 0x266, 0x3, 0x2, 0x2, 0x2, 0x10, 0x268, 0x3, 0x2, 
       0x2, 0x2, 0x12, 0x26e, 0x3, 0x2, 0x2, 0x2, 0x14, 0x285, 0x3, 0x2, 
       0x2, 0x2, 0x16, 0x28b, 0x3, 0x2, 0x2, 0x2, 0x18, 0x297, 0x3, 0x2, 
       0x2, 0x2, 0x1a, 0x299, 0x3, 0x2, 0x2, 0x2, 0x1c, 0x29b, 0x3, 0x2, 
       0x2, 0x2, 0x1e, 0x2a8, 0x3, 0x2, 0x2, 0x2, 0x20, 0x2af, 0x3, 0x2, 
       0x2, 0x2, 0x22, 0x2b2, 0x3, 0x2, 0x2, 0x2, 0x24, 0x2b7, 0x3, 0x2, 
       0x2, 0x2, 0x26, 0x2e1, 0x3, 0x2, 0x2, 0x2, 0x28, 0x303, 0x3, 0x2, 
       0x2, 0x2, 0x2a, 0x305, 0x3, 0x2, 0x2, 0x2, 0x2c, 0x31a, 0x3, 0x2, 
       0x2, 0x2, 0x2e, 0x336, 0x3, 0x2, 0x2, 0x2, 0x30, 0x338, 0x3, 0x2, 
       0x2, 0x2, 0x32, 0x33b, 0x3, 0x2, 0x2, 0x2, 0x34, 0x34b, 0x3, 0x2, 
       0x2, 0x2, 0x36, 0x34f, 0x3, 0x2, 0x2, 0x2, 0x38, 0x358, 0x3, 0x2, 
       0x2, 0x2, 0x3a, 0x35a, 0x3, 0x2, 0x2, 0x2, 0x3c, 0x373, 0x3, 0x2, 
       0x2, 0x2, 0x3e, 0x376, 0x3, 0x2, 0x2, 0x2, 0x40, 0x37f, 0x3, 0x2, 
       0x2, 0x2, 0x42, 0x38a, 0x3, 0x2, 0x2, 0x2, 0x44, 0x38c, 0x3, 0x2, 
       0x2, 0x2, 0x46, 0x394, 0x3, 0x2, 0x2, 0x2, 0x48, 0x39c, 0x3, 0x2, 
       0x2, 0x2, 0x4a, 0x3a4, 0x3, 0x2, 0x2, 0x2, 0x4c, 0x3b1, 0x3, 0x2, 
       0x2, 0x2, 0x4e, 0x3b3, 0x3, 0x2, 0x2, 0x2, 0x50, 0x3bb, 0x3, 0x2, 
       0x2, 0x2, 0x52, 0x3c3, 0x3, 0x2, 0x2, 0x2, 0x54, 0x3cb, 0x3, 0x2, 
       0x2, 0x2, 0x56, 0x3d3, 0x3, 0x2, 0x2, 0x2, 0x58, 0x3db, 0x3, 0x2, 
       0x2, 0x2, 0x5a, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x5c, 0x3eb, 0x3, 0x2, 
       0x2, 0x2, 0x5e, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x60, 0x3fb, 0x3, 0x2, 
       0x2, 0x2, 0x62, 0x3fd, 0x3, 0x2, 0x2, 0x2, 0x64, 0x405, 0x3, 0x2, 
       0x2, 0x2, 0x66, 0x422, 0x3, 0x2, 0x2, 0x2, 0x68, 0x425, 0x3, 0x2, 
       0x2, 0x2, 0x6a, 0x430, 0x3, 0x2, 0x2, 0x2, 0x6c, 0x433, 0x3, 0x2, 
       0x2, 0x2, 0x6e, 0x444, 0x3, 0x2, 0x2, 0x2, 0x70, 0x458, 0x3, 0x2, 
       0x2, 0x2, 0x72, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x74, 0x45f, 0x3, 0x2, 
       0x2, 0x2, 0x76, 0x466, 0x3, 0x2, 0x2, 0x2, 0x78, 0x476, 0x3, 0x2, 
       0x2, 0x2, 0x7a, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x7c, 0x47f, 0x3, 0x2, 
       0x2, 0x2, 0x7e, 0x485, 0x3, 0x2, 0x2, 0x2, 0x80, 0x48b, 0x3, 0x2, 
       0x2, 0x2, 0x82, 0x491, 0x3, 0x2, 0x2, 0x2, 0x84, 0x497, 0x3, 0x2, 
       0x2, 0x2, 0x86, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x88, 0x4a3, 0x3, 0x2, 
       0x2, 0x2, 0x8a, 0x4a9, 0x3, 0x2, 0x2, 0x2, 0x8c, 0x4af, 0x3, 0x2, 
       0x2, 0x2, 0x8e, 0x4b2, 0x3, 0x2, 0x2, 0x2, 0x90, 0x4b5, 0x3, 0x2, 
       0x2, 0x2, 0x92, 0x4b8, 0x3, 0x2, 0x2, 0x2, 0x94, 0x4bb, 0x3, 0x2, 
       0x2, 0x2, 0x96, 0x4be, 0x3, 0x2, 0x2, 0x2, 0x98, 0x4c1, 0x3, 0x2, 
       0x2, 0x2, 0x9a, 0x4c4, 0x3, 0x2, 0x2, 0x2, 0x9c, 0x4cb, 0x3, 0x2, 
       0x2, 0x2, 0x9e, 0x4d1, 0x3, 0x2, 0x2, 0x2, 0xa0, 0x4d7, 0x3, 0x2, 
       0x2, 0x2, 0xa2, 0x4e5, 0x3, 0x2, 0x2, 0x2, 0xa4, 0x4ea, 0x3, 0x2, 
       0x2, 0x2, 0xa6, 0x4ec, 0x3, 0x2, 0x2, 0x2, 0xa8, 0x4fa, 0x3, 0x2, 
       0x2, 0x2, 0xaa, 0x509, 0x3, 0x2, 0x2, 0x2, 0xac, 0x516, 0x3, 0x2, 
       0x2, 0x2, 0xae, 0x518, 0x3, 0x2, 0x2, 0x2, 0xb0, 0x520, 0x3, 0x2, 
       0x2, 0x2, 0xb2, 0x532, 0x3, 0x2, 0x2, 0x2, 0xb4, 0x534, 0x3, 0x2, 
       0x2, 0x2, 0xb6, 0x539, 0x3, 0x2, 0x2, 0x2, 0xb8, 0x541, 0x3, 0x2, 
       0x2, 0x2, 0xba, 0x559, 0x3, 0x2, 0x2, 0x2, 0xbc, 0x55d, 0x3, 0x2, 
       0x2, 0x2, 0xbe, 0x569, 0x3, 0x2, 0x2, 0x2, 0xc0, 0x570, 0x3, 0x2, 
       0x2, 0x2, 0xc2, 0x584, 0x3, 0x2, 0x2, 0x2, 0xc4, 0x58f, 0x3, 0x2, 
       0x2, 0x2, 0xc6, 0x597, 0x3, 0x2, 0x2, 0x2, 0xc8, 0x5a0, 0x3, 0x2, 
       0x2, 0x2, 0xca, 0x5a4, 0x3, 0x2, 0x2, 0x2, 0xcc, 0x5ab, 0x3, 0x2, 
       0x2, 0x2, 0xce, 0x5be, 0x3, 0x2, 0x2, 0x2, 0xd0, 0x5cb, 0x3, 0x2, 
       0x2, 0x2, 0xd2, 0x5ee, 0x3, 0x2, 0x2, 0x2, 0xd4, 0x5f2, 0x3, 0x2, 
       0x2, 0x2, 0xd6, 0x5f5, 0x3, 0x2, 0x2, 0x2, 0xd8, 0x5fc, 0x3, 0x2, 
       0x2, 0x2, 0xda, 0x607, 0x3, 0x2, 0x2, 0x2, 0xdc, 0x60b, 0x3, 0x2, 
       0x2, 0x2, 0xde, 0x60e, 0x3, 0x2, 0x2, 0x2, 0xe0, 0x620, 0x3, 0x2, 
       0x2, 0x2, 0xe2, 0x62a, 0x3, 0x2, 0x2, 0x2, 0xe4, 0x62c, 0x3, 0x2, 
       0x2, 0x2, 0xe6, 0x641, 0x3, 0x2, 0x2, 0x2, 0xe8, 0x643, 0x3, 0x2, 
       0x2, 0x2, 0xea, 0x64b, 0x3, 0x2, 0x2, 0x2, 0xec, 0x64d, 0x3, 0x2, 
       0x2, 0x2, 0xee, 0x657, 0x3, 0x2, 0x2, 0x2, 0xf0, 0x65a, 0x3, 0x2, 
       0x2, 0x2, 0xf2, 0x66b, 0x3, 0x2, 0x2, 0x2, 0xf4, 0x66d, 0x3, 0x2, 
       0x2, 0x2, 0xf6, 0x674, 0x3, 0x2, 0x2, 0x2, 0xf8, 0x67c, 0x3, 0x2, 
       0x2, 0x2, 0xfa, 0x682, 0x3, 0x2, 0x2, 0x2, 0xfc, 0x685, 0x3, 0x2, 
       0x2, 0x2, 0xfe, 0x68a, 0x3, 0x2, 0x2, 0x2, 0x100, 0x68f, 0x3, 0x2, 
       0x2, 0x2, 0x102, 0x694, 0x3, 0x2, 0x2, 0x2, 0x104, 0x699, 0x3, 0x2, 
       0x2, 0x2, 0x106, 0x69f, 0x3, 0x2, 0x2, 0x2, 0x108, 0x6a5, 0x3, 0x2, 
       0x2, 0x2, 0x10a, 0x6a7, 0x3, 0x2, 0x2, 0x2, 0x10c, 0x6a9, 0x3, 0x2, 
       0x2, 0x2, 0x10e, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x110, 0x6b5, 0x3, 0x2, 
       0x2, 0x2, 0x112, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x114, 0x6c0, 0x3, 0x2, 
       0x2, 0x2, 0x116, 0x6c7, 0x3, 0x2, 0x2, 0x2, 0x118, 0x6c9, 0x3, 0x2, 
       0x2, 0x2, 0x11a, 0x6ff, 0x3, 0x2, 0x2, 0x2, 0x11c, 0x704, 0x3, 0x2, 
       0x2, 0x2, 0x11e, 0x706, 0x3, 0x2, 0x2, 0x2, 0x120, 0x724, 0x3, 0x2, 
       0x2, 0x2, 0x122, 0x726, 0x3, 0x2, 0x2, 0x2, 0x124, 0x728, 0x3, 0x2, 
       0x2, 0x2, 0x126, 0x732, 0x3, 0x2, 0x2, 0x2, 0x128, 0x73f, 0x3, 0x2, 
       0x2, 0x2, 0x12a, 0x749, 0x3, 0x2, 0x2, 0x2, 0x12c, 0x74d, 0x3, 0x2, 
       0x2, 0x2, 0x12e, 0x750, 0x3, 0x2, 0x2, 0x2, 0x130, 0x758, 0x3, 0x2, 
       0x2, 0x2, 0x132, 0x75d, 0x3, 0x2, 0x2, 0x2, 0x134, 0x761, 0x3, 0x2, 
       0x2, 0x2, 0x136, 0x763, 0x3, 0x2, 0x2, 0x2, 0x138, 0x766, 0x3, 0x2, 
       0x2, 0x2, 0x13a, 0x773, 0x3, 0x2, 0x2, 0x2, 0x13c, 0x775, 0x3, 0x2, 
       0x2, 0x2, 0x13e, 0x77c, 0x3, 0x2, 0x2, 0x2, 0x140, 0x780, 0x3, 0x2, 
       0x2, 0x2, 0x142, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x144, 0x796, 0x3, 0x2, 
       0x2, 0x2, 0x146, 0x79c, 0x3, 0x2, 0x2, 0x2, 0x148, 0x7a7, 0x3, 0x2, 
       0x2, 0x2, 0x14a, 0x7b3, 0x3, 0x2, 0x2, 0x2, 0x14c, 0x7b5, 0x3, 0x2, 
       0x2, 0x2, 0x14e, 0x7c0, 0x3, 0x2, 0x2, 0x2, 0x150, 0x7ce, 0x3, 0x2, 
       0x2, 0x2, 0x152, 0x7d4, 0x3, 0x2, 0x2, 0x2, 0x154, 0x7d6, 0x3, 0x2, 
       0x2, 0x2, 0x156, 0x7dd, 0x3, 0x2, 0x2, 0x2, 0x158, 0x7f2, 0x3, 0x2, 
       0x2, 0x2, 0x15a, 0x7f4, 0x3, 0x2, 0x2, 0x2, 0x15c, 0x7fc, 0x3, 0x2, 
       0x2, 0x2, 0x15e, 0x805, 0x3, 0x2, 0x2, 0x2, 0x160, 0x80d, 0x3, 0x2, 
       0x2, 0x2, 0x162, 0x81b, 0x3, 0x2, 0x2, 0x2, 0x164, 0x82e, 0x3, 0x2, 
       0x2, 0x2, 0x166, 0x83f, 0x3, 0x2, 0x2, 0x2, 0x168, 0x852, 0x3, 0x2, 
       0x2, 0x2, 0x16a, 0x855, 0x3, 0x2, 0x2, 0x2, 0x16c, 0x859, 0x3, 0x2, 
       0x2, 0x2, 0x16e, 0x85b, 0x3, 0x2, 0x2, 0x2, 0x170, 0x85e, 0x3, 0x2, 
       0x2, 0x2, 0x172, 0x863, 0x3, 0x2, 0x2, 0x2, 0x174, 0x86f, 0x3, 0x2, 
       0x2, 0x2, 0x176, 0x87a, 0x3, 0x2, 0x2, 0x2, 0x178, 0x88e, 0x3, 0x2, 
       0x2, 0x2, 0x17a, 0x8a9, 0x3, 0x2, 0x2, 0x2, 0x17c, 0x8ae, 0x3, 0x2, 
       0x2, 0x2, 0x17e, 0x8c2, 0x3, 0x2, 0x2, 0x2, 0x180, 0x8c9, 0x3, 0x2, 
       0x2, 0x2, 0x182, 0x8d2, 0x3, 0x2, 0x2, 0x2, 0x184, 0x8df, 0x3, 0x2, 
       0x2, 0x2, 0x186, 0x8e4, 0x3, 0x2, 0x2, 0x2, 0x188, 0x8e8, 0x3, 0x2, 
       0x2, 0x2, 0x18a, 0x8fe, 0x3, 0x2, 0x2, 0x2, 0x18c, 0x909, 0x3, 0x2, 
       0x2, 0x2, 0x18e, 0x915, 0x3, 0x2, 0x2, 0x2, 0x190, 0x91d, 0x3, 0x2, 
       0x2, 0x2, 0x192, 0x922, 0x3, 0x2, 0x2, 0x2, 0x194, 0x92a, 0x3, 0x2, 
       0x2, 0x2, 0x196, 0x930, 0x3, 0x2, 0x2, 0x2, 0x198, 0x937, 0x3, 0x2, 
       0x2, 0x2, 0x19a, 0x93d, 0x3, 0x2, 0x2, 0x2, 0x19c, 0x93f, 0x3, 0x2, 
       0x2, 0x2, 0x19e, 0x944, 0x3, 0x2, 0x2, 0x2, 0x1a0, 0x949, 0x3, 0x2, 
       0x2, 0x2, 0x1a2, 0x94e, 0x3, 0x2, 0x2, 0x2, 0x1a4, 0x961, 0x3, 0x2, 
       0x2, 0x2, 0x1a6, 0x963, 0x3, 0x2, 0x2, 0x2, 0x1a8, 0x97e, 0x3, 0x2, 
       0x2, 0x2, 0x1aa, 0x980, 0x3, 0x2, 0x2, 0x2, 0x1ac, 0x984, 0x3, 0x2, 
       0x2, 0x2, 0x1ae, 0x98b, 0x3, 0x2, 0x2, 0x2, 0x1b0, 0x990, 0x3, 0x2, 
       0x2, 0x2, 0x1b2, 0x994, 0x3, 0x2, 0x2, 0x2, 0x1b4, 0x9b7, 0x3, 0x2, 
       0x2, 0x2, 0x1b6, 0x9bb, 0x3, 0x2, 0x2, 0x2, 0x1b8, 0x9ca, 0x3, 0x2, 
       0x2, 0x2, 0x1ba, 0x9d1, 0x3, 0x2, 0x2, 0x2, 0x1bc, 0x9d6, 0x3, 0x2, 
       0x2, 0x2, 0x1be, 0x9da, 0x3, 0x2, 0x2, 0x2, 0x1c0, 0x9dc, 0x3, 0x2, 
       0x2, 0x2, 0x1c2, 0x9ea, 0x3, 0x2, 0x2, 0x2, 0x1c4, 0x9f5, 0x3, 0x2, 
       0x2, 0x2, 0x1c6, 0x9f7, 0x3, 0x2, 0x2, 0x2, 0x1c8, 0xa15, 0x3, 0x2, 
       0x2, 0x2, 0x1ca, 0xa18, 0x3, 0x2, 0x2, 0x2, 0x1cc, 0xa1c, 0x3, 0x2, 
       0x2, 0x2, 0x1ce, 0xa1e, 0x3, 0x2, 0x2, 0x2, 0x1d0, 0xa25, 0x3, 0x2, 
       0x2, 0x2, 0x1d2, 0xa31, 0x3, 0x2, 0x2, 0x2, 0x1d4, 0xa49, 0x3, 0x2, 
       0x2, 0x2, 0x1d6, 0xa4b, 0x3, 0x2, 0x2, 0x2, 0x1d8, 0xa66, 0x3, 0x2, 
       0x2, 0x2, 0x1da, 0xa69, 0x3, 0x2, 0x2, 0x2, 0x1dc, 0xa6d, 0x3, 0x2, 
       0x2, 0x2, 0x1de, 0xa6f, 0x3, 0x2, 0x2, 0x2, 0x1e0, 0xa73, 0x3, 0x2, 
       0x2, 0x2, 0x1e2, 0xa76, 0x3, 0x2, 0x2, 0x2, 0x1e4, 0xa85, 0x3, 0x2, 
       0x2, 0x2, 0x1e6, 0xa9a, 0x3, 0x2, 0x2, 0x2, 0x1e8, 0xa9c, 0x3, 0x2, 
       0x2, 0x2, 0x1ea, 0xa9e, 0x3, 0x2, 0x2, 0x2, 0x1ec, 0xaa0, 0x3, 0x2, 
       0x2, 0x2, 0x1ee, 0xaa3, 0x3, 0x2, 0x2, 0x2, 0x1f0, 0xaa7, 0x3, 0x2, 
       0x2, 0x2, 0x1f2, 0xaab, 0x3, 0x2, 0x2, 0x2, 0x1f4, 0xaae, 0x3, 0x2, 
       0x2, 0x2, 0x1f6, 0xabc, 0x3, 0x2, 0x2, 0x2, 0x1f8, 0xac7, 0x3, 0x2, 
       0x2, 0x2, 0x1fa, 0xac9, 0x3, 0x2, 0x2, 0x2, 0x1fc, 0xacc, 0x3, 0x2, 
       0x2, 0x2, 0x1fe, 0xad2, 0x3, 0x2, 0x2, 0x2, 0x200, 0xad8, 0x3, 0x2, 
       0x2, 0x2, 0x202, 0xae2, 0x3, 0x2, 0x2, 0x2, 0x204, 0xaed, 0x3, 0x2, 
       0x2, 0x2, 0x206, 0xafc, 0x3, 0x2, 0x2, 0x2, 0x208, 0xb0f, 0x3, 0x2, 
       0x2, 0x2, 0x20a, 0xb11, 0x3, 0x2, 0x2, 0x2, 0x20c, 0xb13, 0x3, 0x2, 
       0x2, 0x2, 0x20e, 0xb24, 0x3, 0x2, 0x2, 0x2, 0x210, 0xb26, 0x3, 0x2, 
       0x2, 0x2, 0x212, 0xb30, 0x3, 0x2, 0x2, 0x2, 0x214, 0xb35, 0x3, 0x2, 
       0x2, 0x2, 0x216, 0xb3a, 0x3, 0x2, 0x2, 0x2, 0x218, 0xb3e, 0x3, 0x2, 
       0x2, 0x2, 0x21a, 0xb46, 0x3, 0x2, 0x2, 0x2, 0x21c, 0xb4a, 0x3, 0x2, 
       0x2, 0x2, 0x21e, 0xb59, 0x3, 0x2, 0x2, 0x2, 0x220, 0xb5b, 0x3, 0x2, 
       0x2, 0x2, 0x222, 0xb61, 0x3, 0x2, 0x2, 0x2, 0x224, 0xb63, 0x3, 0x2, 
       0x2, 0x2, 0x226, 0xb6a, 0x3, 0x2, 0x2, 0x2, 0x228, 0xb7e, 0x3, 0x2, 
       0x2, 0x2, 0x22a, 0xb80, 0x3, 0x2, 0x2, 0x2, 0x22c, 0xb87, 0x3, 0x2, 
       0x2, 0x2, 0x22e, 0xb89, 0x3, 0x2, 0x2, 0x2, 0x230, 0xb8c, 0x3, 0x2, 
       0x2, 0x2, 0x232, 0xb8f, 0x3, 0x2, 0x2, 0x2, 0x234, 0xb97, 0x3, 0x2, 
       0x2, 0x2, 0x236, 0xbd2, 0x3, 0x2, 0x2, 0x2, 0x238, 0xbd4, 0x3, 0x2, 
       0x2, 0x2, 0x23a, 0x23c, 0x5, 0xde, 0x70, 0x2, 0x23b, 0x23a, 0x3, 
       0x2, 0x2, 0x2, 0x23b, 0x23c, 0x3, 0x2, 0x2, 0x2, 0x23c, 0x23d, 0x3, 
       0x2, 0x2, 0x2, 0x23d, 0x23e, 0x7, 0x2, 0x2, 0x3, 0x23e, 0x23f, 0x8, 
       0x2, 0x1, 0x2, 0x23f, 0x3, 0x3, 0x2, 0x2, 0x2, 0x240, 0x241, 0x9, 
       0x2, 0x2, 0x2, 0x241, 0x5, 0x3, 0x2, 0x2, 0x2, 0x242, 0x244, 0x5, 
       0x238, 0x11d, 0x2, 0x243, 0x242, 0x3, 0x2, 0x2, 0x2, 0x244, 0x245, 
       0x3, 0x2, 0x2, 0x2, 0x245, 0x243, 0x3, 0x2, 0x2, 0x2, 0x245, 0x246, 
       0x3, 0x2, 0x2, 0x2, 0x246, 0x251, 0x3, 0x2, 0x2, 0x2, 0x247, 0x251, 
       0x7, 0x86, 0x2, 0x2, 0x248, 0x249, 0x7, 0x9d, 0x2, 0x2, 0x249, 0x24a, 
       0x5, 0x62, 0x32, 0x2, 0x24a, 0x24b, 0x7, 0x9e, 0x2, 0x2, 0x24b, 0x251, 
       0x3, 0x2, 0x2, 0x2, 0x24c, 0x251, 0x5, 0xa, 0x6, 0x2, 0x24d, 0x251, 
       0x5, 0xc, 0x7, 0x2, 0x24e, 0x251, 0x5, 0x8, 0x5, 0x2, 0x24f, 0x251, 
       0x5, 0x14, 0xb, 0x2, 0x250, 0x243, 0x3, 0x2, 0x2, 0x2, 0x250, 0x247, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x248, 0x3, 0x2, 0x2, 0x2, 0x250, 0x24c, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x24d, 0x3, 0x2, 0x2, 0x2, 0x250, 0x24e, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x24f, 0x3, 0x2, 0x2, 0x2, 0x251, 0x7, 
       0x3, 0x2, 0x2, 0x2, 0x252, 0x255, 0x5, 0x10, 0x9, 0x2, 0x253, 0x255, 
       0x5, 0xe, 0x8, 0x2, 0x254, 0x252, 0x3, 0x2, 0x2, 0x2, 0x254, 0x253, 
       0x3, 0x2, 0x2, 0x2, 0x255, 0x9, 0x3, 0x2, 0x2, 0x2, 0x256, 0x257, 
       0x6, 0x6, 0x2, 0x2, 0x257, 0x258, 0x9, 0x3, 0x2, 0x2, 0x258, 0xb, 
       0x3, 0x2, 0x2, 0x2, 0x259, 0x25a, 0x6, 0x7, 0x3, 0x2, 0x25a, 0x25b, 
       0x9, 0x4, 0x2, 0x2, 0x25b, 0xd, 0x3, 0x2, 0x2, 0x2, 0x25c, 0x267, 
       0x5, 0x208, 0x105, 0x2, 0x25d, 0x267, 0x5, 0x4, 0x3, 0x2, 0x25e, 
       0x267, 0x5, 0x1fa, 0xfe, 0x2, 0x25f, 0x267, 0x5, 0x1ec, 0xf7, 0x2, 
       0x260, 0x267, 0x5, 0x1fc, 0xff, 0x2, 0x261, 0x264, 0x7, 0xac, 0x2, 
       0x2, 0x262, 0x265, 0x5, 0x1c4, 0xe3, 0x2, 0x263, 0x265, 0x5, 0x11e, 
       0x90, 0x2, 0x264, 0x262, 0x3, 0x2, 0x2, 0x2, 0x264, 0x263, 0x3, 0x2, 
       0x2, 0x2, 0x265, 0x267, 0x3, 0x2, 0x2, 0x2, 0x266, 0x25c, 0x3, 0x2, 
       0x2, 0x2, 0x266, 0x25d, 0x3, 0x2, 0x2, 0x2, 0x266, 0x25e, 0x3, 0x2, 
       0x2, 0x2, 0x266, 0x25f, 0x3, 0x2, 0x2, 0x2, 0x266, 0x260, 0x3, 0x2, 
       0x2, 0x2, 0x266, 0x261, 0x3, 0x2, 0x2, 0x2, 0x267, 0xf, 0x3, 0x2, 
       0x2, 0x2, 0x268, 0x26a, 0x5, 0x12, 0xa, 0x2, 0x269, 0x26b, 0x7, 0x85, 
       0x2, 0x2, 0x26a, 0x269, 0x3, 0x2, 0x2, 0x2, 0x26a, 0x26b, 0x3, 0x2, 
       0x2, 0x2, 0x26b, 0x26c, 0x3, 0x2, 0x2, 0x2, 0x26c, 0x26d, 0x5, 0xe, 
       0x8, 0x2, 0x26d, 0x11, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x272, 0x8, 0xa, 
       0x1, 0x2, 0x26f, 0x273, 0x5, 0x11c, 0x8f, 0x2, 0x270, 0x273, 0x5, 
       0x134, 0x9b, 0x2, 0x271, 0x273, 0x5, 0x11e, 0x90, 0x2, 0x272, 0x26f, 
       0x3, 0x2, 0x2, 0x2, 0x272, 0x270, 0x3, 0x2, 0x2, 0x2, 0x272, 0x271, 
       0x3, 0x2, 0x2, 0x2, 0x272, 0x273, 0x3, 0x2, 0x2, 0x2, 0x273, 0x274, 
       0x3, 0x2, 0x2, 0x2, 0x274, 0x275, 0x7, 0xc8, 0x2, 0x2, 0x275, 0x282, 
       0x3, 0x2, 0x2, 0x2, 0x276, 0x27c, 0xc, 0x3, 0x2, 0x2, 0x277, 0x27d, 
       0x5, 0x4, 0x3, 0x2, 0x278, 0x27a, 0x7, 0x85, 0x2, 0x2, 0x279, 0x278, 
       0x3, 0x2, 0x2, 0x2, 0x279, 0x27a, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x27b, 
       0x3, 0x2, 0x2, 0x2, 0x27b, 0x27d, 0x5, 0x206, 0x104, 0x2, 0x27c, 
       0x277, 0x3, 0x2, 0x2, 0x2, 0x27c, 0x279, 0x3, 0x2, 0x2, 0x2, 0x27d, 
       0x27e, 0x3, 0x2, 0x2, 0x2, 0x27e, 0x27f, 0x7, 0xc8, 0x2, 0x2, 0x27f, 
       0x281, 0x3, 0x2, 0x2, 0x2, 0x280, 0x276, 0x3, 0x2, 0x2, 0x2, 0x281, 
       0x284, 0x3, 0x2, 0x2, 0x2, 0x282, 0x280, 0x3, 0x2, 0x2, 0x2, 0x282, 
       0x283, 0x3, 0x2, 0x2, 0x2, 0x283, 0x13, 0x3, 0x2, 0x2, 0x2, 0x284, 
       0x282, 0x3, 0x2, 0x2, 0x2, 0x285, 0x287, 0x5, 0x16, 0xc, 0x2, 0x286, 
       0x288, 0x5, 0x24, 0x13, 0x2, 0x287, 0x286, 0x3, 0x2, 0x2, 0x2, 0x287, 
       0x288, 0x3, 0x2, 0x2, 0x2, 0x288, 0x289, 0x3, 0x2, 0x2, 0x2, 0x289, 
       0x28a, 0x5, 0xca, 0x66, 0x2, 0x28a, 0x15, 0x3, 0x2, 0x2, 0x2, 0x28b, 
       0x28d, 0x7, 0x9f, 0x2, 0x2, 0x28c, 0x28e, 0x5, 0x18, 0xd, 0x2, 0x28d, 
       0x28c, 0x3, 0x2, 0x2, 0x2, 0x28d, 0x28e, 0x3, 0x2, 0x2, 0x2, 0x28e, 
       0x28f, 0x3, 0x2, 0x2, 0x2, 0x28f, 0x290, 0x7, 0xa0, 0x2, 0x2, 0x290, 
       0x17, 0x3, 0x2, 0x2, 0x2, 0x291, 0x298, 0x5, 0x1c, 0xf, 0x2, 0x292, 
       0x295, 0x5, 0x1a, 0xe, 0x2, 0x293, 0x294, 0x7, 0xc3, 0x2, 0x2, 0x294, 
       0x296, 0x5, 0x1c, 0xf, 0x2, 0x295, 0x293, 0x3, 0x2, 0x2, 0x2, 0x295, 
       0x296, 0x3, 0x2, 0x2, 0x2, 0x296, 0x298, 0x3, 0x2, 0x2, 0x2, 0x297, 
       0x291, 0x3, 0x2, 0x2, 0x2, 0x297, 0x292, 0x3, 0x2, 0x2, 0x2, 0x298, 
       0x19, 0x3, 0x2, 0x2, 0x2, 0x299, 0x29a, 0x9, 0x5, 0x2, 0x2, 0x29a, 
       0x1b, 0x3, 0x2, 0x2, 0x2, 0x29b, 0x2a0, 0x5, 0x1e, 0x10, 0x2, 0x29c, 
       0x29d, 0x7, 0xc3, 0x2, 0x2, 0x29d, 0x29f, 0x5, 0x1e, 0x10, 0x2, 0x29e, 
       0x29c, 0x3, 0x2, 0x2, 0x2, 0x29f, 0x2a2, 0x3, 0x2, 0x2, 0x2, 0x2a0, 
       0x29e, 0x3, 0x2, 0x2, 0x2, 0x2a0, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x2a1, 
       0x2a4, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x2a0, 0x3, 0x2, 0x2, 0x2, 0x2a3, 
       0x2a5, 0x7, 0xcc, 0x2, 0x2, 0x2a4, 0x2a3, 0x3, 0x2, 0x2, 0x2, 0x2a4, 
       0x2a5, 0x3, 0x2, 0x2, 0x2, 0x2a5, 0x1d, 0x3, 0x2, 0x2, 0x2, 0x2a6, 
       0x2a9, 0x5, 0x20, 0x11, 0x2, 0x2a7, 0x2a9, 0x5, 0x22, 0x12, 0x2, 
       0x2a8, 0x2a6, 0x3, 0x2, 0x2, 0x2, 0x2a8, 0x2a7, 0x3, 0x2, 0x2, 0x2, 
       0x2a9, 0x1f, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x2ac, 0x7, 0xaa, 0x2, 0x2, 
       0x2ab, 0x2aa, 0x3, 0x2, 0x2, 0x2, 0x2ab, 0x2ac, 0x3, 0x2, 0x2, 0x2, 
       0x2ac, 0x2ad, 0x3, 0x2, 0x2, 0x2, 0x2ad, 0x2b0, 0x5, 0x4, 0x3, 0x2, 
       0x2ae, 0x2b0, 0x7, 0x86, 0x2, 0x2, 0x2af, 0x2ab, 0x3, 0x2, 0x2, 0x2, 
       0x2af, 0x2ae, 0x3, 0x2, 0x2, 0x2, 0x2b0, 0x21, 0x3, 0x2, 0x2, 0x2, 
       0x2b1, 0x2b3, 0x7, 0xaa, 0x2, 0x2, 0x2b2, 0x2b1, 0x3, 0x2, 0x2, 0x2, 
       0x2b2, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x2b3, 0x2b4, 0x3, 0x2, 0x2, 0x2, 
       0x2b4, 0x2b5, 0x5, 0x4, 0x3, 0x2, 0x2b5, 0x2b6, 0x5, 0x1ba, 0xde, 
       0x2, 0x2b6, 0x23, 0x3, 0x2, 0x2, 0x2, 0x2b7, 0x2b9, 0x7, 0x9d, 0x2, 
       0x2, 0x2b8, 0x2ba, 0x5, 0x17e, 0xc0, 0x2, 0x2b9, 0x2b8, 0x3, 0x2, 
       0x2, 0x2, 0x2b9, 0x2ba, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0x2bb, 0x3, 0x2, 
       0x2, 0x2, 0x2bb, 0x2bd, 0x7, 0x9e, 0x2, 0x2, 0x2bc, 0x2be, 0x7, 0x51, 
       0x2, 0x2, 0x2bd, 0x2bc, 0x3, 0x2, 0x2, 0x2, 0x2bd, 0x2be, 0x3, 0x2, 
       0x2, 0x2, 0x2be, 0x2c0, 0x3, 0x2, 0x2, 0x2, 0x2bf, 0x2c1, 0x5, 0x222, 
       0x112, 0x2, 0x2c0, 0x2bf, 0x3, 0x2, 0x2, 0x2, 0x2c0, 0x2c1, 0x3, 
       0x2, 0x2, 0x2, 0x2c1, 0x2c3, 0x3, 0x2, 0x2, 0x2, 0x2c2, 0x2c4, 0x5, 
       0x148, 0xa5, 0x2, 0x2c3, 0x2c2, 0x3, 0x2, 0x2, 0x2, 0x2c3, 0x2c4, 
       0x3, 0x2, 0x2, 0x2, 0x2c4, 0x2c6, 0x3, 0x2, 0x2, 0x2, 0x2c5, 0x2c7, 
       0x5, 0x166, 0xb4, 0x2, 0x2c6, 0x2c5, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x2c7, 
       0x3, 0x2, 0x2, 0x2, 0x2c7, 0x25, 0x3, 0x2, 0x2, 0x2, 0x2c8, 0x2c9, 
       0x8, 0x14, 0x1, 0x2, 0x2c9, 0x2e2, 0x5, 0x6, 0x4, 0x2, 0x2ca, 0x2cd, 
       0x5, 0x11a, 0x8e, 0x2, 0x2cb, 0x2cd, 0x5, 0x210, 0x109, 0x2, 0x2cc, 
       0x2ca, 0x3, 0x2, 0x2, 0x2, 0x2cc, 0x2cb, 0x3, 0x2, 0x2, 0x2, 0x2cd, 
       0x2ce, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x2cf, 0x5, 0x1c2, 0xe2, 0x2, 0x2cf, 
       0x2e2, 0x3, 0x2, 0x2, 0x2, 0x2d0, 0x2e2, 0x5, 0x172, 0xba, 0x2, 0x2d1, 
       0x2d2, 0x9, 0x6, 0x2, 0x2, 0x2d2, 0x2d3, 0x7, 0xaf, 0x2, 0x2, 0x2d3, 
       0x2d4, 0x5, 0x172, 0xba, 0x2, 0x2d4, 0x2d5, 0x7, 0xb0, 0x2, 0x2, 
       0x2d5, 0x2d6, 0x7, 0x9d, 0x2, 0x2, 0x2d6, 0x2d7, 0x5, 0x62, 0x32, 
       0x2, 0x2d7, 0x2d8, 0x7, 0x9e, 0x2, 0x2, 0x2d8, 0x2e2, 0x3, 0x2, 0x2, 
       0x2, 0x2d9, 0x2da, 0x5, 0x28, 0x15, 0x2, 0x2da, 0x2dd, 0x7, 0x9d, 
       0x2, 0x2, 0x2db, 0x2de, 0x5, 0x62, 0x32, 0x2, 0x2dc, 0x2de, 0x5, 
       0x172, 0xba, 0x2, 0x2dd, 0x2db, 0x3, 0x2, 0x2, 0x2, 0x2dd, 0x2dc, 
       0x3, 0x2, 0x2, 0x2, 0x2de, 0x2df, 0x3, 0x2, 0x2, 0x2, 0x2df, 0x2e0, 
       0x7, 0x9e, 0x2, 0x2, 0x2e0, 0x2e2, 0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2c8, 
       0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2cc, 0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2d0, 
       0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x2e1, 0x2d9, 
       0x3, 0x2, 0x2, 0x2, 0x2e2, 0x300, 0x3, 0x2, 0x2, 0x2, 0x2e3, 0x2e4, 
       0xc, 0xa, 0x2, 0x2, 0x2e4, 0x2e7, 0x7, 0x9f, 0x2, 0x2, 0x2e5, 0x2e8, 
       0x5, 0x62, 0x32, 0x2, 0x2e6, 0x2e8, 0x5, 0x1c2, 0xe2, 0x2, 0x2e7, 
       0x2e5, 0x3, 0x2, 0x2, 0x2, 0x2e7, 0x2e6, 0x3, 0x2, 0x2, 0x2, 0x2e8, 
       0x2e9, 0x3, 0x2, 0x2, 0x2, 0x2e9, 0x2ea, 0x7, 0xa0, 0x2, 0x2, 0x2ea, 
       0x2ff, 0x3, 0x2, 0x2, 0x2, 0x2eb, 0x2ec, 0xc, 0x9, 0x2, 0x2, 0x2ec, 
       0x2ee, 0x7, 0x9d, 0x2, 0x2, 0x2ed, 0x2ef, 0x5, 0x2a, 0x16, 0x2, 0x2ee, 
       0x2ed, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x2ef, 0x3, 0x2, 0x2, 0x2, 0x2ef, 
       0x2f0, 0x3, 0x2, 0x2, 0x2, 0x2f0, 0x2ff, 0x7, 0x9e, 0x2, 0x2, 0x2f1, 
       0x2f2, 0xc, 0x6, 0x2, 0x2, 0x2f2, 0x2fa, 0x9, 0x7, 0x2, 0x2, 0x2f3, 
       0x2f5, 0x7, 0x85, 0x2, 0x2, 0x2f4, 0x2f3, 0x3, 0x2, 0x2, 0x2, 0x2f4, 
       0x2f5, 0x3, 0x2, 0x2, 0x2, 0x2f5, 0x2f6, 0x3, 0x2, 0x2, 0x2, 0x2f6, 
       0x2f7, 0x5, 0x8, 0x5, 0x2, 0x2f7, 0x2f8, 0x8, 0x14, 0x1, 0x2, 0x2f8, 
       0x2fb, 0x3, 0x2, 0x2, 0x2, 0x2f9, 0x2fb, 0x5, 0x2c, 0x17, 0x2, 0x2fa, 
       0x2f4, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x2f9, 0x3, 0x2, 0x2, 0x2, 0x2fb, 
       0x2ff, 0x3, 0x2, 0x2, 0x2, 0x2fc, 0x2fd, 0xc, 0x5, 0x2, 0x2, 0x2fd, 
       0x2ff, 0x9, 0x8, 0x2, 0x2, 0x2fe, 0x2e3, 0x3, 0x2, 0x2, 0x2, 0x2fe, 
       0x2eb, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x2f1, 0x3, 0x2, 0x2, 0x2, 0x2fe, 
       0x2fc, 0x3, 0x2, 0x2, 0x2, 0x2ff, 0x302, 0x3, 0x2, 0x2, 0x2, 0x300, 
       0x2fe, 0x3, 0x2, 0x2, 0x2, 0x300, 0x301, 0x3, 0x2, 0x2, 0x2, 0x301, 
       0x27, 0x3, 0x2, 0x2, 0x2, 0x302, 0x300, 0x3, 0x2, 0x2, 0x2, 0x303, 
       0x304, 0x7, 0x8f, 0x2, 0x2, 0x304, 0x29, 0x3, 0x2, 0x2, 0x2, 0x305, 
       0x306, 0x5, 0x1c0, 0xe1, 0x2, 0x306, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x307, 
       0x309, 0x5, 0x12, 0xa, 0x2, 0x308, 0x307, 0x3, 0x2, 0x2, 0x2, 0x308, 
       0x309, 0x3, 0x2, 0x2, 0x2, 0x309, 0x30d, 0x3, 0x2, 0x2, 0x2, 0x30a, 
       0x30b, 0x5, 0x11c, 0x8f, 0x2, 0x30b, 0x30c, 0x7, 0xc8, 0x2, 0x2, 
       0x30c, 0x30e, 0x3, 0x2, 0x2, 0x2, 0x30d, 0x30a, 0x3, 0x2, 0x2, 0x2, 
       0x30d, 0x30e, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x30f, 0x3, 0x2, 0x2, 0x2, 
       0x30f, 0x310, 0x7, 0xac, 0x2, 0x2, 0x310, 0x31b, 0x5, 0x11c, 0x8f, 
       0x2, 0x311, 0x312, 0x5, 0x12, 0xa, 0x2, 0x312, 0x313, 0x7, 0x85, 
       0x2, 0x2, 0x313, 0x314, 0x5, 0x206, 0x104, 0x2, 0x314, 0x315, 0x7, 
       0xc8, 0x2, 0x2, 0x315, 0x316, 0x7, 0xac, 0x2, 0x2, 0x316, 0x317, 
       0x5, 0x11c, 0x8f, 0x2, 0x317, 0x31b, 0x3, 0x2, 0x2, 0x2, 0x318, 0x319, 
       0x7, 0xac, 0x2, 0x2, 0x319, 0x31b, 0x5, 0x11e, 0x90, 0x2, 0x31a, 
       0x308, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x311, 0x3, 0x2, 0x2, 0x2, 0x31a, 
       0x318, 0x3, 0x2, 0x2, 0x2, 0x31b, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x31c, 
       0x337, 0x5, 0x26, 0x14, 0x2, 0x31d, 0x327, 0x7, 0x7b, 0x2, 0x2, 0x31e, 
       0x31f, 0x7, 0x9d, 0x2, 0x2, 0x31f, 0x320, 0x5, 0x172, 0xba, 0x2, 
       0x320, 0x321, 0x7, 0x9e, 0x2, 0x2, 0x321, 0x328, 0x3, 0x2, 0x2, 0x2, 
       0x322, 0x323, 0x7, 0xcc, 0x2, 0x2, 0x323, 0x324, 0x7, 0x9d, 0x2, 
       0x2, 0x324, 0x325, 0x5, 0x4, 0x3, 0x2, 0x325, 0x326, 0x7, 0x9e, 0x2, 
       0x2, 0x326, 0x328, 0x3, 0x2, 0x2, 0x2, 0x327, 0x31e, 0x3, 0x2, 0x2, 
       0x2, 0x327, 0x322, 0x3, 0x2, 0x2, 0x2, 0x328, 0x337, 0x3, 0x2, 0x2, 
       0x2, 0x329, 0x32a, 0x9, 0x9, 0x2, 0x2, 0x32a, 0x337, 0x5, 0x2e, 0x18, 
       0x2, 0x32b, 0x32c, 0x5, 0x30, 0x19, 0x2, 0x32c, 0x32d, 0x5, 0x42, 
       0x22, 0x2, 0x32d, 0x337, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x32f, 0x7, 0x12, 
       0x2, 0x2, 0x32f, 0x330, 0x7, 0x9d, 0x2, 0x2, 0x330, 0x331, 0x5, 0x172, 
       0xba, 0x2, 0x331, 0x332, 0x7, 0x9e, 0x2, 0x2, 0x332, 0x337, 0x3, 
       0x2, 0x2, 0x2, 0x333, 0x337, 0x5, 0x40, 0x21, 0x2, 0x334, 0x337, 
       0x5, 0x32, 0x1a, 0x2, 0x335, 0x337, 0x5, 0x3e, 0x20, 0x2, 0x336, 
       0x31c, 0x3, 0x2, 0x2, 0x2, 0x336, 0x31d, 0x3, 0x2, 0x2, 0x2, 0x336, 
       0x329, 0x3, 0x2, 0x2, 0x2, 0x336, 0x32b, 0x3, 0x2, 0x2, 0x2, 0x336, 
       0x32e, 0x3, 0x2, 0x2, 0x2, 0x336, 0x333, 0x3, 0x2, 0x2, 0x2, 0x336, 
       0x334, 0x3, 0x2, 0x2, 0x2, 0x336, 0x335, 0x3, 0x2, 0x2, 0x2, 0x337, 
       0x2f, 0x3, 0x2, 0x2, 0x2, 0x338, 0x339, 0x9, 0xa, 0x2, 0x2, 0x339, 
       0x31, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x33c, 0x7, 0xc8, 0x2, 0x2, 0x33b, 
       0x33a, 0x3, 0x2, 0x2, 0x2, 0x33b, 0x33c, 0x3, 0x2, 0x2, 0x2, 0x33c, 
       0x33d, 0x3, 0x2, 0x2, 0x2, 0x33d, 0x33f, 0x7, 0x53, 0x2, 0x2, 0x33e, 
       0x340, 0x5, 0x34, 0x1b, 0x2, 0x33f, 0x33e, 0x3, 0x2, 0x2, 0x2, 0x33f, 
       0x340, 0x3, 0x2, 0x2, 0x2, 0x340, 0x346, 0x3, 0x2, 0x2, 0x2, 0x341, 
       0x347, 0x5, 0x36, 0x1c, 0x2, 0x342, 0x343, 0x7, 0x9d, 0x2, 0x2, 0x343, 
       0x344, 0x5, 0x172, 0xba, 0x2, 0x344, 0x345, 0x7, 0x9e, 0x2, 0x2, 
       0x345, 0x347, 0x3, 0x2, 0x2, 0x2, 0x346, 0x341, 0x3, 0x2, 0x2, 0x2, 
       0x346, 0x342, 0x3, 0x2, 0x2, 0x2, 0x347, 0x349, 0x3, 0x2, 0x2, 0x2, 
       0x348, 0x34a, 0x5, 0x3c, 0x1f, 0x2, 0x349, 0x348, 0x3, 0x2, 0x2, 
       0x2, 0x349, 0x34a, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x33, 0x3, 0x2, 0x2, 
       0x2, 0x34b, 0x34c, 0x7, 0x9d, 0x2, 0x2, 0x34c, 0x34d, 0x5, 0x2a, 
       0x16, 0x2, 0x34d, 0x34e, 0x7, 0x9e, 0x2, 0x2, 0x34e, 0x35, 0x3, 0x2, 
       0x2, 0x2, 0x34f, 0x351, 0x5, 0x112, 0x8a, 0x2, 0x350, 0x352, 0x5, 
       0x38, 0x1d, 0x2, 0x351, 0x350, 0x3, 0x2, 0x2, 0x2, 0x351, 0x352, 
       0x3, 0x2, 0x2, 0x2, 0x352, 0x37, 0x3, 0x2, 0x2, 0x2, 0x353, 0x355, 
       0x5, 0x168, 0xb5, 0x2, 0x354, 0x356, 0x5, 0x38, 0x1d, 0x2, 0x355, 
       0x354, 0x3, 0x2, 0x2, 0x2, 0x355, 0x356, 0x3, 0x2, 0x2, 0x2, 0x356, 
       0x359, 0x3, 0x2, 0x2, 0x2, 0x357, 0x359, 0x5, 0x3a, 0x1e, 0x2, 0x358, 
       0x353, 0x3, 0x2, 0x2, 0x2, 0x358, 0x357, 0x3, 0x2, 0x2, 0x2, 0x359, 
       0x39, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x35b, 0x8, 0x1e, 0x1, 0x2, 0x35b, 
       0x35c, 0x7, 0x9f, 0x2, 0x2, 0x35c, 0x35d, 0x5, 0x62, 0x32, 0x2, 0x35d, 
       0x35f, 0x7, 0xa0, 0x2, 0x2, 0x35e, 0x360, 0x5, 0x148, 0xa5, 0x2, 
       0x35f, 0x35e, 0x3, 0x2, 0x2, 0x2, 0x35f, 0x360, 0x3, 0x2, 0x2, 0x2, 
       0x360, 0x36a, 0x3, 0x2, 0x2, 0x2, 0x361, 0x362, 0xc, 0x3, 0x2, 0x2, 
       0x362, 0x363, 0x7, 0x9f, 0x2, 0x2, 0x363, 0x364, 0x5, 0x64, 0x33, 
       0x2, 0x364, 0x366, 0x7, 0xa0, 0x2, 0x2, 0x365, 0x367, 0x5, 0x148, 
       0xa5, 0x2, 0x366, 0x365, 0x3, 0x2, 0x2, 0x2, 0x366, 0x367, 0x3, 0x2, 
       0x2, 0x2, 0x367, 0x369, 0x3, 0x2, 0x2, 0x2, 0x368, 0x361, 0x3, 0x2, 
       0x2, 0x2, 0x369, 0x36c, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x368, 0x3, 0x2, 
       0x2, 0x2, 0x36a, 0x36b, 0x3, 0x2, 0x2, 0x2, 0x36b, 0x3b, 0x3, 0x2, 
       0x2, 0x2, 0x36c, 0x36a, 0x3, 0x2, 0x2, 0x2, 0x36d, 0x36f, 0x7, 0x9d, 
       0x2, 0x2, 0x36e, 0x370, 0x5, 0x2a, 0x16, 0x2, 0x36f, 0x36e, 0x3, 
       0x2, 0x2, 0x2, 0x36f, 0x370, 0x3, 0x2, 0x2, 0x2, 0x370, 0x371, 0x3, 
       0x2, 0x2, 0x2, 0x371, 0x374, 0x7, 0x9e, 0x2, 0x2, 0x372, 0x374, 0x5, 
       0x1c2, 0xe2, 0x2, 0x373, 0x36d, 0x3, 0x2, 0x2, 0x2, 0x373, 0x372, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x375, 0x377, 
       0x7, 0xc8, 0x2, 0x2, 0x376, 0x375, 0x3, 0x2, 0x2, 0x2, 0x376, 0x377, 
       0x3, 0x2, 0x2, 0x2, 0x377, 0x378, 0x3, 0x2, 0x2, 0x2, 0x378, 0x37b, 
       0x7, 0x31, 0x2, 0x2, 0x379, 0x37a, 0x7, 0x9f, 0x2, 0x2, 0x37a, 0x37c, 
       0x7, 0xa0, 0x2, 0x2, 0x37b, 0x379, 0x3, 0x2, 0x2, 0x2, 0x37b, 0x37c, 
       0x3, 0x2, 0x2, 0x2, 0x37c, 0x37d, 0x3, 0x2, 0x2, 0x2, 0x37d, 0x37e, 
       0x5, 0x42, 0x22, 0x2, 0x37e, 0x3f, 0x3, 0x2, 0x2, 0x2, 0x37f, 0x380, 
       0x7, 0x54, 0x2, 0x2, 0x380, 0x381, 0x7, 0x9d, 0x2, 0x2, 0x381, 0x382, 
       0x5, 0x62, 0x32, 0x2, 0x382, 0x383, 0x7, 0x9e, 0x2, 0x2, 0x383, 0x41, 
       0x3, 0x2, 0x2, 0x2, 0x384, 0x38b, 0x5, 0x2e, 0x18, 0x2, 0x385, 0x386, 
       0x7, 0x9d, 0x2, 0x2, 0x386, 0x387, 0x5, 0x172, 0xba, 0x2, 0x387, 
       0x388, 0x7, 0x9e, 0x2, 0x2, 0x388, 0x389, 0x5, 0x42, 0x22, 0x2, 0x389, 
       0x38b, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x384, 0x3, 0x2, 0x2, 0x2, 0x38a, 
       0x385, 0x3, 0x2, 0x2, 0x2, 0x38b, 0x43, 0x3, 0x2, 0x2, 0x2, 0x38c, 
       0x391, 0x5, 0x42, 0x22, 0x2, 0x38d, 0x38e, 0x9, 0xb, 0x2, 0x2, 0x38e, 
       0x390, 0x5, 0x42, 0x22, 0x2, 0x38f, 0x38d, 0x3, 0x2, 0x2, 0x2, 0x390, 
       0x393, 0x3, 0x2, 0x2, 0x2, 0x391, 0x38f, 0x3, 0x2, 0x2, 0x2, 0x391, 
       0x392, 0x3, 0x2, 0x2, 0x2, 0x392, 0x45, 0x3, 0x2, 0x2, 0x2, 0x393, 
       0x391, 0x3, 0x2, 0x2, 0x2, 0x394, 0x399, 0x5, 0x44, 0x23, 0x2, 0x395, 
       0x396, 0x9, 0xc, 0x2, 0x2, 0x396, 0x398, 0x5, 0x44, 0x23, 0x2, 0x397, 
       0x395, 0x3, 0x2, 0x2, 0x2, 0x398, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x399, 
       0x397, 0x3, 0x2, 0x2, 0x2, 0x399, 0x39a, 0x3, 0x2, 0x2, 0x2, 0x39a, 
       0x47, 0x3, 0x2, 0x2, 0x2, 0x39b, 0x399, 0x3, 0x2, 0x2, 0x2, 0x39c, 
       0x3a1, 0x5, 0x46, 0x24, 0x2, 0x39d, 0x39e, 0x9, 0xd, 0x2, 0x2, 0x39e, 
       0x3a0, 0x5, 0x46, 0x24, 0x2, 0x39f, 0x39d, 0x3, 0x2, 0x2, 0x2, 0x3a0, 
       0x3a3, 0x3, 0x2, 0x2, 0x2, 0x3a1, 0x39f, 0x3, 0x2, 0x2, 0x2, 0x3a1, 
       0x3a2, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x49, 0x3, 0x2, 0x2, 0x2, 0x3a3, 
       0x3a1, 0x3, 0x2, 0x2, 0x2, 0x3a4, 0x3aa, 0x5, 0x48, 0x25, 0x2, 0x3a5, 
       0x3a6, 0x5, 0x4c, 0x27, 0x2, 0x3a6, 0x3a7, 0x5, 0x48, 0x25, 0x2, 
       0x3a7, 0x3a9, 0x3, 0x2, 0x2, 0x2, 0x3a8, 0x3a5, 0x3, 0x2, 0x2, 0x2, 
       0x3a9, 0x3ac, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x3a8, 0x3, 0x2, 0x2, 0x2, 
       0x3aa, 0x3ab, 0x3, 0x2, 0x2, 0x2, 0x3ab, 0x4b, 0x3, 0x2, 0x2, 0x2, 
       0x3ac, 0x3aa, 0x3, 0x2, 0x2, 0x2, 0x3ad, 0x3ae, 0x7, 0xb0, 0x2, 0x2, 
       0x3ae, 0x3b2, 0x7, 0xb0, 0x2, 0x2, 0x3af, 0x3b0, 0x7, 0xaf, 0x2, 
       0x2, 0x3b0, 0x3b2, 0x7, 0xaf, 0x2, 0x2, 0x3b1, 0x3ad, 0x3, 0x2, 0x2, 
       0x2, 0x3b1, 0x3af, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x4d, 0x3, 0x2, 0x2, 
       0x2, 0x3b3, 0x3b8, 0x5, 0x4a, 0x26, 0x2, 0x3b4, 0x3b5, 0x9, 0xe, 
       0x2, 0x2, 0x3b5, 0x3b7, 0x5, 0x4a, 0x26, 0x2, 0x3b6, 0x3b4, 0x3, 
       0x2, 0x2, 0x2, 0x3b7, 0x3ba, 0x3, 0x2, 0x2, 0x2, 0x3b8, 0x3b6, 0x3, 
       0x2, 0x2, 0x2, 0x3b8, 0x3b9, 0x3, 0x2, 0x2, 0x2, 0x3b9, 0x4f, 0x3, 
       0x2, 0x2, 0x2, 0x3ba, 0x3b8, 0x3, 0x2, 0x2, 0x2, 0x3bb, 0x3c0, 0x5, 
       0x4e, 0x28, 0x2, 0x3bc, 0x3bd, 0x9, 0xf, 0x2, 0x2, 0x3bd, 0x3bf, 
       0x5, 0x4e, 0x28, 0x2, 0x3be, 0x3bc, 0x3, 0x2, 0x2, 0x2, 0x3bf, 0x3c2, 
       0x3, 0x2, 0x2, 0x2, 0x3c0, 0x3be, 0x3, 0x2, 0x2, 0x2, 0x3c0, 0x3c1, 
       0x3, 0x2, 0x2, 0x2, 0x3c1, 0x51, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x3c0, 
       0x3, 0x2, 0x2, 0x2, 0x3c3, 0x3c8, 0x5, 0x50, 0x29, 0x2, 0x3c4, 0x3c5, 
       0x7, 0xaa, 0x2, 0x2, 0x3c5, 0x3c7, 0x5, 0x50, 0x29, 0x2, 0x3c6, 0x3c4, 
       0x3, 0x2, 0x2, 0x2, 0x3c7, 0x3ca, 0x3, 0x2, 0x2, 0x2, 0x3c8, 0x3c6, 
       0x3, 0x2, 0x2, 0x2, 0x3c8, 0x3c9, 0x3, 0x2, 0x2, 0x2, 0x3c9, 0x53, 
       0x3, 0x2, 0x2, 0x2, 0x3ca, 0x3c8, 0x3, 0x2, 0x2, 0x2, 0x3cb, 0x3d0, 
       0x5, 0x52, 0x2a, 0x2, 0x3cc, 0x3cd, 0x7, 0xa9, 0x2, 0x2, 0x3cd, 0x3cf, 
       0x5, 0x52, 0x2a, 0x2, 0x3ce, 0x3cc, 0x3, 0x2, 0x2, 0x2, 0x3cf, 0x3d2, 
       0x3, 0x2, 0x2, 0x2, 0x3d0, 0x3ce, 0x3, 0x2, 0x2, 0x2, 0x3d0, 0x3d1, 
       0x3, 0x2, 0x2, 0x2, 0x3d1, 0x55, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x3d0, 
       0x3, 0x2, 0x2, 0x2, 0x3d3, 0x3d8, 0x5, 0x54, 0x2b, 0x2, 0x3d4, 0x3d5, 
       0x7, 0xab, 0x2, 0x2, 0x3d5, 0x3d7, 0x5, 0x54, 0x2b, 0x2, 0x3d6, 0x3d4, 
       0x3, 0x2, 0x2, 0x2, 0x3d7, 0x3da, 0x3, 0x2, 0x2, 0x2, 0x3d8, 0x3d6, 
       0x3, 0x2, 0x2, 0x2, 0x3d8, 0x3d9, 0x3, 0x2, 0x2, 0x2, 0x3d9, 0x57, 
       0x3, 0x2, 0x2, 0x2, 0x3da, 0x3d8, 0x3, 0x2, 0x2, 0x2, 0x3db, 0x3e0, 
       0x5, 0x56, 0x2c, 0x2, 0x3dc, 0x3dd, 0x7, 0xbf, 0x2, 0x2, 0x3dd, 0x3df, 
       0x5, 0x56, 0x2c, 0x2, 0x3de, 0x3dc, 0x3, 0x2, 0x2, 0x2, 0x3df, 0x3e2, 
       0x3, 0x2, 0x2, 0x2, 0x3e0, 0x3de, 0x3, 0x2, 0x2, 0x2, 0x3e0, 0x3e1, 
       0x3, 0x2, 0x2, 0x2, 0x3e1, 0x59, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x3e0, 
       0x3, 0x2, 0x2, 0x2, 0x3e3, 0x3e8, 0x5, 0x58, 0x2d, 0x2, 0x3e4, 0x3e5, 
       0x7, 0xc0, 0x2, 0x2, 0x3e5, 0x3e7, 0x5, 0x58, 0x2d, 0x2, 0x3e6, 0x3e4, 
       0x3, 0x2, 0x2, 0x2, 0x3e7, 0x3ea, 0x3, 0x2, 0x2, 0x2, 0x3e8, 0x3e6, 
       0x3, 0x2, 0x2, 0x2, 0x3e8, 0x3e9, 0x3, 0x2, 0x2, 0x2, 0x3e9, 0x5b, 
       0x3, 0x2, 0x2, 0x2, 0x3ea, 0x3e8, 0x3, 0x2, 0x2, 0x2, 0x3eb, 0x3f1, 
       0x5, 0x5a, 0x2e, 0x2, 0x3ec, 0x3ed, 0x7, 0xc6, 0x2, 0x2, 0x3ed, 0x3ee, 
       0x5, 0x62, 0x32, 0x2, 0x3ee, 0x3ef, 0x7, 0xc7, 0x2, 0x2, 0x3ef, 0x3f0, 
       0x5, 0x5e, 0x30, 0x2, 0x3f0, 0x3f2, 0x3, 0x2, 0x2, 0x2, 0x3f1, 0x3ec, 
       0x3, 0x2, 0x2, 0x2, 0x3f1, 0x3f2, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x5d, 
       0x3, 0x2, 0x2, 0x2, 0x3f3, 0x3fa, 0x5, 0x5c, 0x2f, 0x2, 0x3f4, 0x3f5, 
       0x5, 0x5a, 0x2e, 0x2, 0x3f5, 0x3f6, 0x5, 0x60, 0x31, 0x2, 0x3f6, 
       0x3f7, 0x5, 0x1be, 0xe0, 0x2, 0x3f7, 0x3fa, 0x3, 0x2, 0x2, 0x2, 0x3f8, 
       0x3fa, 0x5, 0x220, 0x111, 0x2, 0x3f9, 0x3f3, 0x3, 0x2, 0x2, 0x2, 
       0x3f9, 0x3f4, 0x3, 0x2, 0x2, 0x2, 0x3f9, 0x3f8, 0x3, 0x2, 0x2, 0x2, 
       0x3fa, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x3fb, 0x3fc, 0x9, 0x10, 0x2, 0x2, 
       0x3fc, 0x61, 0x3, 0x2, 0x2, 0x2, 0x3fd, 0x402, 0x5, 0x5e, 0x30, 0x2, 
       0x3fe, 0x3ff, 0x7, 0xc3, 0x2, 0x2, 0x3ff, 0x401, 0x5, 0x5e, 0x30, 
       0x2, 0x400, 0x3fe, 0x3, 0x2, 0x2, 0x2, 0x401, 0x404, 0x3, 0x2, 0x2, 
       0x2, 0x402, 0x400, 0x3, 0x2, 0x2, 0x2, 0x402, 0x403, 0x3, 0x2, 0x2, 
       0x2, 0x403, 0x63, 0x3, 0x2, 0x2, 0x2, 0x404, 0x402, 0x3, 0x2, 0x2, 
       0x2, 0x405, 0x406, 0x5, 0x5c, 0x2f, 0x2, 0x406, 0x65, 0x3, 0x2, 0x2, 
       0x2, 0x407, 0x423, 0x5, 0x68, 0x35, 0x2, 0x408, 0x423, 0x5, 0x6a, 
       0x36, 0x2, 0x409, 0x423, 0x5, 0xac, 0x57, 0x2, 0x40a, 0x423, 0x5, 
       0xb8, 0x5d, 0x2, 0x40b, 0x423, 0x5, 0x6c, 0x37, 0x2, 0x40c, 0x423, 
       0x5, 0x6e, 0x38, 0x2, 0x40d, 0x423, 0x5, 0x8a, 0x46, 0x2, 0x40e, 
       0x423, 0x5, 0x76, 0x3c, 0x2, 0x40f, 0x423, 0x5, 0x78, 0x3d, 0x2, 
       0x410, 0x423, 0x5, 0xa4, 0x53, 0x2, 0x411, 0x423, 0x5, 0x7a, 0x3e, 
       0x2, 0x412, 0x423, 0x5, 0x7c, 0x3f, 0x2, 0x413, 0x414, 0x9, 0x11, 
       0x2, 0x2, 0x414, 0x423, 0x5, 0xc6, 0x64, 0x2, 0x415, 0x423, 0x5, 
       0xc4, 0x63, 0x2, 0x416, 0x423, 0x5, 0xdc, 0x6f, 0x2, 0x417, 0x419, 
       0x5, 0x148, 0xa5, 0x2, 0x418, 0x417, 0x3, 0x2, 0x2, 0x2, 0x418, 0x419, 
       0x3, 0x2, 0x2, 0x2, 0x419, 0x420, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x421, 
       0x5, 0xc8, 0x65, 0x2, 0x41b, 0x421, 0x5, 0xca, 0x66, 0x2, 0x41c, 
       0x421, 0x5, 0xce, 0x68, 0x2, 0x41d, 0x421, 0x5, 0xd2, 0x6a, 0x2, 
       0x41e, 0x421, 0x5, 0xda, 0x6e, 0x2, 0x41f, 0x421, 0x5, 0x216, 0x10c, 
       0x2, 0x420, 0x41a, 0x3, 0x2, 0x2, 0x2, 0x420, 0x41b, 0x3, 0x2, 0x2, 
       0x2, 0x420, 0x41c, 0x3, 0x2, 0x2, 0x2, 0x420, 0x41d, 0x3, 0x2, 0x2, 
       0x2, 0x420, 0x41e, 0x3, 0x2, 0x2, 0x2, 0x420, 0x41f, 0x3, 0x2, 0x2, 
       0x2, 0x421, 0x423, 0x3, 0x2, 0x2, 0x2, 0x422, 0x407, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x408, 0x3, 0x2, 0x2, 0x2, 0x422, 0x409, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x40a, 0x3, 0x2, 0x2, 0x2, 0x422, 0x40b, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x40c, 0x3, 0x2, 0x2, 0x2, 0x422, 0x40d, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x40e, 0x3, 0x2, 0x2, 0x2, 0x422, 0x40f, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x410, 0x3, 0x2, 0x2, 0x2, 0x422, 0x411, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x412, 0x3, 0x2, 0x2, 0x2, 0x422, 0x413, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x415, 0x3, 0x2, 0x2, 0x2, 0x422, 0x416, 0x3, 0x2, 0x2, 
       0x2, 0x422, 0x418, 0x3, 0x2, 0x2, 0x2, 0x423, 0x67, 0x3, 0x2, 0x2, 
       0x2, 0x424, 0x426, 0x5, 0x148, 0xa5, 0x2, 0x425, 0x424, 0x3, 0x2, 
       0x2, 0x2, 0x425, 0x426, 0x3, 0x2, 0x2, 0x2, 0x426, 0x42b, 0x3, 0x2, 
       0x2, 0x2, 0x427, 0x42c, 0x5, 0x4, 0x3, 0x2, 0x428, 0x429, 0x7, 0x18, 
       0x2, 0x2, 0x429, 0x42c, 0x5, 0x64, 0x33, 0x2, 0x42a, 0x42c, 0x7, 
       0x30, 0x2, 0x2, 0x42b, 0x427, 0x3, 0x2, 0x2, 0x2, 0x42b, 0x428, 0x3, 
       0x2, 0x2, 0x2, 0x42b, 0x42a, 0x3, 0x2, 0x2, 0x2, 0x42c, 0x42d, 0x3, 
       0x2, 0x2, 0x2, 0x42d, 0x42e, 0x7, 0xc7, 0x2, 0x2, 0x42e, 0x42f, 0x5, 
       0x66, 0x34, 0x2, 0x42f, 0x69, 0x3, 0x2, 0x2, 0x2, 0x430, 0x431, 0x9, 
       0x12, 0x2, 0x2, 0x431, 0x432, 0x7, 0xc9, 0x2, 0x2, 0x432, 0x6b, 0x3, 
       0x2, 0x2, 0x2, 0x433, 0x434, 0x7, 0xa6, 0x2, 0x2, 0x434, 0x435, 0x7, 
       0xcd, 0x2, 0x2, 0x435, 0x436, 0x7, 0xaf, 0x2, 0x2, 0x436, 0x437, 
       0x7, 0xaf, 0x2, 0x2, 0x437, 0x438, 0x7, 0x9f, 0x2, 0x2, 0x438, 0x439, 
       0x8, 0x37, 0x1, 0x2, 0x439, 0x43e, 0x5, 0x70, 0x39, 0x2, 0x43a, 0x43b, 
       0x7, 0xc3, 0x2, 0x2, 0x43b, 0x43d, 0x5, 0x70, 0x39, 0x2, 0x43c, 0x43a, 
       0x3, 0x2, 0x2, 0x2, 0x43d, 0x440, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x43c, 
       0x3, 0x2, 0x2, 0x2, 0x43e, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x43f, 0x441, 
       0x3, 0x2, 0x2, 0x2, 0x440, 0x43e, 0x3, 0x2, 0x2, 0x2, 0x441, 0x442, 
       0x7, 0xa0, 0x2, 0x2, 0x442, 0x443, 0x7, 0xc9, 0x2, 0x2, 0x443, 0x6d, 
       0x3, 0x2, 0x2, 0x2, 0x444, 0x445, 0x7, 0xa6, 0x2, 0x2, 0x445, 0x446, 
       0x7, 0xcd, 0x2, 0x2, 0x446, 0x447, 0x7, 0xb0, 0x2, 0x2, 0x447, 0x448, 
       0x7, 0xb0, 0x2, 0x2, 0x448, 0x449, 0x7, 0x9f, 0x2, 0x2, 0x449, 0x44a, 
       0x8, 0x38, 0x1, 0x2, 0x44a, 0x44f, 0x5, 0x72, 0x3a, 0x2, 0x44b, 0x44c, 
       0x7, 0xc3, 0x2, 0x2, 0x44c, 0x44e, 0x5, 0x72, 0x3a, 0x2, 0x44d, 0x44b, 
       0x3, 0x2, 0x2, 0x2, 0x44e, 0x451, 0x3, 0x2, 0x2, 0x2, 0x44f, 0x44d, 
       0x3, 0x2, 0x2, 0x2, 0x44f, 0x450, 0x3, 0x2, 0x2, 0x2, 0x450, 0x452, 
       0x3, 0x2, 0x2, 0x2, 0x451, 0x44f, 0x3, 0x2, 0x2, 0x2, 0x452, 0x453, 
       0x7, 0xa0, 0x2, 0x2, 0x453, 0x454, 0x7, 0xc9, 0x2, 0x2, 0x454, 0x6f, 
       0x3, 0x2, 0x2, 0x2, 0x455, 0x459, 0x7, 0xa3, 0x2, 0x2, 0x456, 0x459, 
       0x5, 0x74, 0x3b, 0x2, 0x457, 0x459, 0x5, 0x62, 0x32, 0x2, 0x458, 
       0x455, 0x3, 0x2, 0x2, 0x2, 0x458, 0x456, 0x3, 0x2, 0x2, 0x2, 0x458, 
       0x457, 0x3, 0x2, 0x2, 0x2, 0x459, 0x71, 0x3, 0x2, 0x2, 0x2, 0x45a, 
       0x45e, 0x7, 0xa3, 0x2, 0x2, 0x45b, 0x45e, 0x5, 0x74, 0x3b, 0x2, 0x45c, 
       0x45e, 0x7, 0xcd, 0x2, 0x2, 0x45d, 0x45a, 0x3, 0x2, 0x2, 0x2, 0x45d, 
       0x45b, 0x3, 0x2, 0x2, 0x2, 0x45d, 0x45c, 0x3, 0x2, 0x2, 0x2, 0x45e, 
       0x73, 0x3, 0x2, 0x2, 0x2, 0x45f, 0x462, 0x7, 0xcd, 0x2, 0x2, 0x460, 
       0x461, 0x7, 0x9f, 0x2, 0x2, 0x461, 0x463, 0x7, 0xa0, 0x2, 0x2, 0x462, 
       0x460, 0x3, 0x2, 0x2, 0x2, 0x463, 0x464, 0x3, 0x2, 0x2, 0x2, 0x464, 
       0x462, 0x3, 0x2, 0x2, 0x2, 0x464, 0x465, 0x3, 0x2, 0x2, 0x2, 0x465, 
       0x75, 0x3, 0x2, 0x2, 0x2, 0x466, 0x474, 0x6, 0x3c, 0xa, 0x2, 0x467, 
       0x475, 0x5, 0x7e, 0x40, 0x2, 0x468, 0x475, 0x5, 0x82, 0x42, 0x2, 
       0x469, 0x475, 0x5, 0x8c, 0x47, 0x2, 0x46a, 0x475, 0x5, 0x8e, 0x48, 
       0x2, 0x46b, 0x475, 0x5, 0x80, 0x41, 0x2, 0x46c, 0x475, 0x5, 0x84, 
       0x43, 0x2, 0x46d, 0x475, 0x5, 0x86, 0x44, 0x2, 0x46e, 0x475, 0x5, 
       0x88, 0x45, 0x2, 0x46f, 0x475, 0x5, 0x90, 0x49, 0x2, 0x470, 0x475, 
       0x5, 0x92, 0x4a, 0x2, 0x471, 0x475, 0x5, 0x94, 0x4b, 0x2, 0x472, 
       0x475, 0x5, 0x9a, 0x4e, 0x2, 0x473, 0x475, 0x5, 0x96, 0x4c, 0x2, 
       0x474, 0x467, 0x3, 0x2, 0x2, 0x2, 0x474, 0x468, 0x3, 0x2, 0x2, 0x2, 
       0x474, 0x469, 0x3, 0x2, 0x2, 0x2, 0x474, 0x46a, 0x3, 0x2, 0x2, 0x2, 
       0x474, 0x46b, 0x3, 0x2, 0x2, 0x2, 0x474, 0x46c, 0x3, 0x2, 0x2, 0x2, 
       0x474, 0x46d, 0x3, 0x2, 0x2, 0x2, 0x474, 0x46e, 0x3, 0x2, 0x2, 0x2, 
       0x474, 0x46f, 0x3, 0x2, 0x2, 0x2, 0x474, 0x470, 0x3, 0x2, 0x2, 0x2, 
       0x474, 0x471, 0x3, 0x2, 0x2, 0x2, 0x474, 0x472, 0x3, 0x2, 0x2, 0x2, 
       0x474, 0x473, 0x3, 0x2, 0x2, 0x2, 0x475, 0x77, 0x3, 0x2, 0x2, 0x2, 
       0x476, 0x479, 0x6, 0x3d, 0xb, 0x2, 0x477, 0x47a, 0x5, 0x9c, 0x4f, 
       0x2, 0x478, 0x47a, 0x5, 0x9e, 0x50, 0x2, 0x479, 0x477, 0x3, 0x2, 
       0x2, 0x2, 0x479, 0x478, 0x3, 0x2, 0x2, 0x2, 0x47a, 0x79, 0x3, 0x2, 
       0x2, 0x2, 0x47b, 0x47c, 0x6, 0x3e, 0xc, 0x2, 0x47c, 0x47d, 0x7, 0x5a, 
       0x2, 0x2, 0x47d, 0x47e, 0x5, 0xca, 0x66, 0x2, 0x47e, 0x7b, 0x3, 0x2, 
       0x2, 0x2, 0x47f, 0x480, 0x7, 0x8b, 0x2, 0x2, 0x480, 0x481, 0x7, 0x9d, 
       0x2, 0x2, 0x481, 0x482, 0x5, 0x6, 0x4, 0x2, 0x482, 0x483, 0x7, 0x9e, 
       0x2, 0x2, 0x483, 0x484, 0x5, 0xca, 0x66, 0x2, 0x484, 0x7d, 0x3, 0x2, 
       0x2, 0x2, 0x485, 0x486, 0x7, 0x5d, 0x2, 0x2, 0x486, 0x487, 0x7, 0x9d, 
       0x2, 0x2, 0x487, 0x488, 0x5, 0xa0, 0x51, 0x2, 0x488, 0x489, 0x7, 
       0x9e, 0x2, 0x2, 0x489, 0x48a, 0x7, 0xc9, 0x2, 0x2, 0x48a, 0x7f, 0x3, 
       0x2, 0x2, 0x2, 0x48b, 0x48c, 0x7, 0x5e, 0x2, 0x2, 0x48c, 0x48d, 0x7, 
       0x9d, 0x2, 0x2, 0x48d, 0x48e, 0x5, 0x62, 0x32, 0x2, 0x48e, 0x48f, 
       0x7, 0x9e, 0x2, 0x2, 0x48f, 0x490, 0x7, 0xc9, 0x2, 0x2, 0x490, 0x81, 
       0x3, 0x2, 0x2, 0x2, 0x491, 0x492, 0x7, 0x67, 0x2, 0x2, 0x492, 0x493, 
       0x7, 0x9d, 0x2, 0x2, 0x493, 0x494, 0x5, 0xa0, 0x51, 0x2, 0x494, 0x495, 
       0x7, 0x9e, 0x2, 0x2, 0x495, 0x496, 0x7, 0xc9, 0x2, 0x2, 0x496, 0x83, 
       0x3, 0x2, 0x2, 0x2, 0x497, 0x498, 0x7, 0x5f, 0x2, 0x2, 0x498, 0x499, 
       0x7, 0x9d, 0x2, 0x2, 0x499, 0x49a, 0x5, 0x62, 0x32, 0x2, 0x49a, 0x49b, 
       0x7, 0x9e, 0x2, 0x2, 0x49b, 0x49c, 0x7, 0xc9, 0x2, 0x2, 0x49c, 0x85, 
       0x3, 0x2, 0x2, 0x2, 0x49d, 0x49e, 0x7, 0x6a, 0x2, 0x2, 0x49e, 0x49f, 
       0x7, 0x9d, 0x2, 0x2, 0x49f, 0x4a0, 0x5, 0x4, 0x3, 0x2, 0x4a0, 0x4a1, 
       0x7, 0x9e, 0x2, 0x2, 0x4a1, 0x4a2, 0x7, 0xc9, 0x2, 0x2, 0x4a2, 0x87, 
       0x3, 0x2, 0x2, 0x2, 0x4a3, 0x4a4, 0x7, 0x6b, 0x2, 0x2, 0x4a4, 0x4a5, 
       0x7, 0x9d, 0x2, 0x2, 0x4a5, 0x4a6, 0x5, 0x4, 0x3, 0x2, 0x4a6, 0x4a7, 
       0x7, 0x9e, 0x2, 0x2, 0x4a7, 0x4a8, 0x7, 0xc9, 0x2, 0x2, 0x4a8, 0x89, 
       0x3, 0x2, 0x2, 0x2, 0x4a9, 0x4aa, 0x7, 0x5c, 0x2, 0x2, 0x4aa, 0x4ab, 
       0x7, 0x9d, 0x2, 0x2, 0x4ab, 0x4ac, 0x5, 0x4, 0x3, 0x2, 0x4ac, 0x4ad, 
       0x7, 0x9e, 0x2, 0x2, 0x4ad, 0x4ae, 0x5, 0xca, 0x66, 0x2, 0x4ae, 0x8b, 
       0x3, 0x2, 0x2, 0x2, 0x4af, 0x4b0, 0x7, 0x6c, 0x2, 0x2, 0x4b0, 0x4b1, 
       0x7, 0xc9, 0x2, 0x2, 0x4b1, 0x8d, 0x3, 0x2, 0x2, 0x2, 0x4b2, 0x4b3, 
       0x7, 0x26, 0x2, 0x2, 0x4b3, 0x4b4, 0x7, 0xc9, 0x2, 0x2, 0x4b4, 0x8f, 
       0x3, 0x2, 0x2, 0x2, 0x4b5, 0x4b6, 0x7, 0x61, 0x2, 0x2, 0x4b6, 0x4b7, 
       0x7, 0xc9, 0x2, 0x2, 0x4b7, 0x91, 0x3, 0x2, 0x2, 0x2, 0x4b8, 0x4b9, 
       0x7, 0x62, 0x2, 0x2, 0x4b9, 0x4ba, 0x7, 0xc9, 0x2, 0x2, 0x4ba, 0x93, 
       0x3, 0x2, 0x2, 0x2, 0x4bb, 0x4bc, 0x7, 0x63, 0x2, 0x2, 0x4bc, 0x4bd, 
       0x7, 0xc9, 0x2, 0x2, 0x4bd, 0x95, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4bf, 
       0x7, 0x60, 0x2, 0x2, 0x4bf, 0x4c0, 0x7, 0xc9, 0x2, 0x2, 0x4c0, 0x97, 
       0x3, 0x2, 0x2, 0x2, 0x4c1, 0x4c2, 0x7, 0x64, 0x2, 0x2, 0x4c2, 0x4c3, 
       0x7, 0xc9, 0x2, 0x2, 0x4c3, 0x99, 0x3, 0x2, 0x2, 0x2, 0x4c4, 0x4c5, 
       0x7, 0x65, 0x2, 0x2, 0x4c5, 0x4c6, 0x8, 0x4e, 0x1, 0x2, 0x4c6, 0x4c7, 
       0x7, 0x9d, 0x2, 0x2, 0x4c7, 0x4c8, 0x5, 0x5e, 0x30, 0x2, 0x4c8, 0x4c9, 
       0x7, 0x9e, 0x2, 0x2, 0x4c9, 0x4ca, 0x7, 0xc9, 0x2, 0x2, 0x4ca, 0x9b, 
       0x3, 0x2, 0x2, 0x2, 0x4cb, 0x4cc, 0x7, 0x89, 0x2, 0x2, 0x4cc, 0x4cd, 
       0x7, 0x9d, 0x2, 0x2, 0x4cd, 0x4ce, 0x5, 0xa0, 0x51, 0x2, 0x4ce, 0x4cf, 
       0x7, 0x9e, 0x2, 0x2, 0x4cf, 0x4d0, 0x7, 0xc9, 0x2, 0x2, 0x4d0, 0x9d, 
       0x3, 0x2, 0x2, 0x2, 0x4d1, 0x4d2, 0x7, 0x8a, 0x2, 0x2, 0x4d2, 0x4d3, 
       0x7, 0x9d, 0x2, 0x2, 0x4d3, 0x4d4, 0x5, 0xa0, 0x51, 0x2, 0x4d4, 0x4d5, 
       0x7, 0x9e, 0x2, 0x2, 0x4d5, 0x4d6, 0x7, 0xc9, 0x2, 0x2, 0x4d6, 0x9f, 
       0x3, 0x2, 0x2, 0x2, 0x4d7, 0x4d9, 0x5, 0x5e, 0x30, 0x2, 0x4d8, 0x4da, 
       0x5, 0xa2, 0x52, 0x2, 0x4d9, 0x4d8, 0x3, 0x2, 0x2, 0x2, 0x4d9, 0x4da, 
       0x3, 0x2, 0x2, 0x2, 0x4da, 0x4e2, 0x3, 0x2, 0x2, 0x2, 0x4db, 0x4dc, 
       0x7, 0xc3, 0x2, 0x2, 0x4dc, 0x4de, 0x5, 0x5e, 0x30, 0x2, 0x4dd, 0x4df, 
       0x5, 0xa2, 0x52, 0x2, 0x4de, 0x4dd, 0x3, 0x2, 0x2, 0x2, 0x4de, 0x4df, 
       0x3, 0x2, 0x2, 0x2, 0x4df, 0x4e1, 0x3, 0x2, 0x2, 0x2, 0x4e0, 0x4db, 
       0x3, 0x2, 0x2, 0x2, 0x4e1, 0x4e4, 0x3, 0x2, 0x2, 0x2, 0x4e2, 0x4e0, 
       0x3, 0x2, 0x2, 0x2, 0x4e2, 0x4e3, 0x3, 0x2, 0x2, 0x2, 0x4e3, 0xa1, 
       0x3, 0x2, 0x2, 0x2, 0x4e4, 0x4e2, 0x3, 0x2, 0x2, 0x2, 0x4e5, 0x4e6, 
       0x7, 0xad, 0x2, 0x2, 0x4e6, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x4e7, 0x4eb, 
       0x5, 0xa6, 0x54, 0x2, 0x4e8, 0x4eb, 0x5, 0xa8, 0x55, 0x2, 0x4e9, 
       0x4eb, 0x5, 0xaa, 0x56, 0x2, 0x4ea, 0x4e7, 0x3, 0x2, 0x2, 0x2, 0x4ea, 
       0x4e8, 0x3, 0x2, 0x2, 0x2, 0x4ea, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x4eb, 
       0xa5, 0x3, 0x2, 0x2, 0x2, 0x4ec, 0x4ed, 0x7, 0x2c, 0x2, 0x2, 0x4ed, 
       0x4ee, 0x5, 0x4, 0x3, 0x2, 0x4ee, 0x4ef, 0x8, 0x54, 0x1, 0x2, 0x4ef, 
       0x4f1, 0x7, 0x9d, 0x2, 0x2, 0x4f0, 0x4f2, 0x5, 0x62, 0x32, 0x2, 0x4f1, 
       0x4f0, 0x3, 0x2, 0x2, 0x2, 0x4f1, 0x4f2, 0x3, 0x2, 0x2, 0x2, 0x4f2, 
       0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f3, 0x4f6, 0x7, 0x9e, 0x2, 0x2, 0x4f4, 
       0x4f5, 0x7, 0xa7, 0x2, 0x2, 0x4f5, 0x4f7, 0x5, 0x6, 0x4, 0x2, 0x4f6, 
       0x4f4, 0x3, 0x2, 0x2, 0x2, 0x4f6, 0x4f7, 0x3, 0x2, 0x2, 0x2, 0x4f7, 
       0x4f8, 0x3, 0x2, 0x2, 0x2, 0x4f8, 0x4f9, 0x7, 0xc9, 0x2, 0x2, 0x4f9, 
       0xa7, 0x3, 0x2, 0x2, 0x2, 0x4fa, 0x4fb, 0x5, 0x4, 0x3, 0x2, 0x4fb, 
       0x4fc, 0x7, 0x9d, 0x2, 0x2, 0x4fc, 0x4fd, 0x7, 0x9f, 0x2, 0x2, 0x4fd, 
       0x4ff, 0x8, 0x55, 0x1, 0x2, 0x4fe, 0x500, 0x5, 0x62, 0x32, 0x2, 0x4ff, 
       0x4fe, 0x3, 0x2, 0x2, 0x2, 0x4ff, 0x500, 0x3, 0x2, 0x2, 0x2, 0x500, 
       0x501, 0x3, 0x2, 0x2, 0x2, 0x501, 0x502, 0x7, 0xa0, 0x2, 0x2, 0x502, 
       0x505, 0x7, 0x9e, 0x2, 0x2, 0x503, 0x504, 0x7, 0xa7, 0x2, 0x2, 0x504, 
       0x506, 0x5, 0x6, 0x4, 0x2, 0x505, 0x503, 0x3, 0x2, 0x2, 0x2, 0x505, 
       0x506, 0x3, 0x2, 0x2, 0x2, 0x506, 0x507, 0x3, 0x2, 0x2, 0x2, 0x507, 
       0x508, 0x7, 0xc9, 0x2, 0x2, 0x508, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x509, 
       0x50a, 0x5, 0x4, 0x3, 0x2, 0x50a, 0x50c, 0x7, 0x9d, 0x2, 0x2, 0x50b, 
       0x50d, 0x5, 0x62, 0x32, 0x2, 0x50c, 0x50b, 0x3, 0x2, 0x2, 0x2, 0x50c, 
       0x50d, 0x3, 0x2, 0x2, 0x2, 0x50d, 0x50e, 0x3, 0x2, 0x2, 0x2, 0x50e, 
       0x50f, 0x7, 0x9e, 0x2, 0x2, 0x50f, 0x510, 0x8, 0x56, 0x1, 0x2, 0x510, 
       0x511, 0x7, 0xa7, 0x2, 0x2, 0x511, 0x512, 0x5, 0x6, 0x4, 0x2, 0x512, 
       0x513, 0x7, 0xc9, 0x2, 0x2, 0x513, 0xab, 0x3, 0x2, 0x2, 0x2, 0x514, 
       0x517, 0x5, 0xae, 0x58, 0x2, 0x515, 0x517, 0x5, 0xb0, 0x59, 0x2, 
       0x516, 0x514, 0x3, 0x2, 0x2, 0x2, 0x516, 0x515, 0x3, 0x2, 0x2, 0x2, 
       0x517, 0xad, 0x3, 0x2, 0x2, 0x2, 0x518, 0x519, 0x7, 0x5b, 0x2, 0x2, 
       0x519, 0x51a, 0x7, 0x9d, 0x2, 0x2, 0x51a, 0x51b, 0x5, 0x6, 0x4, 0x2, 
       0x51b, 0x51c, 0x7, 0xc3, 0x2, 0x2, 0x51c, 0x51d, 0x5, 0xb2, 0x5a, 
       0x2, 0x51d, 0x51e, 0x7, 0x9e, 0x2, 0x2, 0x51e, 0x51f, 0x7, 0xc9, 
       0x2, 0x2, 0x51f, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x520, 0x526, 0x8, 0x59, 
       0x1, 0x2, 0x521, 0x522, 0x7, 0x27, 0x2, 0x2, 0x522, 0x523, 0x7, 0x9d, 
       0x2, 0x2, 0x523, 0x524, 0x5, 0x5e, 0x30, 0x2, 0x524, 0x525, 0x7, 
       0x9e, 0x2, 0x2, 0x525, 0x527, 0x3, 0x2, 0x2, 0x2, 0x526, 0x521, 0x3, 
       0x2, 0x2, 0x2, 0x526, 0x527, 0x3, 0x2, 0x2, 0x2, 0x527, 0x528, 0x3, 
       0x2, 0x2, 0x2, 0x528, 0x529, 0x7, 0x68, 0x2, 0x2, 0x529, 0x52a, 0x7, 
       0x9d, 0x2, 0x2, 0x52a, 0x52b, 0x5, 0x6, 0x4, 0x2, 0x52b, 0x52c, 0x7, 
       0xc3, 0x2, 0x2, 0x52c, 0x52d, 0x5, 0xb2, 0x5a, 0x2, 0x52d, 0x52e, 
       0x7, 0x9e, 0x2, 0x2, 0x52e, 0x52f, 0x7, 0xc9, 0x2, 0x2, 0x52f, 0xb1, 
       0x3, 0x2, 0x2, 0x2, 0x530, 0x533, 0x5, 0xb4, 0x5b, 0x2, 0x531, 0x533, 
       0x5, 0xb6, 0x5c, 0x2, 0x532, 0x530, 0x3, 0x2, 0x2, 0x2, 0x532, 0x531, 
       0x3, 0x2, 0x2, 0x2, 0x533, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x534, 0x535, 
       0x5, 0x6, 0x4, 0x2, 0x535, 0x536, 0x6, 0x5b, 0xd, 0x3, 0x536, 0x537, 
       0x7, 0xc3, 0x2, 0x2, 0x537, 0x538, 0x5, 0xc2, 0x62, 0x2, 0x538, 0xb5, 
       0x3, 0x2, 0x2, 0x2, 0x539, 0x53e, 0x5, 0xc2, 0x62, 0x2, 0x53a, 0x53b, 
       0x9, 0x13, 0x2, 0x2, 0x53b, 0x53d, 0x5, 0xc2, 0x62, 0x2, 0x53c, 0x53a, 
       0x3, 0x2, 0x2, 0x2, 0x53d, 0x540, 0x3, 0x2, 0x2, 0x2, 0x53e, 0x53c, 
       0x3, 0x2, 0x2, 0x2, 0x53e, 0x53f, 0x3, 0x2, 0x2, 0x2, 0x53f, 0xb7, 
       0x3, 0x2, 0x2, 0x2, 0x540, 0x53e, 0x3, 0x2, 0x2, 0x2, 0x541, 0x547, 
       0x8, 0x5d, 0x1, 0x2, 0x542, 0x543, 0x7, 0x27, 0x2, 0x2, 0x543, 0x544, 
       0x7, 0x9d, 0x2, 0x2, 0x544, 0x545, 0x5, 0x5e, 0x30, 0x2, 0x545, 0x546, 
       0x7, 0x9e, 0x2, 0x2, 0x546, 0x548, 0x3, 0x2, 0x2, 0x2, 0x547, 0x542, 
       0x3, 0x2, 0x2, 0x2, 0x547, 0x548, 0x3, 0x2, 0x2, 0x2, 0x548, 0x549, 
       0x3, 0x2, 0x2, 0x2, 0x549, 0x54a, 0x7, 0x6d, 0x2, 0x2, 0x54a, 0x54c, 
       0x7, 0xa1, 0x2, 0x2, 0x54b, 0x54d, 0x5, 0xba, 0x5e, 0x2, 0x54c, 0x54b, 
       0x3, 0x2, 0x2, 0x2, 0x54d, 0x54e, 0x3, 0x2, 0x2, 0x2, 0x54e, 0x54c, 
       0x3, 0x2, 0x2, 0x2, 0x54e, 0x54f, 0x3, 0x2, 0x2, 0x2, 0x54f, 0x550, 
       0x3, 0x2, 0x2, 0x2, 0x550, 0x553, 0x7, 0xa2, 0x2, 0x2, 0x551, 0x552, 
       0x7, 0xa7, 0x2, 0x2, 0x552, 0x554, 0x5, 0x6, 0x4, 0x2, 0x553, 0x551, 
       0x3, 0x2, 0x2, 0x2, 0x553, 0x554, 0x3, 0x2, 0x2, 0x2, 0x554, 0x555, 
       0x3, 0x2, 0x2, 0x2, 0x555, 0x556, 0x7, 0xc9, 0x2, 0x2, 0x556, 0xb9, 
       0x3, 0x2, 0x2, 0x2, 0x557, 0x55a, 0x5, 0xbc, 0x5f, 0x2, 0x558, 0x55a, 
       0x5, 0xbe, 0x60, 0x2, 0x559, 0x557, 0x3, 0x2, 0x2, 0x2, 0x559, 0x558, 
       0x3, 0x2, 0x2, 0x2, 0x55a, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55c, 
       0x7, 0xc9, 0x2, 0x2, 0x55c, 0xbb, 0x3, 0x2, 0x2, 0x2, 0x55d, 0x55e, 
       0x7, 0x68, 0x2, 0x2, 0x55e, 0x55f, 0x7, 0x9d, 0x2, 0x2, 0x55f, 0x564, 
       0x5, 0xc0, 0x61, 0x2, 0x560, 0x561, 0x9, 0x13, 0x2, 0x2, 0x561, 0x563, 
       0x5, 0xc0, 0x61, 0x2, 0x562, 0x560, 0x3, 0x2, 0x2, 0x2, 0x563, 0x566, 
       0x3, 0x2, 0x2, 0x2, 0x564, 0x562, 0x3, 0x2, 0x2, 0x2, 0x564, 0x565, 
       0x3, 0x2, 0x2, 0x2, 0x565, 0x567, 0x3, 0x2, 0x2, 0x2, 0x566, 0x564, 
       0x3, 0x2, 0x2, 0x2, 0x567, 0x568, 0x7, 0x9e, 0x2, 0x2, 0x568, 0xbd, 
       0x3, 0x2, 0x2, 0x2, 0x569, 0x56a, 0x7, 0x69, 0x2, 0x2, 0x56a, 0x56b, 
       0x7, 0x9d, 0x2, 0x2, 0x56b, 0x56c, 0x5, 0xc0, 0x61, 0x2, 0x56c, 0x56d, 
       0x9, 0x13, 0x2, 0x2, 0x56d, 0x56e, 0x5, 0xc0, 0x61, 0x2, 0x56e, 0x56f, 
       0x7, 0x9e, 0x2, 0x2, 0x56f, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x570, 0x578, 
       0x7, 0xcd, 0x2, 0x2, 0x571, 0x573, 0x7, 0x9f, 0x2, 0x2, 0x572, 0x574, 
       0x7, 0x3, 0x2, 0x2, 0x573, 0x572, 0x3, 0x2, 0x2, 0x2, 0x574, 0x575, 
       0x3, 0x2, 0x2, 0x2, 0x575, 0x573, 0x3, 0x2, 0x2, 0x2, 0x575, 0x576, 
       0x3, 0x2, 0x2, 0x2, 0x576, 0x577, 0x3, 0x2, 0x2, 0x2, 0x577, 0x579, 
       0x7, 0xa0, 0x2, 0x2, 0x578, 0x571, 0x3, 0x2, 0x2, 0x2, 0x578, 0x579, 
       0x3, 0x2, 0x2, 0x2, 0x579, 0x57a, 0x3, 0x2, 0x2, 0x2, 0x57a, 0x57b, 
       0x8, 0x61, 0x1, 0x2, 0x57b, 0x57d, 0x7, 0x9d, 0x2, 0x2, 0x57c, 0x57e, 
       0x5, 0x62, 0x32, 0x2, 0x57d, 0x57c, 0x3, 0x2, 0x2, 0x2, 0x57d, 0x57e, 
       0x3, 0x2, 0x2, 0x2, 0x57e, 0x57f, 0x3, 0x2, 0x2, 0x2, 0x57f, 0x582, 
       0x7, 0x9e, 0x2, 0x2, 0x580, 0x581, 0x7, 0xa7, 0x2, 0x2, 0x581, 0x583, 
       0x5, 0x6, 0x4, 0x2, 0x582, 0x580, 0x3, 0x2, 0x2, 0x2, 0x582, 0x583, 
       0x3, 0x2, 0x2, 0x2, 0x583, 0xc1, 0x3, 0x2, 0x2, 0x2, 0x584, 0x585, 
       0x7, 0xcd, 0x2, 0x2, 0x585, 0x586, 0x8, 0x62, 0x1, 0x2, 0x586, 0x588, 
       0x7, 0x9d, 0x2, 0x2, 0x587, 0x589, 0x5, 0x62, 0x32, 0x2, 0x588, 0x587, 
       0x3, 0x2, 0x2, 0x2, 0x588, 0x589, 0x3, 0x2, 0x2, 0x2, 0x589, 0x58a, 
       0x3, 0x2, 0x2, 0x2, 0x58a, 0x58d, 0x7, 0x9e, 0x2, 0x2, 0x58b, 0x58c, 
       0x7, 0xa7, 0x2, 0x2, 0x58c, 0x58e, 0x5, 0x6, 0x4, 0x2, 0x58d, 0x58b, 
       0x3, 0x2, 0x2, 0x2, 0x58d, 0x58e, 0x3, 0x2, 0x2, 0x2, 0x58e, 0xc3, 
       0x3, 0x2, 0x2, 0x2, 0x58f, 0x590, 0x5, 0x10, 0x9, 0x2, 0x590, 0x592, 
       0x7, 0x9d, 0x2, 0x2, 0x591, 0x593, 0x5, 0x62, 0x32, 0x2, 0x592, 0x591, 
       0x3, 0x2, 0x2, 0x2, 0x592, 0x593, 0x3, 0x2, 0x2, 0x2, 0x593, 0x594, 
       0x3, 0x2, 0x2, 0x2, 0x594, 0x595, 0x7, 0x9e, 0x2, 0x2, 0x595, 0x596, 
       0x7, 0xc9, 0x2, 0x2, 0x596, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x597, 0x598, 
       0x5, 0x8, 0x5, 0x2, 0x598, 0x59a, 0x7, 0x9d, 0x2, 0x2, 0x599, 0x59b, 
       0x5, 0x62, 0x32, 0x2, 0x59a, 0x599, 0x3, 0x2, 0x2, 0x2, 0x59a, 0x59b, 
       0x3, 0x2, 0x2, 0x2, 0x59b, 0x59c, 0x3, 0x2, 0x2, 0x2, 0x59c, 0x59d, 
       0x7, 0x9e, 0x2, 0x2, 0x59d, 0x59e, 0x7, 0xc9, 0x2, 0x2, 0x59e, 0xc7, 
       0x3, 0x2, 0x2, 0x2, 0x59f, 0x5a1, 0x5, 0x62, 0x32, 0x2, 0x5a0, 0x59f, 
       0x3, 0x2, 0x2, 0x2, 0x5a0, 0x5a1, 0x3, 0x2, 0x2, 0x2, 0x5a1, 0x5a2, 
       0x3, 0x2, 0x2, 0x2, 0x5a2, 0x5a3, 0x7, 0xc9, 0x2, 0x2, 0x5a3, 0xc9, 
       0x3, 0x2, 0x2, 0x2, 0x5a4, 0x5a6, 0x7, 0xa1, 0x2, 0x2, 0x5a5, 0x5a7, 
       0x5, 0xcc, 0x67, 0x2, 0x5a6, 0x5a5, 0x3, 0x2, 0x2, 0x2, 0x5a6, 0x5a7, 
       0x3, 0x2, 0x2, 0x2, 0x5a7, 0x5a8, 0x3, 0x2, 0x2, 0x2, 0x5a8, 0x5a9, 
       0x7, 0xa2, 0x2, 0x2, 0x5a9, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x5aa, 0x5ac, 
       0x5, 0x66, 0x34, 0x2, 0x5ab, 0x5aa, 0x3, 0x2, 0x2, 0x2, 0x5ac, 0x5ad, 
       0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ab, 0x3, 0x2, 0x2, 0x2, 0x5ad, 0x5ae, 
       0x3, 0x2, 0x2, 0x2, 0x5ae, 0xcd, 0x3, 0x2, 0x2, 0x2, 0x5af, 0x5b0, 
       0x7, 0x48, 0x2, 0x2, 0x5b0, 0x5b1, 0x7, 0x9d, 0x2, 0x2, 0x5b1, 0x5b2, 
       0x5, 0xd0, 0x69, 0x2, 0x5b2, 0x5b3, 0x7, 0x9e, 0x2, 0x2, 0x5b3, 0x5b6, 
       0x5, 0x66, 0x34, 0x2, 0x5b4, 0x5b5, 0x7, 0x36, 0x2, 0x2, 0x5b5, 0x5b7, 
       0x5, 0x66, 0x34, 0x2, 0x5b6, 0x5b4, 0x3, 0x2, 0x2, 0x2, 0x5b6, 0x5b7, 
       0x3, 0x2, 0x2, 0x2, 0x5b7, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5b8, 0x5b9, 
       0x7, 0x84, 0x2, 0x2, 0x5b9, 0x5ba, 0x7, 0x9d, 0x2, 0x2, 0x5ba, 0x5bb, 
       0x5, 0xd0, 0x69, 0x2, 0x5bb, 0x5bc, 0x7, 0x9e, 0x2, 0x2, 0x5bc, 0x5bd, 
       0x5, 0x66, 0x34, 0x2, 0x5bd, 0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5be, 0x5af, 
       0x3, 0x2, 0x2, 0x2, 0x5be, 0x5b8, 0x3, 0x2, 0x2, 0x2, 0x5bf, 0xcf, 
       0x3, 0x2, 0x2, 0x2, 0x5c0, 0x5cc, 0x5, 0x62, 0x32, 0x2, 0x5c1, 0x5c3, 
       0x5, 0x148, 0xa5, 0x2, 0x5c2, 0x5c1, 0x3, 0x2, 0x2, 0x2, 0x5c2, 0x5c3, 
       0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c4, 0x3, 0x2, 0x2, 0x2, 0x5c4, 0x5c5, 
       0x5, 0xf0, 0x79, 0x2, 0x5c5, 0x5c9, 0x5, 0x15e, 0xb0, 0x2, 0x5c6, 
       0x5c7, 0x7, 0xae, 0x2, 0x2, 0x5c7, 0x5ca, 0x5, 0x1be, 0xe0, 0x2, 
       0x5c8, 0x5ca, 0x5, 0x1c2, 0xe2, 0x2, 0x5c9, 0x5c6, 0x3, 0x2, 0x2, 
       0x2, 0x5c9, 0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5ca, 0x5cc, 0x3, 0x2, 0x2, 
       0x2, 0x5cb, 0x5c0, 0x3, 0x2, 0x2, 0x2, 0x5cb, 0x5c2, 0x3, 0x2, 0x2, 
       0x2, 0x5cc, 0xd1, 0x3, 0x2, 0x2, 0x2, 0x5cd, 0x5ce, 0x7, 0x99, 0x2, 
       0x2, 0x5ce, 0x5cf, 0x7, 0x9d, 0x2, 0x2, 0x5cf, 0x5d0, 0x5, 0xd0, 
       0x69, 0x2, 0x5d0, 0x5d1, 0x7, 0x9e, 0x2, 0x2, 0x5d1, 0x5d2, 0x5, 
       0x66, 0x34, 0x2, 0x5d2, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5d3, 0x5d4, 
       0x7, 0x33, 0x2, 0x2, 0x5d4, 0x5d5, 0x5, 0x66, 0x34, 0x2, 0x5d5, 0x5d6, 
       0x7, 0x99, 0x2, 0x2, 0x5d6, 0x5d7, 0x7, 0x9d, 0x2, 0x2, 0x5d7, 0x5d8, 
       0x5, 0x62, 0x32, 0x2, 0x5d8, 0x5d9, 0x7, 0x9e, 0x2, 0x2, 0x5d9, 0x5da, 
       0x7, 0xc9, 0x2, 0x2, 0x5da, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5db, 0x5dc, 
       0x9, 0x14, 0x2, 0x2, 0x5dc, 0x5e9, 0x7, 0x9d, 0x2, 0x2, 0x5dd, 0x5df, 
       0x5, 0xd4, 0x6b, 0x2, 0x5de, 0x5e0, 0x5, 0xd0, 0x69, 0x2, 0x5df, 
       0x5de, 0x3, 0x2, 0x2, 0x2, 0x5df, 0x5e0, 0x3, 0x2, 0x2, 0x2, 0x5e0, 
       0x5e1, 0x3, 0x2, 0x2, 0x2, 0x5e1, 0x5e3, 0x7, 0xc9, 0x2, 0x2, 0x5e2, 
       0x5e4, 0x5, 0x62, 0x32, 0x2, 0x5e3, 0x5e2, 0x3, 0x2, 0x2, 0x2, 0x5e3, 
       0x5e4, 0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5e5, 
       0x5e6, 0x5, 0xd6, 0x6c, 0x2, 0x5e6, 0x5e7, 0x7, 0xc7, 0x2, 0x2, 0x5e7, 
       0x5e8, 0x5, 0xd8, 0x6d, 0x2, 0x5e8, 0x5ea, 0x3, 0x2, 0x2, 0x2, 0x5e9, 
       0x5dd, 0x3, 0x2, 0x2, 0x2, 0x5e9, 0x5e5, 0x3, 0x2, 0x2, 0x2, 0x5ea, 
       0x5eb, 0x3, 0x2, 0x2, 0x2, 0x5eb, 0x5ec, 0x7, 0x9e, 0x2, 0x2, 0x5ec, 
       0x5ed, 0x5, 0x66, 0x34, 0x2, 0x5ed, 0x5ef, 0x3, 0x2, 0x2, 0x2, 0x5ee, 
       0x5cd, 0x3, 0x2, 0x2, 0x2, 0x5ee, 0x5d3, 0x3, 0x2, 0x2, 0x2, 0x5ee, 
       0x5db, 0x3, 0x2, 0x2, 0x2, 0x5ef, 0xd3, 0x3, 0x2, 0x2, 0x2, 0x5f0, 
       0x5f3, 0x5, 0xc8, 0x65, 0x2, 0x5f1, 0x5f3, 0x5, 0xe6, 0x74, 0x2, 
       0x5f2, 0x5f0, 0x3, 0x2, 0x2, 0x2, 0x5f2, 0x5f1, 0x3, 0x2, 0x2, 0x2, 
       0x5f3, 0xd5, 0x3, 0x2, 0x2, 0x2, 0x5f4, 0x5f6, 0x5, 0x148, 0xa5, 
       0x2, 0x5f5, 0x5f4, 0x3, 0x2, 0x2, 0x2, 0x5f5, 0x5f6, 0x3, 0x2, 0x2, 
       0x2, 0x5f6, 0x5f7, 0x3, 0x2, 0x2, 0x2, 0x5f7, 0x5f8, 0x5, 0xf0, 0x79, 
       0x2, 0x5f8, 0x5f9, 0x5, 0x15e, 0xb0, 0x2, 0x5f9, 0xd7, 0x3, 0x2, 
       0x2, 0x2, 0x5fa, 0x5fd, 0x5, 0x62, 0x32, 0x2, 0x5fb, 0x5fd, 0x5, 
       0x1c2, 0xe2, 0x2, 0x5fc, 0x5fa, 0x3, 0x2, 0x2, 0x2, 0x5fc, 0x5fb, 
       0x3, 0x2, 0x2, 0x2, 0x5fd, 0xd9, 0x3, 0x2, 0x2, 0x2, 0x5fe, 0x608, 
       0x7, 0x17, 0x2, 0x2, 0x5ff, 0x608, 0x7, 0x2c, 0x2, 0x2, 0x600, 0x603, 
       0x7, 0x77, 0x2, 0x2, 0x601, 0x604, 0x5, 0x62, 0x32, 0x2, 0x602, 0x604, 
       0x5, 0x1c2, 0xe2, 0x2, 0x603, 0x601, 0x3, 0x2, 0x2, 0x2, 0x603, 0x602, 
       0x3, 0x2, 0x2, 0x2, 0x603, 0x604, 0x3, 0x2, 0x2, 0x2, 0x604, 0x608, 
       0x3, 0x2, 0x2, 0x2, 0x605, 0x606, 0x7, 0x44, 0x2, 0x2, 0x606, 0x608, 
       0x5, 0x4, 0x3, 0x2, 0x607, 0x5fe, 0x3, 0x2, 0x2, 0x2, 0x607, 0x5ff, 
       0x3, 0x2, 0x2, 0x2, 0x607, 0x600, 0x3, 0x2, 0x2, 0x2, 0x607, 0x605, 
       0x3, 0x2, 0x2, 0x2, 0x608, 0x609, 0x3, 0x2, 0x2, 0x2, 0x609, 0x60a, 
       0x7, 0xc9, 0x2, 0x2, 0x60a, 0xdb, 0x3, 0x2, 0x2, 0x2, 0x60b, 0x60c, 
       0x5, 0xe2, 0x72, 0x2, 0x60c, 0xdd, 0x3, 0x2, 0x2, 0x2, 0x60d, 0x60f, 
       0x5, 0xe0, 0x71, 0x2, 0x60e, 0x60d, 0x3, 0x2, 0x2, 0x2, 0x60f, 0x610, 
       0x3, 0x2, 0x2, 0x2, 0x610, 0x60e, 0x3, 0x2, 0x2, 0x2, 0x610, 0x611, 
       0x3, 0x2, 0x2, 0x2, 0x611, 0xdf, 0x3, 0x2, 0x2, 0x2, 0x612, 0x621, 
       0x5, 0x22a, 0x116, 0x2, 0x613, 0x621, 0x5, 0x186, 0xc4, 0x2, 0x614, 
       0x621, 0x5, 0x184, 0xc3, 0x2, 0x615, 0x621, 0x5, 0x1b0, 0xd9, 0x2, 
       0x616, 0x621, 0x5, 0x1ae, 0xd8, 0x2, 0x617, 0x621, 0x5, 0x1b4, 0xdb, 
       0x2, 0x618, 0x621, 0x5, 0xe2, 0x72, 0x2, 0x619, 0x621, 0x5, 0x1fe, 
       0x100, 0x2, 0x61a, 0x621, 0x5, 0x212, 0x10a, 0x2, 0x61b, 0x621, 0x5, 
       0x214, 0x10b, 0x2, 0x61c, 0x621, 0x5, 0x146, 0xa4, 0x2, 0x61d, 0x621, 
       0x5, 0x138, 0x9d, 0x2, 0x61e, 0x621, 0x5, 0xea, 0x76, 0x2, 0x61f, 
       0x621, 0x5, 0xec, 0x77, 0x2, 0x620, 0x612, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x613, 0x3, 0x2, 0x2, 0x2, 0x620, 0x614, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x615, 0x3, 0x2, 0x2, 0x2, 0x620, 0x616, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x617, 0x3, 0x2, 0x2, 0x2, 0x620, 0x618, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x619, 0x3, 0x2, 0x2, 0x2, 0x620, 0x61a, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x61b, 0x3, 0x2, 0x2, 0x2, 0x620, 0x61c, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x61d, 0x3, 0x2, 0x2, 0x2, 0x620, 0x61e, 0x3, 0x2, 0x2, 0x2, 0x620, 
       0x61f, 0x3, 0x2, 0x2, 0x2, 0x621, 0xe1, 0x3, 0x2, 0x2, 0x2, 0x622, 
       0x62b, 0x5, 0xe6, 0x74, 0x2, 0x623, 0x62b, 0x5, 0x144, 0xa3, 0x2, 
       0x624, 0x62b, 0x5, 0x13c, 0x9f, 0x2, 0x625, 0x62b, 0x5, 0x140, 0xa1, 
       0x2, 0x626, 0x62b, 0x5, 0x142, 0xa2, 0x2, 0x627, 0x62b, 0x5, 0xe8, 
       0x75, 0x2, 0x628, 0x62b, 0x5, 0xe4, 0x73, 0x2, 0x629, 0x62b, 0x5, 
       0x128, 0x95, 0x2, 0x62a, 0x622, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x623, 
       0x3, 0x2, 0x2, 0x2, 0x62a, 0x624, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x625, 
       0x3, 0x2, 0x2, 0x2, 0x62a, 0x626, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x627, 
       0x3, 0x2, 0x2, 0x2, 0x62a, 0x628, 0x3, 0x2, 0x2, 0x2, 0x62a, 0x629, 
       0x3, 0x2, 0x2, 0x2, 0x62b, 0xe3, 0x3, 0x2, 0x2, 0x2, 0x62c, 0x62d, 
       0x7, 0x93, 0x2, 0x2, 0x62d, 0x62f, 0x5, 0x4, 0x3, 0x2, 0x62e, 0x630, 
       0x5, 0x148, 0xa5, 0x2, 0x62f, 0x62e, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x630, 
       0x3, 0x2, 0x2, 0x2, 0x630, 0x631, 0x3, 0x2, 0x2, 0x2, 0x631, 0x632, 
       0x7, 0xae, 0x2, 0x2, 0x632, 0x633, 0x5, 0x172, 0xba, 0x2, 0x633, 
       0x634, 0x7, 0xc9, 0x2, 0x2, 0x634, 0xe5, 0x3, 0x2, 0x2, 0x2, 0x635, 
       0x637, 0x5, 0xf0, 0x79, 0x2, 0x636, 0x638, 0x5, 0x15a, 0xae, 0x2, 
       0x637, 0x636, 0x3, 0x2, 0x2, 0x2, 0x637, 0x638, 0x3, 0x2, 0x2, 0x2, 
       0x638, 0x63a, 0x3, 0x2, 0x2, 0x2, 0x639, 0x635, 0x3, 0x2, 0x2, 0x2, 
       0x639, 0x63a, 0x3, 0x2, 0x2, 0x2, 0x63a, 0x63b, 0x3, 0x2, 0x2, 0x2, 
       0x63b, 0x642, 0x7, 0xc9, 0x2, 0x2, 0x63c, 0x63d, 0x5, 0x148, 0xa5, 
       0x2, 0x63d, 0x63e, 0x5, 0xf0, 0x79, 0x2, 0x63e, 0x63f, 0x5, 0x15a, 
       0xae, 0x2, 0x63f, 0x640, 0x7, 0xc9, 0x2, 0x2, 0x640, 0x642, 0x3, 
       0x2, 0x2, 0x2, 0x641, 0x639, 0x3, 0x2, 0x2, 0x2, 0x641, 0x63c, 0x3, 
       0x2, 0x2, 0x2, 0x642, 0xe7, 0x3, 0x2, 0x2, 0x2, 0x643, 0x644, 0x7, 
       0x81, 0x2, 0x2, 0x644, 0x645, 0x7, 0x9d, 0x2, 0x2, 0x645, 0x646, 
       0x5, 0x64, 0x33, 0x2, 0x646, 0x647, 0x7, 0xc3, 0x2, 0x2, 0x647, 0x648, 
       0x7, 0x6, 0x2, 0x2, 0x648, 0x649, 0x7, 0x9e, 0x2, 0x2, 0x649, 0x64a, 
       0x7, 0xc9, 0x2, 0x2, 0x64a, 0xe9, 0x3, 0x2, 0x2, 0x2, 0x64b, 0x64c, 
       0x7, 0xc9, 0x2, 0x2, 0x64c, 0xeb, 0x3, 0x2, 0x2, 0x2, 0x64d, 0x64e, 
       0x5, 0x148, 0xa5, 0x2, 0x64e, 0x64f, 0x7, 0xc9, 0x2, 0x2, 0x64f, 
       0xed, 0x3, 0x2, 0x2, 0x2, 0x650, 0x658, 0x7, 0x40, 0x2, 0x2, 0x651, 
       0x658, 0x7, 0x8e, 0x2, 0x2, 0x652, 0x658, 0x7, 0x50, 0x2, 0x2, 0x653, 
       0x658, 0x7, 0x2a, 0x2, 0x2, 0x654, 0x658, 0x5, 0x108, 0x85, 0x2, 
       0x655, 0x658, 0x5, 0x10e, 0x88, 0x2, 0x656, 0x658, 0x5, 0x10a, 0x86, 
       0x2, 0x657, 0x650, 0x3, 0x2, 0x2, 0x2, 0x657, 0x651, 0x3, 0x2, 0x2, 
       0x2, 0x657, 0x652, 0x3, 0x2, 0x2, 0x2, 0x657, 0x653, 0x3, 0x2, 0x2, 
       0x2, 0x657, 0x654, 0x3, 0x2, 0x2, 0x2, 0x657, 0x655, 0x3, 0x2, 0x2, 
       0x2, 0x657, 0x656, 0x3, 0x2, 0x2, 0x2, 0x658, 0xef, 0x3, 0x2, 0x2, 
       0x2, 0x659, 0x65b, 0x5, 0xee, 0x78, 0x2, 0x65a, 0x659, 0x3, 0x2, 
       0x2, 0x2, 0x65b, 0x65c, 0x3, 0x2, 0x2, 0x2, 0x65c, 0x65d, 0x3, 0x2, 
       0x2, 0x2, 0x65c, 0x65a, 0x3, 0x2, 0x2, 0x2, 0x65d, 0x65f, 0x3, 0x2, 
       0x2, 0x2, 0x65e, 0x660, 0x5, 0x148, 0xa5, 0x2, 0x65f, 0x65e, 0x3, 
       0x2, 0x2, 0x2, 0x65f, 0x660, 0x3, 0x2, 0x2, 0x2, 0x660, 0xf1, 0x3, 
       0x2, 0x2, 0x2, 0x661, 0x66c, 0x5, 0xf4, 0x7b, 0x2, 0x662, 0x66c, 
       0x5, 0xf6, 0x7c, 0x2, 0x663, 0x66c, 0x5, 0xf8, 0x7d, 0x2, 0x664, 
       0x66c, 0x5, 0xfa, 0x7e, 0x2, 0x665, 0x66c, 0x5, 0xfc, 0x7f, 0x2, 
       0x666, 0x66c, 0x5, 0xfe, 0x80, 0x2, 0x667, 0x66c, 0x5, 0x100, 0x81, 
       0x2, 0x668, 0x66c, 0x5, 0x102, 0x82, 0x2, 0x669, 0x66c, 0x5, 0x104, 
       0x83, 0x2, 0x66a, 0x66c, 0x5, 0x106, 0x84, 0x2, 0x66b, 0x661, 0x3, 
       0x2, 0x2, 0x2, 0x66b, 0x662, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x663, 0x3, 
       0x2, 0x2, 0x2, 0x66b, 0x664, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x665, 0x3, 
       0x2, 0x2, 0x2, 0x66b, 0x666, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x667, 0x3, 
       0x2, 0x2, 0x2, 0x66b, 0x668, 0x3, 0x2, 0x2, 0x2, 0x66b, 0x669, 0x3, 
       0x2, 0x2, 0x2, 0x66b, 0x66a, 0x3, 0x2, 0x2, 0x2, 0x66c, 0xf3, 0x3, 
       0x2, 0x2, 0x2, 0x66d, 0x66e, 0x7, 0x41, 0x2, 0x2, 0x66e, 0x66f, 0x7, 
       0x9d, 0x2, 0x2, 0x66f, 0x670, 0x9, 0x15, 0x2, 0x2, 0x670, 0x671, 
       0x7, 0xc3, 0x2, 0x2, 0x671, 0x672, 0x5, 0x11a, 0x8e, 0x2, 0x672, 
       0x673, 0x7, 0x9e, 0x2, 0x2, 0x673, 0xf5, 0x3, 0x2, 0x2, 0x2, 0x674, 
       0x675, 0x7, 0x1a, 0x2, 0x2, 0x675, 0x676, 0x8, 0x7c, 0x1, 0x2, 0x676, 
       0x677, 0x7, 0x9d, 0x2, 0x2, 0x677, 0x678, 0x9, 0x15, 0x2, 0x2, 0x678, 
       0x679, 0x7, 0xc3, 0x2, 0x2, 0x679, 0x67a, 0x5, 0x11a, 0x8e, 0x2, 
       0x67a, 0x67b, 0x7, 0x9e, 0x2, 0x2, 0x67b, 0xf7, 0x3, 0x2, 0x2, 0x2, 
       0x67c, 0x67d, 0x7, 0x2e, 0x2, 0x2, 0x67d, 0x67e, 0x8, 0x7d, 0x1, 
       0x2, 0x67e, 0x67f, 0x7, 0x9d, 0x2, 0x2, 0x67f, 0x680, 0x5, 0x11a, 
       0x8e, 0x2, 0x680, 0x681, 0x7, 0x9e, 0x2, 0x2, 0x681, 0xf9, 0x3, 0x2, 
       0x2, 0x2, 0x682, 0x683, 0x7, 0x2d, 0x2, 0x2, 0x683, 0x684, 0x8, 0x7e, 
       0x1, 0x2, 0x684, 0xfb, 0x3, 0x2, 0x2, 0x2, 0x685, 0x686, 0x7, 0x7c, 
       0x2, 0x2, 0x686, 0x687, 0x7, 0x9d, 0x2, 0x2, 0x687, 0x688, 0x5, 0x11a, 
       0x8e, 0x2, 0x688, 0x689, 0x7, 0x9e, 0x2, 0x2, 0x689, 0xfd, 0x3, 0x2, 
       0x2, 0x2, 0x68a, 0x68b, 0x7, 0x7f, 0x2, 0x2, 0x68b, 0x68c, 0x7, 0x9d, 
       0x2, 0x2, 0x68c, 0x68d, 0x5, 0x11a, 0x8e, 0x2, 0x68d, 0x68e, 0x7, 
       0x9e, 0x2, 0x2, 0x68e, 0xff, 0x3, 0x2, 0x2, 0x2, 0x68f, 0x690, 0x7, 
       0x7d, 0x2, 0x2, 0x690, 0x691, 0x7, 0x9d, 0x2, 0x2, 0x691, 0x692, 
       0x5, 0x11a, 0x8e, 0x2, 0x692, 0x693, 0x7, 0x9e, 0x2, 0x2, 0x693, 
       0x101, 0x3, 0x2, 0x2, 0x2, 0x694, 0x695, 0x7, 0x7e, 0x2, 0x2, 0x695, 
       0x696, 0x7, 0x9d, 0x2, 0x2, 0x696, 0x697, 0x5, 0x11a, 0x8e, 0x2, 
       0x697, 0x698, 0x7, 0x9e, 0x2, 0x2, 0x698, 0x103, 0x3, 0x2, 0x2, 0x2, 
       0x699, 0x69a, 0x7, 0x6e, 0x2, 0x2, 0x69a, 0x69b, 0x7, 0x9d, 0x2, 
       0x2, 0x69b, 0x69c, 0x7, 0xcd, 0x2, 0x2, 0x69c, 0x69d, 0x8, 0x83, 
       0x1, 0x2, 0x69d, 0x69e, 0x7, 0x9e, 0x2, 0x2, 0x69e, 0x105, 0x3, 0x2, 
       0x2, 0x2, 0x69f, 0x6a0, 0x7, 0x66, 0x2, 0x2, 0x6a0, 0x6a1, 0x7, 0x9d, 
       0x2, 0x2, 0x6a1, 0x6a2, 0x7, 0xcd, 0x2, 0x2, 0x6a2, 0x6a3, 0x8, 0x84, 
       0x1, 0x2, 0x6a3, 0x6a4, 0x7, 0x9e, 0x2, 0x2, 0x6a4, 0x107, 0x3, 0x2, 
       0x2, 0x2, 0x6a5, 0x6a6, 0x9, 0x16, 0x2, 0x2, 0x6a6, 0x109, 0x3, 0x2, 
       0x2, 0x2, 0x6a7, 0x6a8, 0x9, 0x17, 0x2, 0x2, 0x6a8, 0x10b, 0x3, 0x2, 
       0x2, 0x2, 0x6a9, 0x6aa, 0x5, 0x4, 0x3, 0x2, 0x6aa, 0x10d, 0x3, 0x2, 
       0x2, 0x2, 0x6ab, 0x6b0, 0x5, 0xf2, 0x7a, 0x2, 0x6ac, 0x6b0, 0x5, 
       0x1c6, 0xe4, 0x2, 0x6ad, 0x6b0, 0x5, 0x110, 0x89, 0x2, 0x6ae, 0x6b0, 
       0x5, 0x124, 0x93, 0x2, 0x6af, 0x6ab, 0x3, 0x2, 0x2, 0x2, 0x6af, 0x6ac, 
       0x3, 0x2, 0x2, 0x2, 0x6af, 0x6ad, 0x3, 0x2, 0x2, 0x2, 0x6af, 0x6ae, 
       0x3, 0x2, 0x2, 0x2, 0x6b0, 0x10f, 0x3, 0x2, 0x2, 0x2, 0x6b1, 0x6b6, 
       0x5, 0x120, 0x91, 0x2, 0x6b2, 0x6b6, 0x5, 0x210, 0x109, 0x2, 0x6b3, 
       0x6b6, 0x5, 0x16c, 0xb7, 0x2, 0x6b4, 0x6b6, 0x5, 0x11a, 0x8e, 0x2, 
       0x6b5, 0x6b1, 0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b2, 0x3, 0x2, 0x2, 0x2, 
       0x6b5, 0x6b3, 0x3, 0x2, 0x2, 0x2, 0x6b5, 0x6b4, 0x3, 0x2, 0x2, 0x2, 
       0x6b6, 0x111, 0x3, 0x2, 0x2, 0x2, 0x6b7, 0x6b9, 0x5, 0x10e, 0x88, 
       0x2, 0x6b8, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6ba, 0x3, 0x2, 0x2, 
       0x2, 0x6ba, 0x6b8, 0x3, 0x2, 0x2, 0x2, 0x6ba, 0x6bb, 0x3, 0x2, 0x2, 
       0x2, 0x6bb, 0x6bd, 0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6be, 0x5, 0x148, 
       0xa5, 0x2, 0x6bd, 0x6bc, 0x3, 0x2, 0x2, 0x2, 0x6bd, 0x6be, 0x3, 0x2, 
       0x2, 0x2, 0x6be, 0x113, 0x3, 0x2, 0x2, 0x2, 0x6bf, 0x6c1, 0x5, 0x110, 
       0x89, 0x2, 0x6c0, 0x6bf, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x6c2, 0x3, 0x2, 
       0x2, 0x2, 0x6c2, 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6c2, 0x6c3, 0x3, 0x2, 
       0x2, 0x2, 0x6c3, 0x6c5, 0x3, 0x2, 0x2, 0x2, 0x6c4, 0x6c6, 0x5, 0x148, 
       0xa5, 0x2, 0x6c5, 0x6c4, 0x3, 0x2, 0x2, 0x2, 0x6c5, 0x6c6, 0x3, 0x2, 
       0x2, 0x2, 0x6c6, 0x115, 0x3, 0x2, 0x2, 0x2, 0x6c7, 0x6c8, 0x9, 0x18, 
       0x2, 0x2, 0x6c8, 0x117, 0x3, 0x2, 0x2, 0x2, 0x6c9, 0x6ca, 0x9, 0x19, 
       0x2, 0x2, 0x6ca, 0x119, 0x3, 0x2, 0x2, 0x2, 0x6cb, 0x6cd, 0x5, 0x12, 
       0xa, 0x2, 0x6cc, 0x6cb, 0x3, 0x2, 0x2, 0x2, 0x6cc, 0x6cd, 0x3, 0x2, 
       0x2, 0x2, 0x6cd, 0x6ce, 0x3, 0x2, 0x2, 0x2, 0x6ce, 0x700, 0x5, 0x11c, 
       0x8f, 0x2, 0x6cf, 0x6d0, 0x5, 0x12, 0xa, 0x2, 0x6d0, 0x6d1, 0x7, 
       0x85, 0x2, 0x2, 0x6d1, 0x6d2, 0x5, 0x206, 0x104, 0x2, 0x6d2, 0x700, 
       0x3, 0x2, 0x2, 0x2, 0x6d3, 0x700, 0x5, 0x118, 0x8d, 0x2, 0x6d4, 0x6d6, 
       0x5, 0x118, 0x8d, 0x2, 0x6d5, 0x6d4, 0x3, 0x2, 0x2, 0x2, 0x6d5, 0x6d6, 
       0x3, 0x2, 0x2, 0x2, 0x6d6, 0x6d8, 0x3, 0x2, 0x2, 0x2, 0x6d7, 0x6d9, 
       0x5, 0x116, 0x8c, 0x2, 0x6d8, 0x6d7, 0x3, 0x2, 0x2, 0x2, 0x6d9, 0x6da, 
       0x3, 0x2, 0x2, 0x2, 0x6da, 0x6d8, 0x3, 0x2, 0x2, 0x2, 0x6da, 0x6db, 
       0x3, 0x2, 0x2, 0x2, 0x6db, 0x700, 0x3, 0x2, 0x2, 0x2, 0x6dc, 0x6de, 
       0x5, 0x118, 0x8d, 0x2, 0x6dd, 0x6dc, 0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6de, 
       0x3, 0x2, 0x2, 0x2, 0x6de, 0x6df, 0x3, 0x2, 0x2, 0x2, 0x6df, 0x700, 
       0x7, 0x1c, 0x2, 0x2, 0x6e0, 0x6e2, 0x5, 0x118, 0x8d, 0x2, 0x6e1, 
       0x6e0, 0x3, 0x2, 0x2, 0x2, 0x6e1, 0x6e2, 0x3, 0x2, 0x2, 0x2, 0x6e2, 
       0x6e3, 0x3, 0x2, 0x2, 0x2, 0x6e3, 0x700, 0x7, 0x1d, 0x2, 0x2, 0x6e4, 
       0x6e6, 0x5, 0x118, 0x8d, 0x2, 0x6e5, 0x6e4, 0x3, 0x2, 0x2, 0x2, 0x6e5, 
       0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x6e7, 0x3, 0x2, 0x2, 0x2, 0x6e7, 
       0x700, 0x7, 0x1e, 0x2, 0x2, 0x6e8, 0x6ea, 0x5, 0x118, 0x8d, 0x2, 
       0x6e9, 0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6e9, 0x6ea, 0x3, 0x2, 0x2, 0x2, 
       0x6ea, 0x6eb, 0x3, 0x2, 0x2, 0x2, 0x6eb, 0x700, 0x7, 0x98, 0x2, 0x2, 
       0x6ec, 0x700, 0x7, 0x16, 0x2, 0x2, 0x6ed, 0x6ef, 0x5, 0x118, 0x8d, 
       0x2, 0x6ee, 0x6ed, 0x3, 0x2, 0x2, 0x2, 0x6ee, 0x6ef, 0x3, 0x2, 0x2, 
       0x2, 0x6ef, 0x6f3, 0x3, 0x2, 0x2, 0x2, 0x6f0, 0x6f2, 0x5, 0x116, 
       0x8c, 0x2, 0x6f1, 0x6f0, 0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f5, 0x3, 0x2, 
       0x2, 0x2, 0x6f3, 0x6f1, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f4, 0x3, 0x2, 
       0x2, 0x2, 0x6f4, 0x6f6, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f3, 0x3, 0x2, 
       0x2, 0x2, 0x6f6, 0x700, 0x7, 0x4b, 0x2, 0x2, 0x6f7, 0x700, 0x7, 0x3e, 
       0x2, 0x2, 0x6f8, 0x6fa, 0x5, 0x116, 0x8c, 0x2, 0x6f9, 0x6f8, 0x3, 
       0x2, 0x2, 0x2, 0x6f9, 0x6fa, 0x3, 0x2, 0x2, 0x2, 0x6fa, 0x6fb, 0x3, 
       0x2, 0x2, 0x2, 0x6fb, 0x700, 0x7, 0x34, 0x2, 0x2, 0x6fc, 0x700, 0x7, 
       0x96, 0x2, 0x2, 0x6fd, 0x700, 0x7, 0x14, 0x2, 0x2, 0x6fe, 0x700, 
       0x5, 0x11e, 0x90, 0x2, 0x6ff, 0x6cc, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6cf, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6d3, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6d5, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6dd, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6e1, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6e5, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6e9, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6ee, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6f7, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6f9, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6fd, 
       0x3, 0x2, 0x2, 0x2, 0x6ff, 0x6fe, 0x3, 0x2, 0x2, 0x2, 0x700, 0x11b, 
       0x3, 0x2, 0x2, 0x2, 0x701, 0x705, 0x5, 0x1c4, 0xe3, 0x2, 0x702, 0x705, 
       0x5, 0x122, 0x92, 0x2, 0x703, 0x705, 0x5, 0x10c, 0x87, 0x2, 0x704, 
       0x701, 0x3, 0x2, 0x2, 0x2, 0x704, 0x702, 0x3, 0x2, 0x2, 0x2, 0x704, 
       0x703, 0x3, 0x2, 0x2, 0x2, 0x705, 0x11d, 0x3, 0x2, 0x2, 0x2, 0x706, 
       0x707, 0x7, 0x2f, 0x2, 0x2, 0x707, 0x70a, 0x7, 0x9d, 0x2, 0x2, 0x708, 
       0x70b, 0x5, 0x62, 0x32, 0x2, 0x709, 0x70b, 0x7, 0x14, 0x2, 0x2, 0x70a, 
       0x708, 0x3, 0x2, 0x2, 0x2, 0x70a, 0x709, 0x3, 0x2, 0x2, 0x2, 0x70b, 
       0x70c, 0x3, 0x2, 0x2, 0x2, 0x70c, 0x70d, 0x7, 0x9e, 0x2, 0x2, 0x70d, 
       0x11f, 0x3, 0x2, 0x2, 0x2, 0x70e, 0x71d, 0x5, 0x1ce, 0xe8, 0x2, 0x70f, 
       0x711, 0x5, 0x148, 0xa5, 0x2, 0x710, 0x70f, 0x3, 0x2, 0x2, 0x2, 0x710, 
       0x711, 0x3, 0x2, 0x2, 0x2, 0x711, 0x713, 0x3, 0x2, 0x2, 0x2, 0x712, 
       0x714, 0x5, 0x12, 0xa, 0x2, 0x713, 0x712, 0x3, 0x2, 0x2, 0x2, 0x713, 
       0x714, 0x3, 0x2, 0x2, 0x2, 0x714, 0x715, 0x3, 0x2, 0x2, 0x2, 0x715, 
       0x71e, 0x5, 0x4, 0x3, 0x2, 0x716, 0x71e, 0x5, 0x206, 0x104, 0x2, 
       0x717, 0x719, 0x5, 0x12, 0xa, 0x2, 0x718, 0x71a, 0x7, 0x85, 0x2, 
       0x2, 0x719, 0x718, 0x3, 0x2, 0x2, 0x2, 0x719, 0x71a, 0x3, 0x2, 0x2, 
       0x2, 0x71a, 0x71b, 0x3, 0x2, 0x2, 0x2, 0x71b, 0x71c, 0x5, 0x206, 
       0x104, 0x2, 0x71c, 0x71e, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x710, 0x3, 
       0x2, 0x2, 0x2, 0x71d, 0x716, 0x3, 0x2, 0x2, 0x2, 0x71d, 0x717, 0x3, 
       0x2, 0x2, 0x2, 0x71e, 0x725, 0x3, 0x2, 0x2, 0x2, 0x71f, 0x721, 0x7, 
       0x38, 0x2, 0x2, 0x720, 0x722, 0x5, 0x12, 0xa, 0x2, 0x721, 0x720, 
       0x3, 0x2, 0x2, 0x2, 0x721, 0x722, 0x3, 0x2, 0x2, 0x2, 0x722, 0x723, 
       0x3, 0x2, 0x2, 0x2, 0x723, 0x725, 0x5, 0x4, 0x3, 0x2, 0x724, 0x70e, 
       0x3, 0x2, 0x2, 0x2, 0x724, 0x71f, 0x3, 0x2, 0x2, 0x2, 0x725, 0x121, 
       0x3, 0x2, 0x2, 0x2, 0x726, 0x727, 0x5, 0x4, 0x3, 0x2, 0x727, 0x123, 
       0x3, 0x2, 0x2, 0x2, 0x728, 0x729, 0x5, 0x126, 0x94, 0x2, 0x729, 0x72e, 
       0x7, 0xa1, 0x2, 0x2, 0x72a, 0x72c, 0x5, 0x12e, 0x98, 0x2, 0x72b, 
       0x72d, 0x7, 0xc3, 0x2, 0x2, 0x72c, 0x72b, 0x3, 0x2, 0x2, 0x2, 0x72c, 
       0x72d, 0x3, 0x2, 0x2, 0x2, 0x72d, 0x72f, 0x3, 0x2, 0x2, 0x2, 0x72e, 
       0x72a, 0x3, 0x2, 0x2, 0x2, 0x72e, 0x72f, 0x3, 0x2, 0x2, 0x2, 0x72f, 
       0x730, 0x3, 0x2, 0x2, 0x2, 0x730, 0x731, 0x7, 0xa2, 0x2, 0x2, 0x731, 
       0x125, 0x3, 0x2, 0x2, 0x2, 0x732, 0x734, 0x5, 0x12a, 0x96, 0x2, 0x733, 
       0x735, 0x5, 0x148, 0xa5, 0x2, 0x734, 0x733, 0x3, 0x2, 0x2, 0x2, 0x734, 
       0x735, 0x3, 0x2, 0x2, 0x2, 0x735, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x736, 
       0x738, 0x5, 0x12, 0xa, 0x2, 0x737, 0x736, 0x3, 0x2, 0x2, 0x2, 0x737, 
       0x738, 0x3, 0x2, 0x2, 0x2, 0x738, 0x739, 0x3, 0x2, 0x2, 0x2, 0x739, 
       0x73b, 0x5, 0x4, 0x3, 0x2, 0x73a, 0x737, 0x3, 0x2, 0x2, 0x2, 0x73a, 
       0x73b, 0x3, 0x2, 0x2, 0x2, 0x73b, 0x73d, 0x3, 0x2, 0x2, 0x2, 0x73c, 
       0x73e, 0x5, 0x12c, 0x97, 0x2, 0x73d, 0x73c, 0x3, 0x2, 0x2, 0x2, 0x73d, 
       0x73e, 0x3, 0x2, 0x2, 0x2, 0x73e, 0x127, 0x3, 0x2, 0x2, 0x2, 0x73f, 
       0x741, 0x5, 0x12a, 0x96, 0x2, 0x740, 0x742, 0x5, 0x148, 0xa5, 0x2, 
       0x741, 0x740, 0x3, 0x2, 0x2, 0x2, 0x741, 0x742, 0x3, 0x2, 0x2, 0x2, 
       0x742, 0x743, 0x3, 0x2, 0x2, 0x2, 0x743, 0x745, 0x5, 0x4, 0x3, 0x2, 
       0x744, 0x746, 0x5, 0x12c, 0x97, 0x2, 0x745, 0x744, 0x3, 0x2, 0x2, 
       0x2, 0x745, 0x746, 0x3, 0x2, 0x2, 0x2, 0x746, 0x747, 0x3, 0x2, 0x2, 
       0x2, 0x747, 0x748, 0x7, 0xc9, 0x2, 0x2, 0x748, 0x129, 0x3, 0x2, 0x2, 
       0x2, 0x749, 0x74b, 0x7, 0x38, 0x2, 0x2, 0x74a, 0x74c, 0x9, 0x1a, 
       0x2, 0x2, 0x74b, 0x74a, 0x3, 0x2, 0x2, 0x2, 0x74b, 0x74c, 0x3, 0x2, 
       0x2, 0x2, 0x74c, 0x12b, 0x3, 0x2, 0x2, 0x2, 0x74d, 0x74e, 0x7, 0xc7, 
       0x2, 0x2, 0x74e, 0x74f, 0x5, 0x112, 0x8a, 0x2, 0x74f, 0x12d, 0x3, 
       0x2, 0x2, 0x2, 0x750, 0x755, 0x5, 0x130, 0x99, 0x2, 0x751, 0x752, 
       0x7, 0xc3, 0x2, 0x2, 0x752, 0x754, 0x5, 0x130, 0x99, 0x2, 0x753, 
       0x751, 0x3, 0x2, 0x2, 0x2, 0x754, 0x757, 0x3, 0x2, 0x2, 0x2, 0x755, 
       0x753, 0x3, 0x2, 0x2, 0x2, 0x755, 0x756, 0x3, 0x2, 0x2, 0x2, 0x756, 
       0x12f, 0x3, 0x2, 0x2, 0x2, 0x757, 0x755, 0x3, 0x2, 0x2, 0x2, 0x758, 
       0x75b, 0x5, 0x132, 0x9a, 0x2, 0x759, 0x75a, 0x7, 0xae, 0x2, 0x2, 
       0x75a, 0x75c, 0x5, 0x64, 0x33, 0x2, 0x75b, 0x759, 0x3, 0x2, 0x2, 
       0x2, 0x75b, 0x75c, 0x3, 0x2, 0x2, 0x2, 0x75c, 0x131, 0x3, 0x2, 0x2, 
       0x2, 0x75d, 0x75e, 0x5, 0x4, 0x3, 0x2, 0x75e, 0x133, 0x3, 0x2, 0x2, 
       0x2, 0x75f, 0x762, 0x5, 0x136, 0x9c, 0x2, 0x760, 0x762, 0x5, 0x13a, 
       0x9e, 0x2, 0x761, 0x75f, 0x3, 0x2, 0x2, 0x2, 0x761, 0x760, 0x3, 0x2, 
       0x2, 0x2, 0x762, 0x135, 0x3, 0x2, 0x2, 0x2, 0x763, 0x764, 0x5, 0x4, 
       0x3, 0x2, 0x764, 0x137, 0x3, 0x2, 0x2, 0x2, 0x765, 0x767, 0x7, 0x4a, 
       0x2, 0x2, 0x766, 0x765, 0x3, 0x2, 0x2, 0x2, 0x766, 0x767, 0x3, 0x2, 
       0x2, 0x2, 0x767, 0x768, 0x3, 0x2, 0x2, 0x2, 0x768, 0x76b, 0x7, 0x52, 
       0x2, 0x2, 0x769, 0x76c, 0x5, 0x4, 0x3, 0x2, 0x76a, 0x76c, 0x5, 0x136, 
       0x9c, 0x2, 0x76b, 0x769, 0x3, 0x2, 0x2, 0x2, 0x76b, 0x76a, 0x3, 0x2, 
       0x2, 0x2, 0x76b, 0x76c, 0x3, 0x2, 0x2, 0x2, 0x76c, 0x76d, 0x3, 0x2, 
       0x2, 0x2, 0x76d, 0x76f, 0x7, 0xa1, 0x2, 0x2, 0x76e, 0x770, 0x5, 0xde, 
       0x70, 0x2, 0x76f, 0x76e, 0x3, 0x2, 0x2, 0x2, 0x76f, 0x770, 0x3, 0x2, 
       0x2, 0x2, 0x770, 0x771, 0x3, 0x2, 0x2, 0x2, 0x771, 0x772, 0x7, 0xa2, 
       0x2, 0x2, 0x772, 0x139, 0x3, 0x2, 0x2, 0x2, 0x773, 0x774, 0x5, 0x4, 
       0x3, 0x2, 0x774, 0x13b, 0x3, 0x2, 0x2, 0x2, 0x775, 0x776, 0x7, 0x52, 
       0x2, 0x2, 0x776, 0x777, 0x5, 0x4, 0x3, 0x2, 0x777, 0x778, 0x7, 0xae, 
       0x2, 0x2, 0x778, 0x779, 0x5, 0x13e, 0xa0, 0x2, 0x779, 0x77a, 0x7, 
       0xc9, 0x2, 0x2, 0x77a, 0x13d, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x77d, 0x5, 
       0x12, 0xa, 0x2, 0x77c, 0x77b, 0x3, 0x2, 0x2, 0x2, 0x77c, 0x77d, 0x3, 
       0x2, 0x2, 0x2, 0x77d, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x77e, 0x77f, 0x5, 
       0x134, 0x9b, 0x2, 0x77f, 0x13f, 0x3, 0x2, 0x2, 0x2, 0x780, 0x786, 
       0x7, 0x93, 0x2, 0x2, 0x781, 0x783, 0x7, 0x90, 0x2, 0x2, 0x782, 0x781, 
       0x3, 0x2, 0x2, 0x2, 0x782, 0x783, 0x3, 0x2, 0x2, 0x2, 0x783, 0x784, 
       0x3, 0x2, 0x2, 0x2, 0x784, 0x787, 0x5, 0x12, 0xa, 0x2, 0x785, 0x787, 
       0x7, 0xc8, 0x2, 0x2, 0x786, 0x782, 0x3, 0x2, 0x2, 0x2, 0x786, 0x785, 
       0x3, 0x2, 0x2, 0x2, 0x787, 0x788, 0x3, 0x2, 0x2, 0x2, 0x788, 0x789, 
       0x5, 0xe, 0x8, 0x2, 0x789, 0x78a, 0x7, 0xc9, 0x2, 0x2, 0x78a, 0x141, 
       0x3, 0x2, 0x2, 0x2, 0x78b, 0x78d, 0x5, 0x148, 0xa5, 0x2, 0x78c, 0x78b, 
       0x3, 0x2, 0x2, 0x2, 0x78c, 0x78d, 0x3, 0x2, 0x2, 0x2, 0x78d, 0x78e, 
       0x3, 0x2, 0x2, 0x2, 0x78e, 0x78f, 0x7, 0x93, 0x2, 0x2, 0x78f, 0x791, 
       0x7, 0x52, 0x2, 0x2, 0x790, 0x792, 0x5, 0x12, 0xa, 0x2, 0x791, 0x790, 
       0x3, 0x2, 0x2, 0x2, 0x791, 0x792, 0x3, 0x2, 0x2, 0x2, 0x792, 0x793, 
       0x3, 0x2, 0x2, 0x2, 0x793, 0x794, 0x5, 0x134, 0x9b, 0x2, 0x794, 0x795, 
       0x7, 0xc9, 0x2, 0x2, 0x795, 0x143, 0x3, 0x2, 0x2, 0x2, 0x796, 0x797, 
       0x7, 0x13, 0x2, 0x2, 0x797, 0x798, 0x7, 0x9d, 0x2, 0x2, 0x798, 0x799, 
       0x7, 0x6, 0x2, 0x2, 0x799, 0x79a, 0x7, 0x9e, 0x2, 0x2, 0x79a, 0x79b, 
       0x7, 0xc9, 0x2, 0x2, 0x79b, 0x145, 0x3, 0x2, 0x2, 0x2, 0x79c, 0x79d, 
       0x7, 0x3b, 0x2, 0x2, 0x79d, 0x7a4, 0x7, 0x6, 0x2, 0x2, 0x79e, 0x7a0, 
       0x7, 0xa1, 0x2, 0x2, 0x79f, 0x7a1, 0x5, 0xde, 0x70, 0x2, 0x7a0, 0x79f, 
       0x3, 0x2, 0x2, 0x2, 0x7a0, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a1, 0x7a2, 
       0x3, 0x2, 0x2, 0x2, 0x7a2, 0x7a5, 0x7, 0xa2, 0x2, 0x2, 0x7a3, 0x7a5, 
       0x5, 0xe0, 0x71, 0x2, 0x7a4, 0x79e, 0x3, 0x2, 0x2, 0x2, 0x7a4, 0x7a3, 
       0x3, 0x2, 0x2, 0x2, 0x7a5, 0x147, 0x3, 0x2, 0x2, 0x2, 0x7a6, 0x7a8, 
       0x5, 0x14a, 0xa6, 0x2, 0x7a7, 0x7a6, 0x3, 0x2, 0x2, 0x2, 0x7a8, 0x7a9, 
       0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7a7, 0x3, 0x2, 0x2, 0x2, 0x7a9, 0x7aa, 
       0x3, 0x2, 0x2, 0x2, 0x7aa, 0x149, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 
       0x7, 0x9f, 0x2, 0x2, 0x7ac, 0x7ae, 0x7, 0x9f, 0x2, 0x2, 0x7ad, 0x7af, 
       0x5, 0x14e, 0xa8, 0x2, 0x7ae, 0x7ad, 0x3, 0x2, 0x2, 0x2, 0x7ae, 0x7af, 
       0x3, 0x2, 0x2, 0x2, 0x7af, 0x7b0, 0x3, 0x2, 0x2, 0x2, 0x7b0, 0x7b1, 
       0x7, 0xa0, 0x2, 0x2, 0x7b1, 0x7b4, 0x7, 0xa0, 0x2, 0x2, 0x7b2, 0x7b4, 
       0x5, 0x14c, 0xa7, 0x2, 0x7b3, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7b3, 0x7b2, 
       0x3, 0x2, 0x2, 0x2, 0x7b4, 0x14b, 0x3, 0x2, 0x2, 0x2, 0x7b5, 0x7b6, 
       0x7, 0x11, 0x2, 0x2, 0x7b6, 0x7b9, 0x7, 0x9d, 0x2, 0x2, 0x7b7, 0x7ba, 
       0x5, 0x172, 0xba, 0x2, 0x7b8, 0x7ba, 0x5, 0x64, 0x33, 0x2, 0x7b9, 
       0x7b7, 0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7b8, 0x3, 0x2, 0x2, 0x2, 0x7ba, 
       0x7bc, 0x3, 0x2, 0x2, 0x2, 0x7bb, 0x7bd, 0x7, 0xcc, 0x2, 0x2, 0x7bc, 
       0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bd, 0x3, 0x2, 0x2, 0x2, 0x7bd, 
       0x7be, 0x3, 0x2, 0x2, 0x2, 0x7be, 0x7bf, 0x7, 0x9e, 0x2, 0x2, 0x7bf, 
       0x14d, 0x3, 0x2, 0x2, 0x2, 0x7c0, 0x7c5, 0x5, 0x150, 0xa9, 0x2, 0x7c1, 
       0x7c2, 0x7, 0xc3, 0x2, 0x2, 0x7c2, 0x7c4, 0x5, 0x150, 0xa9, 0x2, 
       0x7c3, 0x7c1, 0x3, 0x2, 0x2, 0x2, 0x7c4, 0x7c7, 0x3, 0x2, 0x2, 0x2, 
       0x7c5, 0x7c3, 0x3, 0x2, 0x2, 0x2, 0x7c5, 0x7c6, 0x3, 0x2, 0x2, 0x2, 
       0x7c6, 0x7c9, 0x3, 0x2, 0x2, 0x2, 0x7c7, 0x7c5, 0x3, 0x2, 0x2, 0x2, 
       0x7c8, 0x7ca, 0x7, 0xcc, 0x2, 0x2, 0x7c9, 0x7c8, 0x3, 0x2, 0x2, 0x2, 
       0x7c9, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7ca, 0x14f, 0x3, 0x2, 0x2, 0x2, 
       0x7cb, 0x7cc, 0x5, 0x152, 0xaa, 0x2, 0x7cc, 0x7cd, 0x7, 0xc8, 0x2, 
       0x2, 0x7cd, 0x7cf, 0x3, 0x2, 0x2, 0x2, 0x7ce, 0x7cb, 0x3, 0x2, 0x2, 
       0x2, 0x7ce, 0x7cf, 0x3, 0x2, 0x2, 0x2, 0x7cf, 0x7d0, 0x3, 0x2, 0x2, 
       0x2, 0x7d0, 0x7d2, 0x5, 0x4, 0x3, 0x2, 0x7d1, 0x7d3, 0x5, 0x154, 
       0xab, 0x2, 0x7d2, 0x7d1, 0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7d3, 0x3, 0x2, 
       0x2, 0x2, 0x7d3, 0x151, 0x3, 0x2, 0x2, 0x2, 0x7d4, 0x7d5, 0x5, 0x4, 
       0x3, 0x2, 0x7d5, 0x153, 0x3, 0x2, 0x2, 0x2, 0x7d6, 0x7d8, 0x7, 0x9d, 
       0x2, 0x2, 0x7d7, 0x7d9, 0x5, 0x156, 0xac, 0x2, 0x7d8, 0x7d7, 0x3, 
       0x2, 0x2, 0x2, 0x7d8, 0x7d9, 0x3, 0x2, 0x2, 0x2, 0x7d9, 0x7da, 0x3, 
       0x2, 0x2, 0x2, 0x7da, 0x7db, 0x7, 0x9e, 0x2, 0x2, 0x7db, 0x155, 0x3, 
       0x2, 0x2, 0x2, 0x7dc, 0x7de, 0x5, 0x158, 0xad, 0x2, 0x7dd, 0x7dc, 
       0x3, 0x2, 0x2, 0x2, 0x7de, 0x7df, 0x3, 0x2, 0x2, 0x2, 0x7df, 0x7dd, 
       0x3, 0x2, 0x2, 0x2, 0x7df, 0x7e0, 0x3, 0x2, 0x2, 0x2, 0x7e0, 0x157, 
       0x3, 0x2, 0x2, 0x2, 0x7e1, 0x7e2, 0x7, 0x9d, 0x2, 0x2, 0x7e2, 0x7e3, 
       0x5, 0x156, 0xac, 0x2, 0x7e3, 0x7e4, 0x7, 0x9e, 0x2, 0x2, 0x7e4, 
       0x7f3, 0x3, 0x2, 0x2, 0x2, 0x7e5, 0x7e6, 0x7, 0x9f, 0x2, 0x2, 0x7e6, 
       0x7e7, 0x5, 0x156, 0xac, 0x2, 0x7e7, 0x7e8, 0x7, 0xa0, 0x2, 0x2, 
       0x7e8, 0x7f3, 0x3, 0x2, 0x2, 0x2, 0x7e9, 0x7ea, 0x7, 0xa1, 0x2, 0x2, 
       0x7ea, 0x7eb, 0x5, 0x156, 0xac, 0x2, 0x7eb, 0x7ec, 0x7, 0xa2, 0x2, 
       0x2, 0x7ec, 0x7f3, 0x3, 0x2, 0x2, 0x2, 0x7ed, 0x7ef, 0xa, 0x1b, 0x2, 
       0x2, 0x7ee, 0x7ed, 0x3, 0x2, 0x2, 0x2, 0x7ef, 0x7f0, 0x3, 0x2, 0x2, 
       0x2, 0x7f0, 0x7ee, 0x3, 0x2, 0x2, 0x2, 0x7f0, 0x7f1, 0x3, 0x2, 0x2, 
       0x2, 0x7f1, 0x7f3, 0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7e1, 0x3, 0x2, 0x2, 
       0x2, 0x7f2, 0x7e5, 0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7e9, 0x3, 0x2, 0x2, 
       0x2, 0x7f2, 0x7ee, 0x3, 0x2, 0x2, 0x2, 0x7f3, 0x159, 0x3, 0x2, 0x2, 
       0x2, 0x7f4, 0x7f9, 0x5, 0x15c, 0xaf, 0x2, 0x7f5, 0x7f6, 0x7, 0xc3, 
       0x2, 0x2, 0x7f6, 0x7f8, 0x5, 0x15c, 0xaf, 0x2, 0x7f7, 0x7f5, 0x3, 
       0x2, 0x2, 0x2, 0x7f8, 0x7fb, 0x3, 0x2, 0x2, 0x2, 0x7f9, 0x7f7, 0x3, 
       0x2, 0x2, 0x2, 0x7f9, 0x7fa, 0x3, 0x2, 0x2, 0x2, 0x7fa, 0x15b, 0x3, 
       0x2, 0x2, 0x2, 0x7fb, 0x7f9, 0x3, 0x2, 0x2, 0x2, 0x7fc, 0x7fe, 0x5, 
       0x15e, 0xb0, 0x2, 0x7fd, 0x7ff, 0x5, 0x1ba, 0xde, 0x2, 0x7fe, 0x7fd, 
       0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7ff, 0x3, 0x2, 0x2, 0x2, 0x7ff, 0x15d, 
       0x3, 0x2, 0x2, 0x2, 0x800, 0x806, 0x5, 0x160, 0xb1, 0x2, 0x801, 0x802, 
       0x5, 0x162, 0xb2, 0x2, 0x802, 0x803, 0x5, 0x164, 0xb3, 0x2, 0x803, 
       0x804, 0x5, 0x166, 0xb4, 0x2, 0x804, 0x806, 0x3, 0x2, 0x2, 0x2, 0x805, 
       0x800, 0x3, 0x2, 0x2, 0x2, 0x805, 0x801, 0x3, 0x2, 0x2, 0x2, 0x806, 
       0x15f, 0x3, 0x2, 0x2, 0x2, 0x807, 0x809, 0x5, 0x168, 0xb5, 0x2, 0x808, 
       0x80a, 0x7, 0x29, 0x2, 0x2, 0x809, 0x808, 0x3, 0x2, 0x2, 0x2, 0x809, 
       0x80a, 0x3, 0x2, 0x2, 0x2, 0x80a, 0x80c, 0x3, 0x2, 0x2, 0x2, 0x80b, 
       0x807, 0x3, 0x2, 0x2, 0x2, 0x80c, 0x80f, 0x3, 0x2, 0x2, 0x2, 0x80d, 
       0x80b, 0x3, 0x2, 0x2, 0x2, 0x80d, 0x80e, 0x3, 0x2, 0x2, 0x2, 0x80e, 
       0x810, 0x3, 0x2, 0x2, 0x2, 0x80f, 0x80d, 0x3, 0x2, 0x2, 0x2, 0x810, 
       0x811, 0x5, 0x162, 0xb2, 0x2, 0x811, 0x161, 0x3, 0x2, 0x2, 0x2, 0x812, 
       0x813, 0x8, 0xb2, 0x1, 0x2, 0x813, 0x815, 0x5, 0x170, 0xb9, 0x2, 
       0x814, 0x816, 0x5, 0x148, 0xa5, 0x2, 0x815, 0x814, 0x3, 0x2, 0x2, 
       0x2, 0x815, 0x816, 0x3, 0x2, 0x2, 0x2, 0x816, 0x81c, 0x3, 0x2, 0x2, 
       0x2, 0x817, 0x818, 0x7, 0x9d, 0x2, 0x2, 0x818, 0x819, 0x5, 0x160, 
       0xb1, 0x2, 0x819, 0x81a, 0x7, 0x9e, 0x2, 0x2, 0x81a, 0x81c, 0x3, 
       0x2, 0x2, 0x2, 0x81b, 0x812, 0x3, 0x2, 0x2, 0x2, 0x81b, 0x817, 0x3, 
       0x2, 0x2, 0x2, 0x81c, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x81d, 0x827, 0xc, 
       0x4, 0x2, 0x2, 0x81e, 0x828, 0x5, 0x164, 0xb3, 0x2, 0x81f, 0x821, 
       0x7, 0x9f, 0x2, 0x2, 0x820, 0x822, 0x5, 0x64, 0x33, 0x2, 0x821, 0x820, 
       0x3, 0x2, 0x2, 0x2, 0x821, 0x822, 0x3, 0x2, 0x2, 0x2, 0x822, 0x823, 
       0x3, 0x2, 0x2, 0x2, 0x823, 0x825, 0x7, 0xa0, 0x2, 0x2, 0x824, 0x826, 
       0x5, 0x148, 0xa5, 0x2, 0x825, 0x824, 0x3, 0x2, 0x2, 0x2, 0x825, 0x826, 
       0x3, 0x2, 0x2, 0x2, 0x826, 0x828, 0x3, 0x2, 0x2, 0x2, 0x827, 0x81e, 
       0x3, 0x2, 0x2, 0x2, 0x827, 0x81f, 0x3, 0x2, 0x2, 0x2, 0x828, 0x82a, 
       0x3, 0x2, 0x2, 0x2, 0x829, 0x81d, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x82d, 
       0x3, 0x2, 0x2, 0x2, 0x82b, 0x829, 0x3, 0x2, 0x2, 0x2, 0x82b, 0x82c, 
       0x3, 0x2, 0x2, 0x2, 0x82c, 0x163, 0x3, 0x2, 0x2, 0x2, 0x82d, 0x82b, 
       0x3, 0x2, 0x2, 0x2, 0x82e, 0x830, 0x7, 0x9d, 0x2, 0x2, 0x82f, 0x831, 
       0x5, 0x17e, 0xc0, 0x2, 0x830, 0x82f, 0x3, 0x2, 0x2, 0x2, 0x830, 0x831, 
       0x3, 0x2, 0x2, 0x2, 0x831, 0x832, 0x3, 0x2, 0x2, 0x2, 0x832, 0x834, 
       0x7, 0x9e, 0x2, 0x2, 0x833, 0x835, 0x5, 0x16a, 0xb6, 0x2, 0x834, 
       0x833, 0x3, 0x2, 0x2, 0x2, 0x834, 0x835, 0x3, 0x2, 0x2, 0x2, 0x835, 
       0x837, 0x3, 0x2, 0x2, 0x2, 0x836, 0x838, 0x5, 0x16e, 0xb8, 0x2, 0x837, 
       0x836, 0x3, 0x2, 0x2, 0x2, 0x837, 0x838, 0x3, 0x2, 0x2, 0x2, 0x838, 
       0x83a, 0x3, 0x2, 0x2, 0x2, 0x839, 0x83b, 0x5, 0x222, 0x112, 0x2, 
       0x83a, 0x839, 0x3, 0x2, 0x2, 0x2, 0x83a, 0x83b, 0x3, 0x2, 0x2, 0x2, 
       0x83b, 0x83d, 0x3, 0x2, 0x2, 0x2, 0x83c, 0x83e, 0x5, 0x148, 0xa5, 
       0x2, 0x83d, 0x83c, 0x3, 0x2, 0x2, 0x2, 0x83d, 0x83e, 0x3, 0x2, 0x2, 
       0x2, 0x83e, 0x165, 0x3, 0x2, 0x2, 0x2, 0x83f, 0x840, 0x7, 0xc5, 0x2, 
       0x2, 0x840, 0x842, 0x5, 0x114, 0x8b, 0x2, 0x841, 0x843, 0x5, 0x174, 
       0xbb, 0x2, 0x842, 0x841, 0x3, 0x2, 0x2, 0x2, 0x842, 0x843, 0x3, 0x2, 
       0x2, 0x2, 0x843, 0x167, 0x3, 0x2, 0x2, 0x2, 0x844, 0x846, 0x9, 0x1c, 
       0x2, 0x2, 0x845, 0x847, 0x5, 0x148, 0xa5, 0x2, 0x846, 0x845, 0x3, 
       0x2, 0x2, 0x2, 0x846, 0x847, 0x3, 0x2, 0x2, 0x2, 0x847, 0x853, 0x3, 
       0x2, 0x2, 0x2, 0x848, 0x84a, 0x5, 0x12, 0xa, 0x2, 0x849, 0x848, 0x3, 
       0x2, 0x2, 0x2, 0x849, 0x84a, 0x3, 0x2, 0x2, 0x2, 0x84a, 0x84b, 0x3, 
       0x2, 0x2, 0x2, 0x84b, 0x84d, 0x7, 0xa6, 0x2, 0x2, 0x84c, 0x84e, 0x5, 
       0x148, 0xa5, 0x2, 0x84d, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x84d, 0x84e, 
       0x3, 0x2, 0x2, 0x2, 0x84e, 0x850, 0x3, 0x2, 0x2, 0x2, 0x84f, 0x851, 
       0x5, 0x16a, 0xb6, 0x2, 0x850, 0x84f, 0x3, 0x2, 0x2, 0x2, 0x850, 0x851, 
       0x3, 0x2, 0x2, 0x2, 0x851, 0x853, 0x3, 0x2, 0x2, 0x2, 0x852, 0x844, 
       0x3, 0x2, 0x2, 0x2, 0x852, 0x849, 0x3, 0x2, 0x2, 0x2, 0x853, 0x169, 
       0x3, 0x2, 0x2, 0x2, 0x854, 0x856, 0x5, 0x16c, 0xb7, 0x2, 0x855, 0x854, 
       0x3, 0x2, 0x2, 0x2, 0x856, 0x857, 0x3, 0x2, 0x2, 0x2, 0x857, 0x855, 
       0x3, 0x2, 0x2, 0x2, 0x857, 0x858, 0x3, 0x2, 0x2, 0x2, 0x858, 0x16b, 
       0x3, 0x2, 0x2, 0x2, 0x859, 0x85a, 0x9, 0x1d, 0x2, 0x2, 0x85a, 0x16d, 
       0x3, 0x2, 0x2, 0x2, 0x85b, 0x85c, 0x9, 0x1c, 0x2, 0x2, 0x85c, 0x16f, 
       0x3, 0x2, 0x2, 0x2, 0x85d, 0x85f, 0x7, 0xcc, 0x2, 0x2, 0x85e, 0x85d, 
       0x3, 0x2, 0x2, 0x2, 0x85e, 0x85f, 0x3, 0x2, 0x2, 0x2, 0x85f, 0x860, 
       0x3, 0x2, 0x2, 0x2, 0x860, 0x861, 0x5, 0x8, 0x5, 0x2, 0x861, 0x862, 
       0x8, 0xb9, 0x1, 0x2, 0x862, 0x171, 0x3, 0x2, 0x2, 0x2, 0x863, 0x865, 
       0x5, 0x112, 0x8a, 0x2, 0x864, 0x866, 0x5, 0x174, 0xbb, 0x2, 0x865, 
       0x864, 0x3, 0x2, 0x2, 0x2, 0x865, 0x866, 0x3, 0x2, 0x2, 0x2, 0x866, 
       0x173, 0x3, 0x2, 0x2, 0x2, 0x867, 0x870, 0x5, 0x176, 0xbc, 0x2, 0x868, 
       0x86a, 0x5, 0x178, 0xbd, 0x2, 0x869, 0x868, 0x3, 0x2, 0x2, 0x2, 0x869, 
       0x86a, 0x3, 0x2, 0x2, 0x2, 0x86a, 0x86b, 0x3, 0x2, 0x2, 0x2, 0x86b, 
       0x86c, 0x5, 0x164, 0xb3, 0x2, 0x86c, 0x86d, 0x5, 0x166, 0xb4, 0x2, 
       0x86d, 0x870, 0x3, 0x2, 0x2, 0x2, 0x86e, 0x870, 0x5, 0x17a, 0xbe, 
       0x2, 0x86f, 0x867, 0x3, 0x2, 0x2, 0x2, 0x86f, 0x869, 0x3, 0x2, 0x2, 
       0x2, 0x86f, 0x86e, 0x3, 0x2, 0x2, 0x2, 0x870, 0x175, 0x3, 0x2, 0x2, 
       0x2, 0x871, 0x87b, 0x5, 0x178, 0xbd, 0x2, 0x872, 0x874, 0x5, 0x168, 
       0xb5, 0x2, 0x873, 0x872, 0x3, 0x2, 0x2, 0x2, 0x874, 0x875, 0x3, 0x2, 
       0x2, 0x2, 0x875, 0x873, 0x3, 0x2, 0x2, 0x2, 0x875, 0x876, 0x3, 0x2, 
       0x2, 0x2, 0x876, 0x878, 0x3, 0x2, 0x2, 0x2, 0x877, 0x879, 0x5, 0x178, 
       0xbd, 0x2, 0x878, 0x877, 0x3, 0x2, 0x2, 0x2, 0x878, 0x879, 0x3, 0x2, 
       0x2, 0x2, 0x879, 0x87b, 0x3, 0x2, 0x2, 0x2, 0x87a, 0x871, 0x3, 0x2, 
       0x2, 0x2, 0x87a, 0x873, 0x3, 0x2, 0x2, 0x2, 0x87b, 0x177, 0x3, 0x2, 
       0x2, 0x2, 0x87c, 0x87d, 0x8, 0xbd, 0x1, 0x2, 0x87d, 0x88f, 0x5, 0x164, 
       0xb3, 0x2, 0x87e, 0x880, 0x7, 0x9f, 0x2, 0x2, 0x87f, 0x881, 0x5, 
       0x64, 0x33, 0x2, 0x880, 0x87f, 0x3, 0x2, 0x2, 0x2, 0x880, 0x881, 
       0x3, 0x2, 0x2, 0x2, 0x881, 0x882, 0x3, 0x2, 0x2, 0x2, 0x882, 0x884, 
       0x7, 0xa0, 0x2, 0x2, 0x883, 0x87e, 0x3, 0x2, 0x2, 0x2, 0x884, 0x885, 
       0x3, 0x2, 0x2, 0x2, 0x885, 0x883, 0x3, 0x2, 0x2, 0x2, 0x885, 0x886, 
       0x3, 0x2, 0x2, 0x2, 0x886, 0x888, 0x3, 0x2, 0x2, 0x2, 0x887, 0x889, 
       0x5, 0x148, 0xa5, 0x2, 0x888, 0x887, 0x3, 0x2, 0x2, 0x2, 0x888, 0x889, 
       0x3, 0x2, 0x2, 0x2, 0x889, 0x88f, 0x3, 0x2, 0x2, 0x2, 0x88a, 0x88b, 
       0x7, 0x9d, 0x2, 0x2, 0x88b, 0x88c, 0x5, 0x176, 0xbc, 0x2, 0x88c, 
       0x88d, 0x7, 0x9e, 0x2, 0x2, 0x88d, 0x88f, 0x3, 0x2, 0x2, 0x2, 0x88e, 
       0x87c, 0x3, 0x2, 0x2, 0x2, 0x88e, 0x883, 0x3, 0x2, 0x2, 0x2, 0x88e, 
       0x88a, 0x3, 0x2, 0x2, 0x2, 0x88f, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x890, 
       0x89f, 0xc, 0x6, 0x2, 0x2, 0x891, 0x8a0, 0x5, 0x164, 0xb3, 0x2, 0x892, 
       0x898, 0x5, 0x178, 0xbd, 0x2, 0x893, 0x895, 0x7, 0x9f, 0x2, 0x2, 
       0x894, 0x896, 0x5, 0x64, 0x33, 0x2, 0x895, 0x894, 0x3, 0x2, 0x2, 
       0x2, 0x895, 0x896, 0x3, 0x2, 0x2, 0x2, 0x896, 0x897, 0x3, 0x2, 0x2, 
       0x2, 0x897, 0x899, 0x7, 0xa0, 0x2, 0x2, 0x898, 0x893, 0x3, 0x2, 0x2, 
       0x2, 0x899, 0x89a, 0x3, 0x2, 0x2, 0x2, 0x89a, 0x898, 0x3, 0x2, 0x2, 
       0x2, 0x89a, 0x89b, 0x3, 0x2, 0x2, 0x2, 0x89b, 0x89d, 0x3, 0x2, 0x2, 
       0x2, 0x89c, 0x89e, 0x5, 0x148, 0xa5, 0x2, 0x89d, 0x89c, 0x3, 0x2, 
       0x2, 0x2, 0x89d, 0x89e, 0x3, 0x2, 0x2, 0x2, 0x89e, 0x8a0, 0x3, 0x2, 
       0x2, 0x2, 0x89f, 0x891, 0x3, 0x2, 0x2, 0x2, 0x89f, 0x892, 0x3, 0x2, 
       0x2, 0x2, 0x8a0, 0x8a2, 0x3, 0x2, 0x2, 0x2, 0x8a1, 0x890, 0x3, 0x2, 
       0x2, 0x2, 0x8a2, 0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a3, 0x8a1, 0x3, 0x2, 
       0x2, 0x2, 0x8a3, 0x8a4, 0x3, 0x2, 0x2, 0x2, 0x8a4, 0x179, 0x3, 0x2, 
       0x2, 0x2, 0x8a5, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a6, 0x8a8, 0x5, 0x168, 
       0xb5, 0x2, 0x8a7, 0x8a6, 0x3, 0x2, 0x2, 0x2, 0x8a8, 0x8ab, 0x3, 0x2, 
       0x2, 0x2, 0x8a9, 0x8a7, 0x3, 0x2, 0x2, 0x2, 0x8a9, 0x8aa, 0x3, 0x2, 
       0x2, 0x2, 0x8aa, 0x8ac, 0x3, 0x2, 0x2, 0x2, 0x8ab, 0x8a9, 0x3, 0x2, 
       0x2, 0x2, 0x8ac, 0x8ad, 0x5, 0x17c, 0xbf, 0x2, 0x8ad, 0x17b, 0x3, 
       0x2, 0x2, 0x2, 0x8ae, 0x8af, 0x8, 0xbf, 0x1, 0x2, 0x8af, 0x8b0, 0x7, 
       0xcc, 0x2, 0x2, 0x8b0, 0x8bf, 0x3, 0x2, 0x2, 0x2, 0x8b1, 0x8bb, 0xc, 
       0x4, 0x2, 0x2, 0x8b2, 0x8bc, 0x5, 0x164, 0xb3, 0x2, 0x8b3, 0x8b5, 
       0x7, 0x9f, 0x2, 0x2, 0x8b4, 0x8b6, 0x5, 0x64, 0x33, 0x2, 0x8b5, 0x8b4, 
       0x3, 0x2, 0x2, 0x2, 0x8b5, 0x8b6, 0x3, 0x2, 0x2, 0x2, 0x8b6, 0x8b7, 
       0x3, 0x2, 0x2, 0x2, 0x8b7, 0x8b9, 0x7, 0xa0, 0x2, 0x2, 0x8b8, 0x8ba, 
       0x5, 0x148, 0xa5, 0x2, 0x8b9, 0x8b8, 0x3, 0x2, 0x2, 0x2, 0x8b9, 0x8ba, 
       0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8bc, 0x3, 0x2, 0x2, 0x2, 0x8bb, 0x8b2, 
       0x3, 0x2, 0x2, 0x2, 0x8bb, 0x8b3, 0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8be, 
       0x3, 0x2, 0x2, 0x2, 0x8bd, 0x8b1, 0x3, 0x2, 0x2, 0x2, 0x8be, 0x8c1, 
       0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8bd, 0x3, 0x2, 0x2, 0x2, 0x8bf, 0x8c0, 
       0x3, 0x2, 0x2, 0x2, 0x8c0, 0x17d, 0x3, 0x2, 0x2, 0x2, 0x8c1, 0x8bf, 
       0x3, 0x2, 0x2, 0x2, 0x8c2, 0x8c7, 0x5, 0x180, 0xc1, 0x2, 0x8c3, 0x8c5, 
       0x7, 0xc3, 0x2, 0x2, 0x8c4, 0x8c3, 0x3, 0x2, 0x2, 0x2, 0x8c4, 0x8c5, 
       0x3, 0x2, 0x2, 0x2, 0x8c5, 0x8c6, 0x3, 0x2, 0x2, 0x2, 0x8c6, 0x8c8, 
       0x7, 0xcc, 0x2, 0x2, 0x8c7, 0x8c4, 0x3, 0x2, 0x2, 0x2, 0x8c7, 0x8c8, 
       0x3, 0x2, 0x2, 0x2, 0x8c8, 0x17f, 0x3, 0x2, 0x2, 0x2, 0x8c9, 0x8ce, 
       0x5, 0x182, 0xc2, 0x2, 0x8ca, 0x8cb, 0x7, 0xc3, 0x2, 0x2, 0x8cb, 
       0x8cd, 0x5, 0x182, 0xc2, 0x2, 0x8cc, 0x8ca, 0x3, 0x2, 0x2, 0x2, 0x8cd, 
       0x8d0, 0x3, 0x2, 0x2, 0x2, 0x8ce, 0x8cc, 0x3, 0x2, 0x2, 0x2, 0x8ce, 
       0x8cf, 0x3, 0x2, 0x2, 0x2, 0x8cf, 0x181, 0x3, 0x2, 0x2, 0x2, 0x8d0, 
       0x8ce, 0x3, 0x2, 0x2, 0x2, 0x8d1, 0x8d3, 0x5, 0x148, 0xa5, 0x2, 0x8d2, 
       0x8d1, 0x3, 0x2, 0x2, 0x2, 0x8d2, 0x8d3, 0x3, 0x2, 0x2, 0x2, 0x8d3, 
       0x8d4, 0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d9, 0x5, 0xf0, 0x79, 0x2, 0x8d5, 
       0x8da, 0x5, 0x15e, 0xb0, 0x2, 0x8d6, 0x8d8, 0x5, 0x174, 0xbb, 0x2, 
       0x8d7, 0x8d6, 0x3, 0x2, 0x2, 0x2, 0x8d7, 0x8d8, 0x3, 0x2, 0x2, 0x2, 
       0x8d8, 0x8da, 0x3, 0x2, 0x2, 0x2, 0x8d9, 0x8d5, 0x3, 0x2, 0x2, 0x2, 
       0x8d9, 0x8d7, 0x3, 0x2, 0x2, 0x2, 0x8da, 0x8dd, 0x3, 0x2, 0x2, 0x2, 
       0x8db, 0x8dc, 0x7, 0xae, 0x2, 0x2, 0x8dc, 0x8de, 0x5, 0x1be, 0xe0, 
       0x2, 0x8dd, 0x8db, 0x3, 0x2, 0x2, 0x2, 0x8dd, 0x8de, 0x3, 0x2, 0x2, 
       0x2, 0x8de, 0x183, 0x3, 0x2, 0x2, 0x2, 0x8df, 0x8e0, 0x5, 0x188, 
       0xc5, 0x2, 0x8e0, 0x8e1, 0x8, 0xc3, 0x1, 0x2, 0x8e1, 0x8e2, 0x5, 
       0xca, 0x66, 0x2, 0x8e2, 0x8e3, 0x8, 0xc3, 0x1, 0x2, 0x8e3, 0x185, 
       0x3, 0x2, 0x2, 0x2, 0x8e4, 0x8e5, 0x5, 0x188, 0xc5, 0x2, 0x8e5, 0x8e6, 
       0x8, 0xc4, 0x1, 0x2, 0x8e6, 0x8e7, 0x7, 0xc9, 0x2, 0x2, 0x8e7, 0x187, 
       0x3, 0x2, 0x2, 0x2, 0x8e8, 0x8ed, 0x7, 0x73, 0x2, 0x2, 0x8e9, 0x8ea, 
       0x7, 0x9f, 0x2, 0x2, 0x8ea, 0x8eb, 0x5, 0x64, 0x33, 0x2, 0x8eb, 0x8ec, 
       0x7, 0xa0, 0x2, 0x2, 0x8ec, 0x8ee, 0x3, 0x2, 0x2, 0x2, 0x8ed, 0x8e9, 
       0x3, 0x2, 0x2, 0x2, 0x8ed, 0x8ee, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8ef, 
       0x3, 0x2, 0x2, 0x2, 0x8ef, 0x8f4, 0x8, 0xc5, 0x1, 0x2, 0x8f0, 0x8f2, 
       0x7, 0x80, 0x2, 0x2, 0x8f1, 0x8f3, 0x9, 0x1e, 0x2, 0x2, 0x8f2, 0x8f1, 
       0x3, 0x2, 0x2, 0x2, 0x8f2, 0x8f3, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8f5, 
       0x3, 0x2, 0x2, 0x2, 0x8f4, 0x8f0, 0x3, 0x2, 0x2, 0x2, 0x8f4, 0x8f5, 
       0x3, 0x2, 0x2, 0x2, 0x8f5, 0x8f6, 0x3, 0x2, 0x2, 0x2, 0x8f6, 0x8fa, 
       0x5, 0x18a, 0xc6, 0x2, 0x8f7, 0x8f9, 0x5, 0x19a, 0xce, 0x2, 0x8f8, 
       0x8f7, 0x3, 0x2, 0x2, 0x2, 0x8f9, 0x8fc, 0x3, 0x2, 0x2, 0x2, 0x8fa, 
       0x8f8, 0x3, 0x2, 0x2, 0x2, 0x8fa, 0x8fb, 0x3, 0x2, 0x2, 0x2, 0x8fb, 
       0x189, 0x3, 0x2, 0x2, 0x2, 0x8fc, 0x8fa, 0x3, 0x2, 0x2, 0x2, 0x8fd, 
       0x8ff, 0x5, 0xf0, 0x79, 0x2, 0x8fe, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x8fe, 
       0x8ff, 0x3, 0x2, 0x2, 0x2, 0x8ff, 0x900, 0x3, 0x2, 0x2, 0x2, 0x900, 
       0x901, 0x5, 0x170, 0xb9, 0x2, 0x901, 0x902, 0x8, 0xc6, 0x1, 0x2, 
       0x902, 0x904, 0x7, 0x9d, 0x2, 0x2, 0x903, 0x905, 0x5, 0x18c, 0xc7, 
       0x2, 0x904, 0x903, 0x3, 0x2, 0x2, 0x2, 0x904, 0x905, 0x3, 0x2, 0x2, 
       0x2, 0x905, 0x906, 0x3, 0x2, 0x2, 0x2, 0x906, 0x907, 0x7, 0x9e, 0x2, 
       0x2, 0x907, 0x908, 0x8, 0xc6, 0x1, 0x2, 0x908, 0x18b, 0x3, 0x2, 0x2, 
       0x2, 0x909, 0x90e, 0x5, 0x18e, 0xc8, 0x2, 0x90a, 0x90b, 0x7, 0xc3, 
       0x2, 0x2, 0x90b, 0x90d, 0x5, 0x18e, 0xc8, 0x2, 0x90c, 0x90a, 0x3, 
       0x2, 0x2, 0x2, 0x90d, 0x910, 0x3, 0x2, 0x2, 0x2, 0x90e, 0x90c, 0x3, 
       0x2, 0x2, 0x2, 0x90e, 0x90f, 0x3, 0x2, 0x2, 0x2, 0x90f, 0x18d, 0x3, 
       0x2, 0x2, 0x2, 0x910, 0x90e, 0x3, 0x2, 0x2, 0x2, 0x911, 0x916, 0x5, 
       0x190, 0xc9, 0x2, 0x912, 0x916, 0x5, 0x192, 0xca, 0x2, 0x913, 0x916, 
       0x5, 0x194, 0xcb, 0x2, 0x914, 0x916, 0x5, 0x196, 0xcc, 0x2, 0x915, 
       0x911, 0x3, 0x2, 0x2, 0x2, 0x915, 0x912, 0x3, 0x2, 0x2, 0x2, 0x915, 
       0x913, 0x3, 0x2, 0x2, 0x2, 0x915, 0x914, 0x3, 0x2, 0x2, 0x2, 0x915, 
       0x916, 0x3, 0x2, 0x2, 0x2, 0x916, 0x918, 0x3, 0x2, 0x2, 0x2, 0x917, 
       0x919, 0x5, 0xf0, 0x79, 0x2, 0x918, 0x917, 0x3, 0x2, 0x2, 0x2, 0x918, 
       0x919, 0x3, 0x2, 0x2, 0x2, 0x919, 0x91a, 0x3, 0x2, 0x2, 0x2, 0x91a, 
       0x91b, 0x5, 0x15e, 0xb0, 0x2, 0x91b, 0x91c, 0x8, 0xc8, 0x1, 0x2, 
       0x91c, 0x18f, 0x3, 0x2, 0x2, 0x2, 0x91d, 0x91e, 0x7, 0x47, 0x2, 0x2, 
       0x91e, 0x91f, 0x7, 0x9d, 0x2, 0x2, 0x91f, 0x920, 0x5, 0x64, 0x33, 
       0x2, 0x920, 0x921, 0x7, 0x9e, 0x2, 0x2, 0x921, 0x191, 0x3, 0x2, 0x2, 
       0x2, 0x922, 0x923, 0x7, 0x72, 0x2, 0x2, 0x923, 0x926, 0x7, 0x9d, 
       0x2, 0x2, 0x924, 0x927, 0x5, 0x198, 0xcd, 0x2, 0x925, 0x927, 0x5, 
       0x4, 0x3, 0x2, 0x926, 0x924, 0x3, 0x2, 0x2, 0x2, 0x926, 0x925, 0x3, 
       0x2, 0x2, 0x2, 0x927, 0x928, 0x3, 0x2, 0x2, 0x2, 0x928, 0x929, 0x7, 
       0x9e, 0x2, 0x2, 0x929, 0x193, 0x3, 0x2, 0x2, 0x2, 0x92a, 0x92b, 0x7, 
       0x45, 0x2, 0x2, 0x92b, 0x92c, 0x8, 0xcb, 0x1, 0x2, 0x92c, 0x92d, 
       0x7, 0x9d, 0x2, 0x2, 0x92d, 0x92e, 0x5, 0x5e, 0x30, 0x2, 0x92e, 0x92f, 
       0x7, 0x9e, 0x2, 0x2, 0x92f, 0x195, 0x3, 0x2, 0x2, 0x2, 0x930, 0x931, 
       0x7, 0x46, 0x2, 0x2, 0x931, 0x932, 0x8, 0xcc, 0x1, 0x2, 0x932, 0x933, 
       0x7, 0x9d, 0x2, 0x2, 0x933, 0x934, 0x5, 0x5e, 0x30, 0x2, 0x934, 0x935, 
       0x7, 0x9e, 0x2, 0x2, 0x935, 0x936, 0x8, 0xcc, 0x1, 0x2, 0x936, 0x197, 
       0x3, 0x2, 0x2, 0x2, 0x937, 0x938, 0x9, 0x1f, 0x2, 0x2, 0x938, 0x199, 
       0x3, 0x2, 0x2, 0x2, 0x939, 0x93e, 0x5, 0x19c, 0xcf, 0x2, 0x93a, 0x93e, 
       0x5, 0x19e, 0xd0, 0x2, 0x93b, 0x93e, 0x5, 0x1a0, 0xd1, 0x2, 0x93c, 
       0x93e, 0x5, 0x1a2, 0xd2, 0x2, 0x93d, 0x939, 0x3, 0x2, 0x2, 0x2, 0x93d, 
       0x93a, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x93b, 0x3, 0x2, 0x2, 0x2, 0x93d, 
       0x93c, 0x3, 0x2, 0x2, 0x2, 0x93e, 0x19b, 0x3, 0x2, 0x2, 0x2, 0x93f, 
       0x940, 0x7, 0x78, 0x2, 0x2, 0x940, 0x941, 0x7, 0x9d, 0x2, 0x2, 0x941, 
       0x942, 0x5, 0x62, 0x32, 0x2, 0x942, 0x943, 0x7, 0x9e, 0x2, 0x2, 0x943, 
       0x19d, 0x3, 0x2, 0x2, 0x2, 0x944, 0x945, 0x7, 0x76, 0x2, 0x2, 0x945, 
       0x946, 0x7, 0x9d, 0x2, 0x2, 0x946, 0x947, 0x5, 0x62, 0x32, 0x2, 0x947, 
       0x948, 0x7, 0x9e, 0x2, 0x2, 0x948, 0x19f, 0x3, 0x2, 0x2, 0x2, 0x949, 
       0x94a, 0x7, 0x32, 
  };
  static const uint16_t serializedATNSegment1[] = {
    0x2, 0x2, 0x94a, 0x94b, 0x7, 0x9d, 0x2, 0x2, 0x94b, 0x94c, 0x5, 0x1a4, 
       0xd3, 0x2, 0x94c, 0x94d, 0x7, 0x9e, 0x2, 0x2, 0x94d, 0x1a1, 0x3, 
       0x2, 0x2, 0x2, 0x94e, 0x94f, 0x7, 0x48, 0x2, 0x2, 0x94f, 0x951, 0x7, 
       0x9d, 0x2, 0x2, 0x950, 0x952, 0x5, 0x1a6, 0xd4, 0x2, 0x951, 0x950, 
       0x3, 0x2, 0x2, 0x2, 0x951, 0x952, 0x3, 0x2, 0x2, 0x2, 0x952, 0x953, 
       0x3, 0x2, 0x2, 0x2, 0x953, 0x954, 0x5, 0x62, 0x32, 0x2, 0x954, 0x955, 
       0x7, 0x9e, 0x2, 0x2, 0x955, 0x1a3, 0x3, 0x2, 0x2, 0x2, 0x956, 0x957, 
       0x5, 0x1a6, 0xd4, 0x2, 0x957, 0x958, 0x5, 0x1aa, 0xd6, 0x2, 0x958, 
       0x962, 0x3, 0x2, 0x2, 0x2, 0x959, 0x95e, 0x5, 0x1aa, 0xd6, 0x2, 0x95a, 
       0x95b, 0x7, 0xc3, 0x2, 0x2, 0x95b, 0x95d, 0x5, 0x1aa, 0xd6, 0x2, 
       0x95c, 0x95a, 0x3, 0x2, 0x2, 0x2, 0x95d, 0x960, 0x3, 0x2, 0x2, 0x2, 
       0x95e, 0x95c, 0x3, 0x2, 0x2, 0x2, 0x95e, 0x95f, 0x3, 0x2, 0x2, 0x2, 
       0x95f, 0x962, 0x3, 0x2, 0x2, 0x2, 0x960, 0x95e, 0x3, 0x2, 0x2, 0x2, 
       0x961, 0x956, 0x3, 0x2, 0x2, 0x2, 0x961, 0x959, 0x3, 0x2, 0x2, 0x2, 
       0x962, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0x963, 0x964, 0x7, 0x9f, 0x2, 0x2, 
       0x964, 0x965, 0x5, 0x1a8, 0xd5, 0x2, 0x965, 0x966, 0x7, 0xa0, 0x2, 
       0x2, 0x966, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0x967, 0x968, 0x7, 0x99, 0x2, 
       0x2, 0x968, 0x969, 0x7, 0x9d, 0x2, 0x2, 0x969, 0x96a, 0x5, 0xd0, 
       0x69, 0x2, 0x96a, 0x96b, 0x7, 0x9e, 0x2, 0x2, 0x96b, 0x97f, 0x3, 
       0x2, 0x2, 0x2, 0x96c, 0x96d, 0x9, 0x14, 0x2, 0x2, 0x96d, 0x97a, 0x7, 
       0x9d, 0x2, 0x2, 0x96e, 0x970, 0x5, 0xd4, 0x6b, 0x2, 0x96f, 0x971, 
       0x5, 0xd0, 0x69, 0x2, 0x970, 0x96f, 0x3, 0x2, 0x2, 0x2, 0x970, 0x971, 
       0x3, 0x2, 0x2, 0x2, 0x971, 0x972, 0x3, 0x2, 0x2, 0x2, 0x972, 0x974, 
       0x7, 0xc9, 0x2, 0x2, 0x973, 0x975, 0x5, 0x62, 0x32, 0x2, 0x974, 0x973, 
       0x3, 0x2, 0x2, 0x2, 0x974, 0x975, 0x3, 0x2, 0x2, 0x2, 0x975, 0x97b, 
       0x3, 0x2, 0x2, 0x2, 0x976, 0x977, 0x5, 0xd6, 0x6c, 0x2, 0x977, 0x978, 
       0x7, 0xc7, 0x2, 0x2, 0x978, 0x979, 0x5, 0xd8, 0x6d, 0x2, 0x979, 0x97b, 
       0x3, 0x2, 0x2, 0x2, 0x97a, 0x96e, 0x3, 0x2, 0x2, 0x2, 0x97a, 0x976, 
       0x3, 0x2, 0x2, 0x2, 0x97b, 0x97c, 0x3, 0x2, 0x2, 0x2, 0x97c, 0x97d, 
       0x7, 0x9e, 0x2, 0x2, 0x97d, 0x97f, 0x3, 0x2, 0x2, 0x2, 0x97e, 0x967, 
       0x3, 0x2, 0x2, 0x2, 0x97e, 0x96c, 0x3, 0x2, 0x2, 0x2, 0x97f, 0x1a9, 
       0x3, 0x2, 0x2, 0x2, 0x980, 0x981, 0x7, 0x47, 0x2, 0x2, 0x981, 0x982, 
       0x9, 0x7, 0x2, 0x2, 0x982, 0x983, 0x5, 0x42, 0x22, 0x2, 0x983, 0x1ab, 
       0x3, 0x2, 0x2, 0x2, 0x984, 0x985, 0x7, 0x88, 0x2, 0x2, 0x985, 0x987, 
       0x7, 0x9d, 0x2, 0x2, 0x986, 0x988, 0x5, 0x18c, 0xc7, 0x2, 0x987, 
       0x986, 0x3, 0x2, 0x2, 0x2, 0x987, 0x988, 0x3, 0x2, 0x2, 0x2, 0x988, 
       0x989, 0x3, 0x2, 0x2, 0x2, 0x989, 0x98a, 0x7, 0x9e, 0x2, 0x2, 0x98a, 
       0x1ad, 0x3, 0x2, 0x2, 0x2, 0x98b, 0x98c, 0x5, 0x1b2, 0xda, 0x2, 0x98c, 
       0x98d, 0x8, 0xd8, 0x1, 0x2, 0x98d, 0x98e, 0x5, 0xca, 0x66, 0x2, 0x98e, 
       0x98f, 0x8, 0xd8, 0x1, 0x2, 0x98f, 0x1af, 0x3, 0x2, 0x2, 0x2, 0x990, 
       0x991, 0x5, 0x1b2, 0xda, 0x2, 0x991, 0x992, 0x8, 0xd9, 0x1, 0x2, 
       0x992, 0x993, 0x7, 0xc9, 0x2, 0x2, 0x993, 0x1b1, 0x3, 0x2, 0x2, 0x2, 
       0x994, 0x999, 0x7, 0x1b, 0x2, 0x2, 0x995, 0x996, 0x7, 0x9f, 0x2, 
       0x2, 0x996, 0x997, 0x5, 0x64, 0x33, 0x2, 0x997, 0x998, 0x7, 0xa0, 
       0x2, 0x2, 0x998, 0x99a, 0x3, 0x2, 0x2, 0x2, 0x999, 0x995, 0x3, 0x2, 
       0x2, 0x2, 0x999, 0x99a, 0x3, 0x2, 0x2, 0x2, 0x99a, 0x99b, 0x3, 0x2, 
       0x2, 0x2, 0x99b, 0x99c, 0x8, 0xda, 0x1, 0x2, 0x99c, 0x99e, 0x5, 0x18a, 
       0xc6, 0x2, 0x99d, 0x99f, 0x5, 0x1ac, 0xd7, 0x2, 0x99e, 0x99d, 0x3, 
       0x2, 0x2, 0x2, 0x99e, 0x99f, 0x3, 0x2, 0x2, 0x2, 0x99f, 0x9a3, 0x3, 
       0x2, 0x2, 0x2, 0x9a0, 0x9a2, 0x5, 0x19a, 0xce, 0x2, 0x9a1, 0x9a0, 
       0x3, 0x2, 0x2, 0x2, 0x9a2, 0x9a5, 0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a1, 
       0x3, 0x2, 0x2, 0x2, 0x9a3, 0x9a4, 0x3, 0x2, 0x2, 0x2, 0x9a4, 0x1b3, 
       0x3, 0x2, 0x2, 0x2, 0x9a5, 0x9a3, 0x3, 0x2, 0x2, 0x2, 0x9a6, 0x9a7, 
       0x5, 0x1b6, 0xdc, 0x2, 0x9a7, 0x9a9, 0x7, 0x9d, 0x2, 0x2, 0x9a8, 
       0x9aa, 0x5, 0x17e, 0xc0, 0x2, 0x9a9, 0x9a8, 0x3, 0x2, 0x2, 0x2, 0x9a9, 
       0x9aa, 0x3, 0x2, 0x2, 0x2, 0x9aa, 0x9ab, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x9ac, 0x7, 0x9e, 0x2, 0x2, 0x9ac, 0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9ad, 
       0x9af, 0x5, 0x148, 0xa5, 0x2, 0x9ae, 0x9ad, 0x3, 0x2, 0x2, 0x2, 0x9ae, 
       0x9af, 0x3, 0x2, 0x2, 0x2, 0x9af, 0x9b1, 0x3, 0x2, 0x2, 0x2, 0x9b0, 
       0x9b2, 0x5, 0xf0, 0x79, 0x2, 0x9b1, 0x9b0, 0x3, 0x2, 0x2, 0x2, 0x9b1, 
       0x9b2, 0x3, 0x2, 0x2, 0x2, 0x9b2, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0x9b3, 
       0x9b5, 0x5, 0x15e, 0xb0, 0x2, 0x9b4, 0x9b6, 0x5, 0x1da, 0xee, 0x2, 
       0x9b5, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b6, 0x3, 0x2, 0x2, 0x2, 
       0x9b6, 0x9b8, 0x3, 0x2, 0x2, 0x2, 0x9b7, 0x9a6, 0x3, 0x2, 0x2, 0x2, 
       0x9b7, 0x9ae, 0x3, 0x2, 0x2, 0x2, 0x9b8, 0x9b9, 0x3, 0x2, 0x2, 0x2, 
       0x9b9, 0x9ba, 0x5, 0x1b8, 0xdd, 0x2, 0x9ba, 0x1b5, 0x3, 0x2, 0x2, 
       0x2, 0x9bb, 0x9bc, 0x5, 0x4, 0x3, 0x2, 0x9bc, 0x9be, 0x7, 0xc8, 0x2, 
       0x2, 0x9bd, 0x9bf, 0x7, 0xac, 0x2, 0x2, 0x9be, 0x9bd, 0x3, 0x2, 0x2, 
       0x2, 0x9be, 0x9bf, 0x3, 0x2, 0x2, 0x2, 0x9bf, 0x9c0, 0x3, 0x2, 0x2, 
       0x2, 0x9c0, 0x9c1, 0x5, 0x4, 0x3, 0x2, 0x9c1, 0x1b7, 0x3, 0x2, 0x2, 
       0x2, 0x9c2, 0x9c4, 0x5, 0x1f2, 0xfa, 0x2, 0x9c3, 0x9c2, 0x3, 0x2, 
       0x2, 0x2, 0x9c3, 0x9c4, 0x3, 0x2, 0x2, 0x2, 0x9c4, 0x9c5, 0x3, 0x2, 
       0x2, 0x2, 0x9c5, 0x9cb, 0x5, 0xca, 0x66, 0x2, 0x9c6, 0x9cb, 0x5, 
       0x218, 0x10d, 0x2, 0x9c7, 0x9c8, 0x7, 0xae, 0x2, 0x2, 0x9c8, 0x9c9, 
       0x9, 0x20, 0x2, 0x2, 0x9c9, 0x9cb, 0x7, 0xc9, 0x2, 0x2, 0x9ca, 0x9c3, 
       0x3, 0x2, 0x2, 0x2, 0x9ca, 0x9c6, 0x3, 0x2, 0x2, 0x2, 0x9ca, 0x9c7, 
       0x3, 0x2, 0x2, 0x2, 0x9cb, 0x1b9, 0x3, 0x2, 0x2, 0x2, 0x9cc, 0x9d2, 
       0x5, 0x1bc, 0xdf, 0x2, 0x9cd, 0x9ce, 0x7, 0x9d, 0x2, 0x2, 0x9ce, 
       0x9cf, 0x5, 0x2a, 0x16, 0x2, 0x9cf, 0x9d0, 0x7, 0x9e, 0x2, 0x2, 0x9d0, 
       0x9d2, 0x3, 0x2, 0x2, 0x2, 0x9d1, 0x9cc, 0x3, 0x2, 0x2, 0x2, 0x9d1, 
       0x9cd, 0x3, 0x2, 0x2, 0x2, 0x9d2, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0x9d3, 
       0x9d4, 0x7, 0xae, 0x2, 0x2, 0x9d4, 0x9d7, 0x5, 0x1be, 0xe0, 0x2, 
       0x9d5, 0x9d7, 0x5, 0x1c2, 0xe2, 0x2, 0x9d6, 0x9d3, 0x3, 0x2, 0x2, 
       0x2, 0x9d6, 0x9d5, 0x3, 0x2, 0x2, 0x2, 0x9d7, 0x1bd, 0x3, 0x2, 0x2, 
       0x2, 0x9d8, 0x9db, 0x5, 0x5e, 0x30, 0x2, 0x9d9, 0x9db, 0x5, 0x1c2, 
       0xe2, 0x2, 0x9da, 0x9d8, 0x3, 0x2, 0x2, 0x2, 0x9da, 0x9d9, 0x3, 0x2, 
       0x2, 0x2, 0x9db, 0x1bf, 0x3, 0x2, 0x2, 0x2, 0x9dc, 0x9de, 0x5, 0x1be, 
       0xe0, 0x2, 0x9dd, 0x9df, 0x7, 0xcc, 0x2, 0x2, 0x9de, 0x9dd, 0x3, 
       0x2, 0x2, 0x2, 0x9de, 0x9df, 0x3, 0x2, 0x2, 0x2, 0x9df, 0x9e7, 0x3, 
       0x2, 0x2, 0x2, 0x9e0, 0x9e1, 0x7, 0xc3, 0x2, 0x2, 0x9e1, 0x9e3, 0x5, 
       0x1be, 0xe0, 0x2, 0x9e2, 0x9e4, 0x7, 0xcc, 0x2, 0x2, 0x9e3, 0x9e2, 
       0x3, 0x2, 0x2, 0x2, 0x9e3, 0x9e4, 0x3, 0x2, 0x2, 0x2, 0x9e4, 0x9e6, 
       0x3, 0x2, 0x2, 0x2, 0x9e5, 0x9e0, 0x3, 0x2, 0x2, 0x2, 0x9e6, 0x9e9, 
       0x3, 0x2, 0x2, 0x2, 0x9e7, 0x9e5, 0x3, 0x2, 0x2, 0x2, 0x9e7, 0x9e8, 
       0x3, 0x2, 0x2, 0x2, 0x9e8, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0x9e9, 0x9e7, 
       0x3, 0x2, 0x2, 0x2, 0x9ea, 0x9ef, 0x7, 0xa1, 0x2, 0x2, 0x9eb, 0x9ed, 
       0x5, 0x1c0, 0xe1, 0x2, 0x9ec, 0x9ee, 0x7, 0xc3, 0x2, 0x2, 0x9ed, 
       0x9ec, 0x3, 0x2, 0x2, 0x2, 0x9ed, 0x9ee, 0x3, 0x2, 0x2, 0x2, 0x9ee, 
       0x9f0, 0x3, 0x2, 0x2, 0x2, 0x9ef, 0x9eb, 0x3, 0x2, 0x2, 0x2, 0x9ef, 
       0x9f0, 0x3, 0x2, 0x2, 0x2, 0x9f0, 0x9f1, 0x3, 0x2, 0x2, 0x2, 0x9f1, 
       0x9f2, 0x7, 0xa2, 0x2, 0x2, 0x9f2, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0x9f3, 
       0x9f6, 0x5, 0x206, 0x104, 0x2, 0x9f4, 0x9f6, 0x5, 0x4, 0x3, 0x2, 
       0x9f5, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0x9f5, 0x9f4, 0x3, 0x2, 0x2, 0x2, 
       0x9f6, 0x1c5, 0x3, 0x2, 0x2, 0x2, 0x9f7, 0x9f8, 0x5, 0x1c8, 0xe5, 
       0x2, 0x9f8, 0x9fa, 0x7, 0xa1, 0x2, 0x2, 0x9f9, 0x9fb, 0x5, 0x1d0, 
       0xe9, 0x2, 0x9fa, 0x9f9, 0x3, 0x2, 0x2, 0x2, 0x9fa, 0x9fb, 0x3, 0x2, 
       0x2, 0x2, 0x9fb, 0x9fc, 0x3, 0x2, 0x2, 0x2, 0x9fc, 0x9fd, 0x7, 0xa2, 
       0x2, 0x2, 0x9fd, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0x9fe, 0xa00, 0x5, 0x1ce, 
       0xe8, 0x2, 0x9ff, 0xa01, 0x5, 0x148, 0xa5, 0x2, 0xa00, 0x9ff, 0x3, 
       0x2, 0x2, 0x2, 0xa00, 0xa01, 0x3, 0x2, 0x2, 0x2, 0xa01, 0xa06, 0x3, 
       0x2, 0x2, 0x2, 0xa02, 0xa04, 0x5, 0x1ca, 0xe6, 0x2, 0xa03, 0xa05, 
       0x5, 0x1cc, 0xe7, 0x2, 0xa04, 0xa03, 0x3, 0x2, 0x2, 0x2, 0xa04, 0xa05, 
       0x3, 0x2, 0x2, 0x2, 0xa05, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xa06, 0xa02, 
       0x3, 0x2, 0x2, 0x2, 0xa06, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xa07, 0xa09, 
       0x3, 0x2, 0x2, 0x2, 0xa08, 0xa0a, 0x5, 0x1e0, 0xf1, 0x2, 0xa09, 0xa08, 
       0x3, 0x2, 0x2, 0x2, 0xa09, 0xa0a, 0x3, 0x2, 0x2, 0x2, 0xa0a, 0xa16, 
       0x3, 0x2, 0x2, 0x2, 0xa0b, 0xa0d, 0x7, 0x91, 0x2, 0x2, 0xa0c, 0xa0e, 
       0x5, 0x148, 0xa5, 0x2, 0xa0d, 0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0d, 0xa0e, 
       0x3, 0x2, 0x2, 0x2, 0xa0e, 0xa13, 0x3, 0x2, 0x2, 0x2, 0xa0f, 0xa11, 
       0x5, 0x1ca, 0xe6, 0x2, 0xa10, 0xa12, 0x5, 0x1cc, 0xe7, 0x2, 0xa11, 
       0xa10, 0x3, 0x2, 0x2, 0x2, 0xa11, 0xa12, 0x3, 0x2, 0x2, 0x2, 0xa12, 
       0xa14, 0x3, 0x2, 0x2, 0x2, 0xa13, 0xa0f, 0x3, 0x2, 0x2, 0x2, 0xa13, 
       0xa14, 0x3, 0x2, 0x2, 0x2, 0xa14, 0xa16, 0x3, 0x2, 0x2, 0x2, 0xa15, 
       0x9fe, 0x3, 0x2, 0x2, 0x2, 0xa15, 0xa0b, 0x3, 0x2, 0x2, 0x2, 0xa16, 
       0x1c9, 0x3, 0x2, 0x2, 0x2, 0xa17, 0xa19, 0x5, 0x12, 0xa, 0x2, 0xa18, 
       0xa17, 0x3, 0x2, 0x2, 0x2, 0xa18, 0xa19, 0x3, 0x2, 0x2, 0x2, 0xa19, 
       0xa1a, 0x3, 0x2, 0x2, 0x2, 0xa1a, 0xa1b, 0x5, 0x1c4, 0xe3, 0x2, 0xa1b, 
       0x1cb, 0x3, 0x2, 0x2, 0x2, 0xa1c, 0xa1d, 0x7, 0x3d, 0x2, 0x2, 0xa1d, 
       0x1cd, 0x3, 0x2, 0x2, 0x2, 0xa1e, 0xa1f, 0x9, 0x1a, 0x2, 0x2, 0xa1f, 
       0x1cf, 0x3, 0x2, 0x2, 0x2, 0xa20, 0xa26, 0x5, 0x1d2, 0xea, 0x2, 0xa21, 
       0xa26, 0x5, 0x1d4, 0xeb, 0x2, 0xa22, 0xa23, 0x5, 0x1ea, 0xf6, 0x2, 
       0xa23, 0xa24, 0x7, 0xc7, 0x2, 0x2, 0xa24, 0xa26, 0x3, 0x2, 0x2, 0x2, 
       0xa25, 0xa20, 0x3, 0x2, 0x2, 0x2, 0xa25, 0xa21, 0x3, 0x2, 0x2, 0x2, 
       0xa25, 0xa22, 0x3, 0x2, 0x2, 0x2, 0xa26, 0xa27, 0x3, 0x2, 0x2, 0x2, 
       0xa27, 0xa25, 0x3, 0x2, 0x2, 0x2, 0xa27, 0xa28, 0x3, 0x2, 0x2, 0x2, 
       0xa28, 0x1d1, 0x3, 0x2, 0x2, 0x2, 0xa29, 0xa32, 0x7, 0x4e, 0x2, 0x2, 
       0xa2a, 0xa2b, 0x7, 0x4f, 0x2, 0x2, 0xa2b, 0xa2c, 0x7, 0x9d, 0x2, 
       0x2, 0xa2c, 0xa2d, 0x5, 0x6, 0x4, 0x2, 0xa2d, 0xa2e, 0x7, 0xc3, 0x2, 
       0x2, 0xa2e, 0xa2f, 0x5, 0x6, 0x4, 0x2, 0xa2f, 0xa30, 0x7, 0x9e, 0x2, 
       0x2, 0xa30, 0xa32, 0x3, 0x2, 0x2, 0x2, 0xa31, 0xa29, 0x3, 0x2, 0x2, 
       0x2, 0xa31, 0xa2a, 0x3, 0x2, 0x2, 0x2, 0xa32, 0xa34, 0x3, 0x2, 0x2, 
       0x2, 0xa33, 0xa35, 0x5, 0xf0, 0x79, 0x2, 0xa34, 0xa33, 0x3, 0x2, 
       0x2, 0x2, 0xa34, 0xa35, 0x3, 0x2, 0x2, 0x2, 0xa35, 0xa36, 0x3, 0x2, 
       0x2, 0x2, 0xa36, 0xa37, 0x5, 0x15e, 0xb0, 0x2, 0xa37, 0xa38, 0x7, 
       0xc9, 0x2, 0x2, 0xa38, 0x1d3, 0x3, 0x2, 0x2, 0x2, 0xa39, 0xa3b, 0x5, 
       0x148, 0xa5, 0x2, 0xa3a, 0xa39, 0x3, 0x2, 0x2, 0x2, 0xa3a, 0xa3b, 
       0x3, 0x2, 0x2, 0x2, 0xa3b, 0xa3d, 0x3, 0x2, 0x2, 0x2, 0xa3c, 0xa3e, 
       0x5, 0xf0, 0x79, 0x2, 0xa3d, 0xa3c, 0x3, 0x2, 0x2, 0x2, 0xa3d, 0xa3e, 
       0x3, 0x2, 0x2, 0x2, 0xa3e, 0xa40, 0x3, 0x2, 0x2, 0x2, 0xa3f, 0xa41, 
       0x5, 0x1d6, 0xec, 0x2, 0xa40, 0xa3f, 0x3, 0x2, 0x2, 0x2, 0xa40, 0xa41, 
       0x3, 0x2, 0x2, 0x2, 0xa41, 0xa42, 0x3, 0x2, 0x2, 0x2, 0xa42, 0xa4a, 
       0x7, 0xc9, 0x2, 0x2, 0xa43, 0xa4a, 0x5, 0x1b4, 0xdb, 0x2, 0xa44, 
       0xa4a, 0x5, 0x140, 0xa1, 0x2, 0xa45, 0xa4a, 0x5, 0xe8, 0x75, 0x2, 
       0xa46, 0xa4a, 0x5, 0x1fe, 0x100, 0x2, 0xa47, 0xa4a, 0x5, 0xe4, 0x73, 
       0x2, 0xa48, 0xa4a, 0x5, 0xea, 0x76, 0x2, 0xa49, 0xa3a, 0x3, 0x2, 
       0x2, 0x2, 0xa49, 0xa43, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa44, 0x3, 0x2, 
       0x2, 0x2, 0xa49, 0xa45, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa46, 0x3, 0x2, 
       0x2, 0x2, 0xa49, 0xa47, 0x3, 0x2, 0x2, 0x2, 0xa49, 0xa48, 0x3, 0x2, 
       0x2, 0x2, 0xa4a, 0x1d5, 0x3, 0x2, 0x2, 0x2, 0xa4b, 0xa50, 0x5, 0x1d8, 
       0xed, 0x2, 0xa4c, 0xa4d, 0x7, 0xc3, 0x2, 0x2, 0xa4d, 0xa4f, 0x5, 
       0x1d8, 0xed, 0x2, 0xa4e, 0xa4c, 0x3, 0x2, 0x2, 0x2, 0xa4f, 0xa52, 
       0x3, 0x2, 0x2, 0x2, 0xa50, 0xa4e, 0x3, 0x2, 0x2, 0x2, 0xa50, 0xa51, 
       0x3, 0x2, 0x2, 0x2, 0xa51, 0x1d7, 0x3, 0x2, 0x2, 0x2, 0xa52, 0xa50, 
       0x3, 0x2, 0x2, 0x2, 0xa53, 0xa5c, 0x5, 0x15e, 0xb0, 0x2, 0xa54, 0xa56, 
       0x5, 0x1da, 0xee, 0x2, 0xa55, 0xa57, 0x5, 0x1de, 0xf0, 0x2, 0xa56, 
       0xa55, 0x3, 0x2, 0x2, 0x2, 0xa56, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa57, 
       0xa5d, 0x3, 0x2, 0x2, 0x2, 0xa58, 0xa5b, 0x5, 0x1de, 0xf0, 0x2, 0xa59, 
       0xa5b, 0x5, 0x1bc, 0xdf, 0x2, 0xa5a, 0xa58, 0x3, 0x2, 0x2, 0x2, 0xa5a, 
       0xa59, 0x3, 0x2, 0x2, 0x2, 0xa5a, 0xa5b, 0x3, 0x2, 0x2, 0x2, 0xa5b, 
       0xa5d, 0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa54, 0x3, 0x2, 0x2, 0x2, 0xa5c, 
       0xa5a, 0x3, 0x2, 0x2, 0x2, 0xa5d, 0xa67, 0x3, 0x2, 0x2, 0x2, 0xa5e, 
       0xa60, 0x5, 0x4, 0x3, 0x2, 0xa5f, 0xa5e, 0x3, 0x2, 0x2, 0x2, 0xa5f, 
       0xa60, 0x3, 0x2, 0x2, 0x2, 0xa60, 0xa62, 0x3, 0x2, 0x2, 0x2, 0xa61, 
       0xa63, 0x5, 0x148, 0xa5, 0x2, 0xa62, 0xa61, 0x3, 0x2, 0x2, 0x2, 0xa62, 
       0xa63, 0x3, 0x2, 0x2, 0x2, 0xa63, 0xa64, 0x3, 0x2, 0x2, 0x2, 0xa64, 
       0xa65, 0x7, 0xc7, 0x2, 0x2, 0xa65, 0xa67, 0x5, 0x64, 0x33, 0x2, 0xa66, 
       0xa53, 0x3, 0x2, 0x2, 0x2, 0xa66, 0xa5f, 0x3, 0x2, 0x2, 0x2, 0xa67, 
       0x1d9, 0x3, 0x2, 0x2, 0x2, 0xa68, 0xa6a, 0x5, 0x1dc, 0xef, 0x2, 0xa69, 
       0xa68, 0x3, 0x2, 0x2, 0x2, 0xa6a, 0xa6b, 0x3, 0x2, 0x2, 0x2, 0xa6b, 
       0xa69, 0x3, 0x2, 0x2, 0x2, 0xa6b, 0xa6c, 0x3, 0x2, 0x2, 0x2, 0xa6c, 
       0x1db, 0x3, 0x2, 0x2, 0x2, 0xa6d, 0xa6e, 0x9, 0x21, 0x2, 0x2, 0xa6e, 
       0x1dd, 0x3, 0x2, 0x2, 0x2, 0xa6f, 0xa70, 0x7, 0xae, 0x2, 0x2, 0xa70, 
       0xa71, 0x7, 0xcf, 0x2, 0x2, 0xa71, 0xa72, 0x8, 0xf0, 0x1, 0x2, 0xa72, 
       0x1df, 0x3, 0x2, 0x2, 0x2, 0xa73, 0xa74, 0x7, 0xc7, 0x2, 0x2, 0xa74, 
       0xa75, 0x5, 0x1e2, 0xf2, 0x2, 0xa75, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0xa76, 
       0xa78, 0x5, 0x1e4, 0xf3, 0x2, 0xa77, 0xa79, 0x7, 0xcc, 0x2, 0x2, 
       0xa78, 0xa77, 0x3, 0x2, 0x2, 0x2, 0xa78, 0xa79, 0x3, 0x2, 0x2, 0x2, 
       0xa79, 0xa81, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa7b, 0x7, 0xc3, 0x2, 0x2, 
       0xa7b, 0xa7d, 0x5, 0x1e4, 0xf3, 0x2, 0xa7c, 0xa7e, 0x7, 0xcc, 0x2, 
       0x2, 0xa7d, 0xa7c, 0x3, 0x2, 0x2, 0x2, 0xa7d, 0xa7e, 0x3, 0x2, 0x2, 
       0x2, 0xa7e, 0xa80, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa7a, 0x3, 0x2, 0x2, 
       0x2, 0xa80, 0xa83, 0x3, 0x2, 0x2, 0x2, 0xa81, 0xa7f, 0x3, 0x2, 0x2, 
       0x2, 0xa81, 0xa82, 0x3, 0x2, 0x2, 0x2, 0xa82, 0x1e3, 0x3, 0x2, 0x2, 
       0x2, 0xa83, 0xa81, 0x3, 0x2, 0x2, 0x2, 0xa84, 0xa86, 0x5, 0x148, 
       0xa5, 0x2, 0xa85, 0xa84, 0x3, 0x2, 0x2, 0x2, 0xa85, 0xa86, 0x3, 0x2, 
       0x2, 0x2, 0xa86, 0xa93, 0x3, 0x2, 0x2, 0x2, 0xa87, 0xa94, 0x5, 0x1e8, 
       0xf5, 0x2, 0xa88, 0xa8a, 0x7, 0x95, 0x2, 0x2, 0xa89, 0xa8b, 0x5, 
       0x1ea, 0xf6, 0x2, 0xa8a, 0xa89, 0x3, 0x2, 0x2, 0x2, 0xa8a, 0xa8b, 
       0x3, 0x2, 0x2, 0x2, 0xa8b, 0xa8c, 0x3, 0x2, 0x2, 0x2, 0xa8c, 0xa94, 
       0x5, 0x1e8, 0xf5, 0x2, 0xa8d, 0xa8f, 0x5, 0x1ea, 0xf6, 0x2, 0xa8e, 
       0xa90, 0x7, 0x95, 0x2, 0x2, 0xa8f, 0xa8e, 0x3, 0x2, 0x2, 0x2, 0xa8f, 
       0xa90, 0x3, 0x2, 0x2, 0x2, 0xa90, 0xa91, 0x3, 0x2, 0x2, 0x2, 0xa91, 
       0xa92, 0x5, 0x1e8, 0xf5, 0x2, 0xa92, 0xa94, 0x3, 0x2, 0x2, 0x2, 0xa93, 
       0xa87, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa88, 0x3, 0x2, 0x2, 0x2, 0xa93, 
       0xa8d, 0x3, 0x2, 0x2, 0x2, 0xa94, 0x1e5, 0x3, 0x2, 0x2, 0x2, 0xa95, 
       0xa97, 0x5, 0x12, 0xa, 0x2, 0xa96, 0xa95, 0x3, 0x2, 0x2, 0x2, 0xa96, 
       0xa97, 0x3, 0x2, 0x2, 0x2, 0xa97, 0xa98, 0x3, 0x2, 0x2, 0x2, 0xa98, 
       0xa9b, 0x5, 0x1c4, 0xe3, 0x2, 0xa99, 0xa9b, 0x5, 0x11e, 0x90, 0x2, 
       0xa9a, 0xa96, 0x3, 0x2, 0x2, 0x2, 0xa9a, 0xa99, 0x3, 0x2, 0x2, 0x2, 
       0xa9b, 0x1e7, 0x3, 0x2, 0x2, 0x2, 0xa9c, 0xa9d, 0x5, 0x1e6, 0xf4, 
       0x2, 0xa9d, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0xa9e, 0xa9f, 0x9, 0x22, 0x2, 
       0x2, 0xa9f, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0xaa0, 0xaa1, 0x7, 0x56, 0x2, 
       0x2, 0xaa1, 0xaa2, 0x5, 0x1ee, 0xf8, 0x2, 0xaa2, 0x1ed, 0x3, 0x2, 
       0x2, 0x2, 0xaa3, 0xaa5, 0x5, 0x112, 0x8a, 0x2, 0xaa4, 0xaa6, 0x5, 
       0x1f0, 0xf9, 0x2, 0xaa5, 0xaa4, 0x3, 0x2, 0x2, 0x2, 0xaa5, 0xaa6, 
       0x3, 0x2, 0x2, 0x2, 0xaa6, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0xaa7, 0xaa9, 
       0x5, 0x168, 0xb5, 0x2, 0xaa8, 0xaaa, 0x5, 0x1f0, 0xf9, 0x2, 0xaa9, 
       0xaa8, 0x3, 0x2, 0x2, 0x2, 0xaa9, 0xaaa, 0x3, 0x2, 0x2, 0x2, 0xaaa, 
       0x1f1, 0x3, 0x2, 0x2, 0x2, 0xaab, 0xaac, 0x7, 0xc7, 0x2, 0x2, 0xaac, 
       0xaad, 0x5, 0x1f4, 0xfb, 0x2, 0xaad, 0x1f3, 0x3, 0x2, 0x2, 0x2, 0xaae, 
       0xab0, 0x5, 0x1f6, 0xfc, 0x2, 0xaaf, 0xab1, 0x7, 0xcc, 0x2, 0x2, 
       0xab0, 0xaaf, 0x3, 0x2, 0x2, 0x2, 0xab0, 0xab1, 0x3, 0x2, 0x2, 0x2, 
       0xab1, 0xab9, 0x3, 0x2, 0x2, 0x2, 0xab2, 0xab3, 0x7, 0xc3, 0x2, 0x2, 
       0xab3, 0xab5, 0x5, 0x1f6, 0xfc, 0x2, 0xab4, 0xab6, 0x7, 0xcc, 0x2, 
       0x2, 0xab5, 0xab4, 0x3, 0x2, 0x2, 0x2, 0xab5, 0xab6, 0x3, 0x2, 0x2, 
       0x2, 0xab6, 0xab8, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xab2, 0x3, 0x2, 0x2, 
       0x2, 0xab8, 0xabb, 0x3, 0x2, 0x2, 0x2, 0xab9, 0xab7, 0x3, 0x2, 0x2, 
       0x2, 0xab9, 0xaba, 0x3, 0x2, 0x2, 0x2, 0xaba, 0x1f5, 0x3, 0x2, 0x2, 
       0x2, 0xabb, 0xab9, 0x3, 0x2, 0x2, 0x2, 0xabc, 0xac3, 0x5, 0x1f8, 
       0xfd, 0x2, 0xabd, 0xabf, 0x7, 0x9d, 0x2, 0x2, 0xabe, 0xac0, 0x5, 
       0x2a, 0x16, 0x2, 0xabf, 0xabe, 0x3, 0x2, 0x2, 0x2, 0xabf, 0xac0, 
       0x3, 0x2, 0x2, 0x2, 0xac0, 0xac1, 0x3, 0x2, 0x2, 0x2, 0xac1, 0xac4, 
       0x7, 0x9e, 0x2, 0x2, 0xac2, 0xac4, 0x5, 0x1c2, 0xe2, 0x2, 0xac3, 
       0xabd, 0x3, 0x2, 0x2, 0x2, 0xac3, 0xac2, 0x3, 0x2, 0x2, 0x2, 0xac4, 
       0x1f7, 0x3, 0x2, 0x2, 0x2, 0xac5, 0xac8, 0x5, 0x1e6, 0xf4, 0x2, 0xac6, 
       0xac8, 0x5, 0x4, 0x3, 0x2, 0xac7, 0xac5, 0x3, 0x2, 0x2, 0x2, 0xac7, 
       0xac6, 0x3, 0x2, 0x2, 0x2, 0xac8, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0xac9, 
       0xaca, 0x7, 0x56, 0x2, 0x2, 0xaca, 0xacb, 0x5, 0x236, 0x11c, 0x2, 
       0xacb, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0xacc, 0xad0, 0x7, 0x56, 0x2, 0x2, 
       0xacd, 0xace, 0x7, 0x6, 0x2, 0x2, 0xace, 0xad1, 0x5, 0x4, 0x3, 0x2, 
       0xacf, 0xad1, 0x7, 0xd5, 0x2, 0x2, 0xad0, 0xacd, 0x3, 0x2, 0x2, 0x2, 
       0xad0, 0xacf, 0x3, 0x2, 0x2, 0x2, 0xad1, 0x1fd, 0x3, 0x2, 0x2, 0x2, 
       0xad2, 0xad3, 0x7, 0x85, 0x2, 0x2, 0xad3, 0xad4, 0x7, 0xaf, 0x2, 
       0x2, 0xad4, 0xad5, 0x5, 0x200, 0x101, 0x2, 0xad5, 0xad6, 0x7, 0xb0, 
       0x2, 0x2, 0xad6, 0xad7, 0x5, 0xe0, 0x71, 0x2, 0xad7, 0x1ff, 0x3, 
       0x2, 0x2, 0x2, 0xad8, 0xadd, 0x5, 0x202, 0x102, 0x2, 0xad9, 0xada, 
       0x7, 0xc3, 0x2, 0x2, 0xada, 0xadc, 0x5, 0x202, 0x102, 0x2, 0xadb, 
       0xad9, 0x3, 0x2, 0x2, 0x2, 0xadc, 0xadf, 0x3, 0x2, 0x2, 0x2, 0xadd, 
       0xadb, 0x3, 0x2, 0x2, 0x2, 0xadd, 0xade, 0x3, 0x2, 0x2, 0x2, 0xade, 
       0x201, 0x3, 0x2, 0x2, 0x2, 0xadf, 0xadd, 0x3, 0x2, 0x2, 0x2, 0xae0, 
       0xae3, 0x5, 0x204, 0x103, 0x2, 0xae1, 0xae3, 0x5, 0x182, 0xc2, 0x2, 
       0xae2, 0xae0, 0x3, 0x2, 0x2, 0x2, 0xae2, 0xae1, 0x3, 0x2, 0x2, 0x2, 
       0xae3, 0x203, 0x3, 0x2, 0x2, 0x2, 0xae4, 0xae5, 0x7, 0x85, 0x2, 0x2, 
       0xae5, 0xae6, 0x7, 0xaf, 0x2, 0x2, 0xae6, 0xae7, 0x5, 0x200, 0x101, 
       0x2, 0xae7, 0xae8, 0x7, 0xb0, 0x2, 0x2, 0xae8, 0xaea, 0x3, 0x2, 0x2, 
       0x2, 0xae9, 0xae4, 0x3, 0x2, 0x2, 0x2, 0xae9, 0xaea, 0x3, 0x2, 0x2, 
       0x2, 0xaea, 0xaeb, 0x3, 0x2, 0x2, 0x2, 0xaeb, 0xaee, 0x7, 0x25, 0x2, 
       0x2, 0xaec, 0xaee, 0x7, 0x90, 0x2, 0x2, 0xaed, 0xae9, 0x3, 0x2, 0x2, 
       0x2, 0xaed, 0xaec, 0x3, 0x2, 0x2, 0x2, 0xaee, 0xafa, 0x3, 0x2, 0x2, 
       0x2, 0xaef, 0xaf1, 0x7, 0xcc, 0x2, 0x2, 0xaf0, 0xaef, 0x3, 0x2, 0x2, 
       0x2, 0xaf0, 0xaf1, 0x3, 0x2, 0x2, 0x2, 0xaf1, 0xaf3, 0x3, 0x2, 0x2, 
       0x2, 0xaf2, 0xaf4, 0x5, 0x4, 0x3, 0x2, 0xaf3, 0xaf2, 0x3, 0x2, 0x2, 
       0x2, 0xaf3, 0xaf4, 0x3, 0x2, 0x2, 0x2, 0xaf4, 0xafb, 0x3, 0x2, 0x2, 
       0x2, 0xaf5, 0xaf7, 0x5, 0x4, 0x3, 0x2, 0xaf6, 0xaf5, 0x3, 0x2, 0x2, 
       0x2, 0xaf6, 0xaf7, 0x3, 0x2, 0x2, 0x2, 0xaf7, 0xaf8, 0x3, 0x2, 0x2, 
       0x2, 0xaf8, 0xaf9, 0x7, 0xae, 0x2, 0x2, 0xaf9, 0xafb, 0x5, 0x172, 
       0xba, 0x2, 0xafa, 0xaf0, 0x3, 0x2, 0x2, 0x2, 0xafa, 0xaf6, 0x3, 0x2, 
       0x2, 0x2, 0xafb, 0x205, 0x3, 0x2, 0x2, 0x2, 0xafc, 0xafd, 0x5, 0x20a, 
       0x106, 0x2, 0xafd, 0xaff, 0x7, 0xaf, 0x2, 0x2, 0xafe, 0xb00, 0x5, 
       0x20c, 0x107, 0x2, 0xaff, 0xafe, 0x3, 0x2, 0x2, 0x2, 0xaff, 0xb00, 
       0x3, 0x2, 0x2, 0x2, 0xb00, 0xb01, 0x3, 0x2, 0x2, 0x2, 0xb01, 0xb02, 
       0x7, 0xb0, 0x2, 0x2, 0xb02, 0xb03, 0x8, 0x104, 0x1, 0x2, 0xb03, 0x207, 
       0x3, 0x2, 0x2, 0x2, 0xb04, 0xb10, 0x5, 0x206, 0x104, 0x2, 0xb05, 
       0xb08, 0x5, 0x1fa, 0xfe, 0x2, 0xb06, 0xb08, 0x5, 0x1fc, 0xff, 0x2, 
       0xb07, 0xb05, 0x3, 0x2, 0x2, 0x2, 0xb07, 0xb06, 0x3, 0x2, 0x2, 0x2, 
       0xb08, 0xb09, 0x3, 0x2, 0x2, 0x2, 0xb09, 0xb0b, 0x7, 0xaf, 0x2, 0x2, 
       0xb0a, 0xb0c, 0x5, 0x20c, 0x107, 0x2, 0xb0b, 0xb0a, 0x3, 0x2, 0x2, 
       0x2, 0xb0b, 0xb0c, 0x3, 0x2, 0x2, 0x2, 0xb0c, 0xb0d, 0x3, 0x2, 0x2, 
       0x2, 0xb0d, 0xb0e, 0x7, 0xb0, 0x2, 0x2, 0xb0e, 0xb10, 0x3, 0x2, 0x2, 
       0x2, 0xb0f, 0xb04, 0x3, 0x2, 0x2, 0x2, 0xb0f, 0xb07, 0x3, 0x2, 0x2, 
       0x2, 0xb10, 0x209, 0x3, 0x2, 0x2, 0x2, 0xb11, 0xb12, 0x5, 0x4, 0x3, 
       0x2, 0xb12, 0x20b, 0x3, 0x2, 0x2, 0x2, 0xb13, 0xb15, 0x5, 0x20e, 
       0x108, 0x2, 0xb14, 0xb16, 0x7, 0xcc, 0x2, 0x2, 0xb15, 0xb14, 0x3, 
       0x2, 0x2, 0x2, 0xb15, 0xb16, 0x3, 0x2, 0x2, 0x2, 0xb16, 0xb1e, 0x3, 
       0x2, 0x2, 0x2, 0xb17, 0xb18, 0x7, 0xc3, 0x2, 0x2, 0xb18, 0xb1a, 0x5, 
       0x20e, 0x108, 0x2, 0xb19, 0xb1b, 0x7, 0xcc, 0x2, 0x2, 0xb1a, 0xb19, 
       0x3, 0x2, 0x2, 0x2, 0xb1a, 0xb1b, 0x3, 0x2, 0x2, 0x2, 0xb1b, 0xb1d, 
       0x3, 0x2, 0x2, 0x2, 0xb1c, 0xb17, 0x3, 0x2, 0x2, 0x2, 0xb1d, 0xb20, 
       0x3, 0x2, 0x2, 0x2, 0xb1e, 0xb1c, 0x3, 0x2, 0x2, 0x2, 0xb1e, 0xb1f, 
       0x3, 0x2, 0x2, 0x2, 0xb1f, 0x20d, 0x3, 0x2, 0x2, 0x2, 0xb20, 0xb1e, 
       0x3, 0x2, 0x2, 0x2, 0xb21, 0xb25, 0x5, 0x172, 0xba, 0x2, 0xb22, 0xb25, 
       0x5, 0x64, 0x33, 0x2, 0xb23, 0xb25, 0x5, 0x8, 0x5, 0x2, 0xb24, 0xb21, 
       0x3, 0x2, 0x2, 0x2, 0xb24, 0xb22, 0x3, 0x2, 0x2, 0x2, 0xb24, 0xb23, 
       0x3, 0x2, 0x2, 0x2, 0xb25, 0x20f, 0x3, 0x2, 0x2, 0x2, 0xb26, 0xb27, 
       0x7, 0x90, 0x2, 0x2, 0xb27, 0xb2d, 0x5, 0x12, 0xa, 0x2, 0xb28, 0xb2e, 
       0x5, 0x4, 0x3, 0x2, 0xb29, 0xb2b, 0x7, 0x85, 0x2, 0x2, 0xb2a, 0xb29, 
       0x3, 0x2, 0x2, 0x2, 0xb2a, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb2c, 
       0x3, 0x2, 0x2, 0x2, 0xb2c, 0xb2e, 0x5, 0x206, 0x104, 0x2, 0xb2d, 
       0xb28, 0x3, 0x2, 0x2, 0x2, 0xb2d, 0xb2a, 0x3, 0x2, 0x2, 0x2, 0xb2e, 
       0x211, 0x3, 0x2, 0x2, 0x2, 0xb2f, 0xb31, 0x7, 0x3b, 0x2, 0x2, 0xb30, 
       0xb2f, 0x3, 0x2, 0x2, 0x2, 0xb30, 0xb31, 0x3, 0x2, 0x2, 0x2, 0xb31, 
       0xb32, 0x3, 0x2, 0x2, 0x2, 0xb32, 0xb33, 0x7, 0x85, 0x2, 0x2, 0xb33, 
       0xb34, 0x5, 0xe0, 0x71, 0x2, 0xb34, 0x213, 0x3, 0x2, 0x2, 0x2, 0xb35, 
       0xb36, 0x7, 0x85, 0x2, 0x2, 0xb36, 0xb37, 0x7, 0xaf, 0x2, 0x2, 0xb37, 
       0xb38, 0x7, 0xb0, 0x2, 0x2, 0xb38, 0xb39, 0x5, 0xe0, 0x71, 0x2, 0xb39, 
       0x215, 0x3, 0x2, 0x2, 0x2, 0xb3a, 0xb3b, 0x7, 0x8d, 0x2, 0x2, 0xb3b, 
       0xb3c, 0x5, 0xca, 0x66, 0x2, 0xb3c, 0xb3d, 0x5, 0x21a, 0x10e, 0x2, 
       0xb3d, 0x217, 0x3, 0x2, 0x2, 0x2, 0xb3e, 0xb40, 0x7, 0x8d, 0x2, 0x2, 
       0xb3f, 0xb41, 0x5, 0x1f2, 0xfa, 0x2, 0xb40, 0xb3f, 0x3, 0x2, 0x2, 
       0x2, 0xb40, 0xb41, 0x3, 0x2, 0x2, 0x2, 0xb41, 0xb42, 0x3, 0x2, 0x2, 
       0x2, 0xb42, 0xb43, 0x5, 0xca, 0x66, 0x2, 0xb43, 0xb44, 0x5, 0x21a, 
       0x10e, 0x2, 0xb44, 0x219, 0x3, 0x2, 0x2, 0x2, 0xb45, 0xb47, 0x5, 
       0x21c, 0x10f, 0x2, 0xb46, 0xb45, 0x3, 0x2, 0x2, 0x2, 0xb47, 0xb48, 
       0x3, 0x2, 0x2, 0x2, 0xb48, 0xb46, 0x3, 0x2, 0x2, 0x2, 0xb48, 0xb49, 
       0x3, 0x2, 0x2, 0x2, 0xb49, 0x21b, 0x3, 0x2, 0x2, 0x2, 0xb4a, 0xb4b, 
       0x7, 0x19, 0x2, 0x2, 0xb4b, 0xb4c, 0x7, 0x9d, 0x2, 0x2, 0xb4c, 0xb4d, 
       0x5, 0x21e, 0x110, 0x2, 0xb4d, 0xb4e, 0x7, 0x9e, 0x2, 0x2, 0xb4e, 
       0xb4f, 0x5, 0xca, 0x66, 0x2, 0xb4f, 0x21d, 0x3, 0x2, 0x2, 0x2, 0xb50, 
       0xb52, 0x5, 0x148, 0xa5, 0x2, 0xb51, 0xb50, 0x3, 0x2, 0x2, 0x2, 0xb51, 
       0xb52, 0x3, 0x2, 0x2, 0x2, 0xb52, 0xb53, 0x3, 0x2, 0x2, 0x2, 0xb53, 
       0xb56, 0x5, 0x112, 0x8a, 0x2, 0xb54, 0xb57, 0x5, 0x15e, 0xb0, 0x2, 
       0xb55, 0xb57, 0x5, 0x174, 0xbb, 0x2, 0xb56, 0xb54, 0x3, 0x2, 0x2, 
       0x2, 0xb56, 0xb55, 0x3, 0x2, 0x2, 0x2, 0xb56, 0xb57, 0x3, 0x2, 0x2, 
       0x2, 0xb57, 0xb5a, 0x3, 0x2, 0x2, 0x2, 0xb58, 0xb5a, 0x7, 0xcc, 0x2, 
       0x2, 0xb59, 0xb51, 0x3, 0x2, 0x2, 0x2, 0xb59, 0xb58, 0x3, 0x2, 0x2, 
       0x2, 0xb5a, 0x21f, 0x3, 0x2, 0x2, 0x2, 0xb5b, 0xb5d, 0x7, 0x88, 0x2, 
       0x2, 0xb5c, 0xb5e, 0x5, 0x5e, 0x30, 0x2, 0xb5d, 0xb5c, 0x3, 0x2, 
       0x2, 0x2, 0xb5d, 0xb5e, 0x3, 0x2, 0x2, 0x2, 0xb5e, 0x221, 0x3, 0x2, 
       0x2, 0x2, 0xb5f, 0xb62, 0x5, 0x224, 0x113, 0x2, 0xb60, 0xb62, 0x5, 
       0x228, 0x115, 0x2, 0xb61, 0xb5f, 0x3, 0x2, 0x2, 0x2, 0xb61, 0xb60, 
       0x3, 0x2, 0x2, 0x2, 0xb62, 0x223, 0x3, 0x2, 0x2, 0x2, 0xb63, 0xb64, 
       0x7, 0x88, 0x2, 0x2, 0xb64, 0xb66, 0x7, 0x9d, 0x2, 0x2, 0xb65, 0xb67, 
       0x5, 0x226, 0x114, 0x2, 0xb66, 0xb65, 0x3, 0x2, 0x2, 0x2, 0xb66, 
       0xb67, 0x3, 0x2, 0x2, 0x2, 0xb67, 0xb68, 0x3, 0x2, 0x2, 0x2, 0xb68, 
       0xb69, 0x7, 0x9e, 0x2, 0x2, 0xb69, 0x225, 0x3, 0x2, 0x2, 0x2, 0xb6a, 
       0xb6c, 0x5, 0x172, 0xba, 0x2, 0xb6b, 0xb6d, 0x7, 0xcc, 0x2, 0x2, 
       0xb6c, 0xb6b, 0x3, 0x2, 0x2, 0x2, 0xb6c, 0xb6d, 0x3, 0x2, 0x2, 0x2, 
       0xb6d, 0xb75, 0x3, 0x2, 0x2, 0x2, 0xb6e, 0xb6f, 0x7, 0xc3, 0x2, 0x2, 
       0xb6f, 0xb71, 0x5, 0x172, 0xba, 0x2, 0xb70, 0xb72, 0x7, 0xcc, 0x2, 
       0x2, 0xb71, 0xb70, 0x3, 0x2, 0x2, 0x2, 0xb71, 0xb72, 0x3, 0x2, 0x2, 
       0x2, 0xb72, 0xb74, 0x3, 0x2, 0x2, 0x2, 0xb73, 0xb6e, 0x3, 0x2, 0x2, 
       0x2, 0xb74, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb73, 0x3, 0x2, 0x2, 
       0x2, 0xb75, 0xb76, 0x3, 0x2, 0x2, 0x2, 0xb76, 0x227, 0x3, 0x2, 0x2, 
       0x2, 0xb77, 0xb75, 0x3, 0x2, 0x2, 0x2, 0xb78, 0xb79, 0x7, 0x54, 0x2, 
       0x2, 0xb79, 0xb7a, 0x7, 0x9d, 0x2, 0x2, 0xb7a, 0xb7b, 0x5, 0x64, 
       0x33, 0x2, 0xb7b, 0xb7c, 0x7, 0x9e, 0x2, 0x2, 0xb7c, 0xb7f, 0x3, 
       0x2, 0x2, 0x2, 0xb7d, 0xb7f, 0x7, 0x54, 0x2, 0x2, 0xb7e, 0xb78, 0x3, 
       0x2, 0x2, 0x2, 0xb7e, 0xb7d, 0x3, 0x2, 0x2, 0x2, 0xb7f, 0x229, 0x3, 
       0x2, 0x2, 0x2, 0xb80, 0xb81, 0x7, 0xa, 0x2, 0x2, 0xb81, 0xb82, 0x5, 
       0x22c, 0x117, 0x2, 0xb82, 0x22b, 0x3, 0x2, 0x2, 0x2, 0xb83, 0xb88, 
       0x5, 0x22e, 0x118, 0x2, 0xb84, 0xb88, 0x5, 0x230, 0x119, 0x2, 0xb85, 
       0xb88, 0x5, 0x232, 0x11a, 0x2, 0xb86, 0xb88, 0x5, 0x234, 0x11b, 0x2, 
       0xb87, 0xb83, 0x3, 0x2, 0x2, 0x2, 0xb87, 0xb84, 0x3, 0x2, 0x2, 0x2, 
       0xb87, 0xb85, 0x3, 0x2, 0x2, 0x2, 0xb87, 0xb86, 0x3, 0x2, 0x2, 0x2, 
       0xb88, 0x22d, 0x3, 0x2, 0x2, 0x2, 0xb89, 0xb8a, 0x7, 0x94, 0x2, 0x2, 
       0xb8a, 0xb8b, 0x8, 0x118, 0x1, 0x2, 0xb8b, 0x22f, 0x3, 0x2, 0x2, 
       0x2, 0xb8c, 0xb8d, 0x7, 0x27, 0x2, 0x2, 0xb8d, 0xb8e, 0x8, 0x119, 
       0x1, 0x2, 0xb8e, 0x231, 0x3, 0x2, 0x2, 0x2, 0xb8f, 0xb90, 0x7, 0x28, 
       0x2, 0x2, 0xb90, 0xb95, 0x8, 0x11a, 0x1, 0x2, 0xb91, 0xb92, 0x7, 
       0x15, 0x2, 0x2, 0xb92, 0xb96, 0x8, 0x11a, 0x1, 0x2, 0xb93, 0xb94, 
       0x7, 0x37, 0x2, 0x2, 0xb94, 0xb96, 0x8, 0x11a, 0x1, 0x2, 0xb95, 0xb91, 
       0x3, 0x2, 0x2, 0x2, 0xb95, 0xb93, 0x3, 0x2, 0x2, 0x2, 0xb96, 0x233, 
       0x3, 0x2, 0x2, 0x2, 0xb97, 0xb98, 0x7, 0x43, 0x2, 0x2, 0xb98, 0xb9d, 
       0x8, 0x11b, 0x1, 0x2, 0xb99, 0xb9a, 0x7, 0x15, 0x2, 0x2, 0xb9a, 0xb9e, 
       0x8, 0x11b, 0x1, 0x2, 0xb9b, 0xb9c, 0x7, 0x37, 0x2, 0x2, 0xb9c, 0xb9e, 
       0x8, 0x11b, 0x1, 0x2, 0xb9d, 0xb99, 0x3, 0x2, 0x2, 0x2, 0xb9d, 0xb9b, 
       0x3, 0x2, 0x2, 0x2, 0xb9e, 0x235, 0x3, 0x2, 0x2, 0x2, 0xb9f, 0xba2, 
       0x7, 0x53, 0x2, 0x2, 0xba0, 0xba1, 0x7, 0x9f, 0x2, 0x2, 0xba1, 0xba3, 
       0x7, 0xa0, 0x2, 0x2, 0xba2, 0xba0, 0x3, 0x2, 0x2, 0x2, 0xba2, 0xba3, 
       0x3, 0x2, 0x2, 0x2, 0xba3, 0xbd3, 0x3, 0x2, 0x2, 0x2, 0xba4, 0xba7, 
       0x7, 0x31, 0x2, 0x2, 0xba5, 0xba6, 0x7, 0x9f, 0x2, 0x2, 0xba6, 0xba8, 
       0x7, 0xa0, 0x2, 0x2, 0xba7, 0xba5, 0x3, 0x2, 0x2, 0x2, 0xba7, 0xba8, 
       0x3, 0x2, 0x2, 0x2, 0xba8, 0xbd3, 0x3, 0x2, 0x2, 0x2, 0xba9, 0xbd3, 
       0x7, 0xa4, 0x2, 0x2, 0xbaa, 0xbd3, 0x7, 0xa5, 0x2, 0x2, 0xbab, 0xbd3, 
       0x7, 0xa6, 0x2, 0x2, 0xbac, 0xbd3, 0x7, 0xa7, 0x2, 0x2, 0xbad, 0xbd3, 
       0x7, 0xa8, 0x2, 0x2, 0xbae, 0xbd3, 0x7, 0xa9, 0x2, 0x2, 0xbaf, 0xbd3, 
       0x7, 0xaa, 0x2, 0x2, 0xbb0, 0xbd3, 0x7, 0xab, 0x2, 0x2, 0xbb1, 0xbd3, 
       0x7, 0xac, 0x2, 0x2, 0xbb2, 0xbd3, 0x7, 0xad, 0x2, 0x2, 0xbb3, 0xbd3, 
       0x7, 0xae, 0x2, 0x2, 0xbb4, 0xbd3, 0x7, 0xb0, 0x2, 0x2, 0xbb5, 0xbd3, 
       0x7, 0xaf, 0x2, 0x2, 0xbb6, 0xbd3, 0x7, 0xbe, 0x2, 0x2, 0xbb7, 0xbd3, 
       0x7, 0xb1, 0x2, 0x2, 0xbb8, 0xbd3, 0x7, 0xb2, 0x2, 0x2, 0xbb9, 0xbd3, 
       0x7, 0xb3, 0x2, 0x2, 0xbba, 0xbd3, 0x7, 0xb5, 0x2, 0x2, 0xbbb, 0xbd3, 
       0x7, 0xb6, 0x2, 0x2, 0xbbc, 0xbd3, 0x7, 0xb7, 0x2, 0x2, 0xbbd, 0xbd3, 
       0x7, 0xb8, 0x2, 0x2, 0xbbe, 0xbbf, 0x7, 0xaf, 0x2, 0x2, 0xbbf, 0xbd3, 
       0x7, 0xaf, 0x2, 0x2, 0xbc0, 0xbc1, 0x7, 0xb0, 0x2, 0x2, 0xbc1, 0xbd3, 
       0x7, 0xb0, 0x2, 0x2, 0xbc2, 0xbd3, 0x7, 0xba, 0x2, 0x2, 0xbc3, 0xbd3, 
       0x7, 0xb9, 0x2, 0x2, 0xbc4, 0xbd3, 0x7, 0xbb, 0x2, 0x2, 0xbc5, 0xbd3, 
       0x7, 0xbc, 0x2, 0x2, 0xbc6, 0xbd3, 0x7, 0xbd, 0x2, 0x2, 0xbc7, 0xbd3, 
       0x7, 0xbf, 0x2, 0x2, 0xbc8, 0xbd3, 0x7, 0xc0, 0x2, 0x2, 0xbc9, 0xbd3, 
       0x7, 0xc1, 0x2, 0x2, 0xbca, 0xbd3, 0x7, 0xc2, 0x2, 0x2, 0xbcb, 0xbd3, 
       0x7, 0xc3, 0x2, 0x2, 0xbcc, 0xbd3, 0x7, 0xc4, 0x2, 0x2, 0xbcd, 0xbd3, 
       0x7, 0xc5, 0x2, 0x2, 0xbce, 0xbcf, 0x7, 0x9d, 0x2, 0x2, 0xbcf, 0xbd3, 
       0x7, 0x9e, 0x2, 0x2, 0xbd0, 0xbd1, 0x7, 0x9f, 0x2, 0x2, 0xbd1, 0xbd3, 
       0x7, 0xa0, 0x2, 0x2, 0xbd2, 0xb9f, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xba4, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xba9, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbaa, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbab, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbac, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbad, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbae, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbaf, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb0, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb1, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb2, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb3, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb4, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb5, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb6, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb7, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb8, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbb9, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbba, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbbb, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbbc, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbbd, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbbe, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc0, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc2, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc3, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc4, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc6, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc7, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc8, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbc9, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbca, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbcb, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbcc, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbcd, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbce, 
       0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbd0, 0x3, 0x2, 0x2, 0x2, 0xbd3, 0x237, 
       0x3, 0x2, 0x2, 0x2, 0xbd4, 0xbd5, 0x9, 0x23, 0x2, 0x2, 0xbd5, 0x239, 
       0x3, 0x2, 0x2, 0x2, 0x171, 0x23b, 0x245, 0x250, 0x254, 0x264, 0x266, 
       0x26a, 0x272, 0x279, 0x27c, 0x282, 0x287, 0x28d, 0x295, 0x297, 0x2a0, 
       0x2a4, 0x2a8, 0x2ab, 0x2af, 0x2b2, 0x2b9, 0x2bd, 0x2c0, 0x2c3, 0x2c6, 
       0x2cc, 0x2dd, 0x2e1, 0x2e7, 0x2ee, 0x2f4, 0x2fa, 0x2fe, 0x300, 0x308, 
       0x30d, 0x31a, 0x327, 0x336, 0x33b, 0x33f, 0x346, 0x349, 0x351, 0x355, 
       0x358, 0x35f, 0x366, 0x36a, 0x36f, 0x373, 0x376, 0x37b, 0x38a, 0x391, 
       0x399, 0x3a1, 0x3aa, 0x3b1, 0x3b8, 0x3c0, 0x3c8, 0x3d0, 0x3d8, 0x3e0, 
       0x3e8, 0x3f1, 0x3f9, 0x402, 0x418, 0x420, 0x422, 0x425, 0x42b, 0x43e, 
       0x44f, 0x458, 0x45d, 0x464, 0x474, 0x479, 0x4d9, 0x4de, 0x4e2, 0x4ea, 
       0x4f1, 0x4f6, 0x4ff, 0x505, 0x50c, 0x516, 0x526, 0x532, 0x53e, 0x547, 
       0x54e, 0x553, 0x559, 0x564, 0x575, 0x578, 0x57d, 0x582, 0x588, 0x58d, 
       0x592, 0x59a, 0x5a0, 0x5a6, 0x5ad, 0x5b6, 0x5be, 0x5c2, 0x5c9, 0x5cb, 
       0x5df, 0x5e3, 0x5e9, 0x5ee, 0x5f2, 0x5f5, 0x5fc, 0x603, 0x607, 0x610, 
       0x620, 0x62a, 0x62f, 0x637, 0x639, 0x641, 0x657, 0x65c, 0x65f, 0x66b, 
       0x6af, 0x6b5, 0x6ba, 0x6bd, 0x6c2, 0x6c5, 0x6cc, 0x6d5, 0x6da, 0x6dd, 
       0x6e1, 0x6e5, 0x6e9, 0x6ee, 0x6f3, 0x6f9, 0x6ff, 0x704, 0x70a, 0x710, 
       0x713, 0x719, 0x71d, 0x721, 0x724, 0x72c, 0x72e, 0x734, 0x737, 0x73a, 
       0x73d, 0x741, 0x745, 0x74b, 0x755, 0x75b, 0x761, 0x766, 0x76b, 0x76f, 
       0x77c, 0x782, 0x786, 0x78c, 0x791, 0x7a0, 0x7a4, 0x7a9, 0x7ae, 0x7b3, 
       0x7b9, 0x7bc, 0x7c5, 0x7c9, 0x7ce, 0x7d2, 0x7d8, 0x7df, 0x7f0, 0x7f2, 
       0x7f9, 0x7fe, 0x805, 0x809, 0x80d, 0x815, 0x81b, 0x821, 0x825, 0x827, 
       0x82b, 0x830, 0x834, 0x837, 0x83a, 0x83d, 0x842, 0x846, 0x849, 0x84d, 
       0x850, 0x852, 0x857, 0x85e, 0x865, 0x869, 0x86f, 0x875, 0x878, 0x87a, 
       0x880, 0x885, 0x888, 0x88e, 0x895, 0x89a, 0x89d, 0x89f, 0x8a3, 0x8a9, 
       0x8b5, 0x8b9, 0x8bb, 0x8bf, 0x8c4, 0x8c7, 0x8ce, 0x8d2, 0x8d7, 0x8d9, 
       0x8dd, 0x8ed, 0x8f2, 0x8f4, 0x8fa, 0x8fe, 0x904, 0x90e, 0x915, 0x918, 
       0x926, 0x93d, 0x951, 0x95e, 0x961, 0x970, 0x974, 0x97a, 0x97e, 0x987, 
       0x999, 0x99e, 0x9a3, 0x9a9, 0x9ae, 0x9b1, 0x9b5, 0x9b7, 0x9be, 0x9c3, 
       0x9ca, 0x9d1, 0x9d6, 0x9da, 0x9de, 0x9e3, 0x9e7, 0x9ed, 0x9ef, 0x9f5, 
       0x9fa, 0xa00, 0xa04, 0xa06, 0xa09, 0xa0d, 0xa11, 0xa13, 0xa15, 0xa18, 
       0xa25, 0xa27, 0xa31, 0xa34, 0xa3a, 0xa3d, 0xa40, 0xa49, 0xa50, 0xa56, 
       0xa5a, 0xa5c, 0xa5f, 0xa62, 0xa66, 0xa6b, 0xa78, 0xa7d, 0xa81, 0xa85, 
       0xa8a, 0xa8f, 0xa93, 0xa96, 0xa9a, 0xaa5, 0xaa9, 0xab0, 0xab5, 0xab9, 
       0xabf, 0xac3, 0xac7, 0xad0, 0xadd, 0xae2, 0xae9, 0xaed, 0xaf0, 0xaf3, 
       0xaf6, 0xafa, 0xaff, 0xb07, 0xb0b, 0xb0f, 0xb15, 0xb1a, 0xb1e, 0xb24, 
       0xb2a, 0xb2d, 0xb30, 0xb40, 0xb48, 0xb51, 0xb56, 0xb59, 0xb5d, 0xb61, 
       0xb66, 0xb6c, 0xb71, 0xb75, 0xb7e, 0xb87, 0xb95, 0xb9d, 0xba2, 0xba7, 
       0xbd2, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

ReentParser::Initializer ReentParser::_init;
